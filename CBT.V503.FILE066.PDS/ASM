./ ADD NAME=ASCBSLOT 0117-96033-09086-0927-00103-00058-00054-TCACF0  00
         TITLE '*** ASCBSLOT ***'
ASCBSLOT MOWSTART
ASCBSLOT AMODE 31
ASCBSLOT RMODE 24
**********************************************************************
* CODE TO SCAN THROUGH ASCBS AND REPORT ON AUX STOR SLOTS IN USE     *
* BY ADDRESS SPACE. SEE INFO APAR II06400.                           *
**********************************************************************
MOWWORK  DSECT
ASCBTAB  DC    1600CL16'INIT'      NAME, NON-VIO SLOTS, VIO SLOTS
ASCBSLOT CSECT
         USING CVT,R10             BASE REG FOR CVT
         USING ASVT,R9             BASE REG FOR ASVT
         USING ASCB,R7             BASE REG FOR ASCB
         USING ASMVT,R6            BASE REG FOR ASMVT
         OPEN  (SYSPRINT,(OUTPUT)) OPEN OUTPUT FILE
         L     R10,CVTPTR          LOAD CVT BASE REG
         L     R6,CVTASMVT         POINT TO ASMVT
         L     R9,CVTASVT          AND ASVT BASE REG
         LA    R10,ASVTFRST-4      NOW POINT TO ASVT ENTRY
         L     R8,ASVTMAXU         POINT TO MAX NUM ASVTS
         L     R1,ASMSLOTS         GET TOTAL SLOT COUNT
         CVD   R1,DOUBLE           MAKE IT DECIMAL
         MVC   MSG0+13(8),=X'4020202020202120'
         ED    MSG0+13(8),DOUBLE+4 EDIT NUMBER INTO IT
*        TPUT  MSG0,L'MSG0         DISPLAY RESULT
         PUT   SYSPRINT,MSG0       DISPLAY HEADING
SCANLIST EQU   *
         LA    R10,4(R10)          NEXT ASVTENTY
         TM    0(R10),ASVTAVAI     TEST FOR ASID UN-ASSIGNED
         BO    UNUSED              ITS NOT IN USE
         L     R7,0(R10)           A(ASCB)
         L     R1,ASCBJBNI         POINTER TO JOB NAME
         LTR   R1,R1               ZERO IF ITS A STC
         BNZ   GETNAME             NOT ZERO SO ITS A JOB
         L     R1,ASCBJBNS         POINTER TO STC NAME
GETNAME  EQU   *
         LH    R2,ASCBASID         GET ASID FOR THIS ADDRESS SPACE
         SLL   R2,4                MULTIPLY BY 16
         LA    R6,ASCBTAB(R2)      POINT TO ASCB TABLE SLOT
         MVC   0(8,R6),0(R1)       FILL APPROPRIATE SLOT IN TABLE
         MVC   MSG(8),0(R1)        PUT JOBNAME IN MSG
         L     R2,ASCBASSB         POINT TO ASSB
         USING ASSB,R2
         L     R1,ASSBNVSC
         STCM  R1,B'1111',8(R6)    SAVE NON-VIO SLOT COUNT IN TABLE
         CVD   R1,DOUBLE           MAKE IT DECIMAL
         MVC   MSG+13(8),=X'4020202020202120'
         ED    MSG+13(8),DOUBLE+4  EDIT NUMBER INTO IT
         L     R1,ASSBVSC
         STCM  R1,B'1111',12(R6)   SAVE VIO SLOT COUNT IN TABLE
         CVD   R1,DOUBLE           MAKE IT DECIMAL
         MVC   MSG+31(8),=X'4020202020202120'
         ED    MSG+31(8),DOUBLE+4  EDIT NUMBER INTO IT
*        TPUT  MSG,L'MSG           DISPLAY RESULT
UNUSED   EQU   *
         BCT   R8,SCANLIST
SORTED   EQU   *                   SORT INTO DESCENDING ORDER OF USAGE
         L     R8,ASVTMAXU         POINT TO MAX NUM ASVTS
         LA    R7,ASCBTAB
         LR    R6,R8               COPY COUNT OF ENTRIES
         SLL   R6,4                MULTIPLY BY 16
         AR    R7,R6               POINT TO END OF TABLE
         #SORT FIELDS=(8,4,BI,D),FIRST=ASCBTAB,LAST=(7),LENGTH=16
         L     R8,ASVTMAXU         SET LOOP MAXIMUM
         LA    R7,ASCBTAB          POINT TO TABLE
SORTED10 EQU   *
         CLI   0(R7),X'00'         IS ASCBNAME NULL?
         BE    SORTED20            YES, DON'T SHOW IT
         MVC   MSG(8),0(R7)        MOVE NAME INTO OUTPUT MSG
         ICM   R1,B'1111',8(R7)    GET NON-VIO SLOT COUNT FROM TABLE
         CVD   R1,DOUBLE           MAKE IT DECIMAL
         MVC   MSG+13(8),=X'4020202020202120'
         ED    MSG+13(8),DOUBLE+4  EDIT NUMBER INTO IT
         ICM   R1,B'1111',12(R7)   GET VIO SLOT COUNT FROM TABLE
         CVD   R1,DOUBLE           MAKE IT DECIMAL
         MVC   MSG+31(8),=X'4020202020202120'
         ED    MSG+31(8),DOUBLE+4  EDIT NUMBER INTO IT
*        TPUT  MSG,L'MSG           DISPLAY RESULT
         PUT   SYSPRINT,MSG
         MVI   MSG,C' '
         MVC   MSG+1(L'MSG-1),MSG
SORTED20 EQU   *
         LA    R7,16(,R7)          POINT TO NEXT ENTRY
         BCT   R8,SORTED10
FIN      EQU   *
         CLOSE SYSPRINT
         MOREND
DOUBLE   DC    D'0'
MSG0     DC    CL80'TOTAL SLOTS  NNNNNNNN '
*                   0123456789 123456789 123456789 1234567890
MSG      DC    CL80'XXXXXXXX HAS NNNNNNNN NON-VIO, NNNNNNNN VIO SLOTS'
SYSPRINT DCB   DDNAME=SYSPRINT,MACRF=PM,DSORG=PS,LRECL=80,RECFM=FB
         EJECT
CVT      DSECT
         CVT   DSECT=YES
         EJECT
         IHAASCB
         IHAASSB
         EJECT
         ILRASMVT
         IHAASVT
         END
./ ADD NAME=CHPID    0100-03311-03311-1200-00087-00087-00000-FILE066 00
         TITLE '*** CHPID ***'
CHPID    MOWSTART
CHPID    AMODE 31
CHPID    RMODE 24
***********************************************************************
* DETERMINE CHANNEL/PCHID INFO. BE SURE TO RUN IT ON THE CORRECT      *
* PROCESSOR.                                                          *
* PARM='P=XXX'    XXX IS PCHID NUMBER                                 *
***********************************************************************
CHPID    CSECT
         L     R1,0(R1)                 -> TO PARM
         LH    R2,0(R1)                 GET LENGTH OF PARM
         LTR   R2,R2                    IS THERE ONE?
         BZ    FIN                      NO PARM, JUST EXIT.
         LA    R1,4(R1)                 -> TO PARM DATA, P=XXX OR C=XX
         SH    R2,=H'2'                 ADJUST LENGTH FOR THE P= OR C=
         MVC   PCH(3),0(R1)             COPY XXX
         TR    PCH(3),TRANTAB
         PACK  PCHX(3),PCH(4)           PACK IT
         USING CVT,R2
         L     R2,16                    A(CVT)
         L     R2,CVTHID                HOST ID
         USING SHID,R2
         CLI   CPCND_FLAGS,0            HID AVAILABLE?
         MVC   CMODEL(4),CPCND_TYPE+2   CPU MODEL
         MVC   CCPUID(6),CPCND_SEQNO+6  SERIAL #
         LA    R4,PCHID                 POINT TO PCHID TABLE
         LA    R2,256                   MAX NUMBER OF CHPIDS
         SR    R3,R3                    STARTING CHPID
LOOP     EQU   *
         STH   R3,CHP                   SAVE CHP NUMBER
         IOSCHPD CHPID=CHP,DESC=DATA,ACRONYM=ACRO,ATTR=ATTR
         LTR   R15,R15                  CHECK RETURN CODE
*        BNZ   FIN                      DON'T CARE. JUST FILL UP TABLE
         LA    R11,ATTR                 POINT TO RETURNED DATA
         USING CHPDATTR,R11             MAP RETURNED AREA
         MVC   0(2,R4),CHPDA_CHID       COPY PCHID
         UNPK  CCHAN+17(3),CHP+1(2)     JUST UNPACK THE DATA
         NC    CCHAN+17(3),=2X'0F'      MAKE IT BINARY
         TR    CCHAN+17(3),=C'0123456789ABCDEF' CONVERT TO CHARACTER
         UNPK  CCHAN+07(4),CHPDA_CHID(3) JUST UNPACK THE DATA
         NC    CCHAN+07(4),=3X'0F'      MAKE IT BINARY
         TR    CCHAN+07(4),=C'0123456789ABCDEF' CONVERT TO CHARACTER
         MVI   CCHAN+10,X'40'
         CLC   CHPDA_CHID(3),PCHX       THE PCHID WE'RE LOOKING FOR?
         BNE   NEXTCHP                  NO
         MVC   CCHAN+20(5),ACRO         CHANNEL TYPE
         MVI   CCHAN+19,X'40'
         TPUT  CMODEL,35
         MVI   WTOMSG+4,X'40'           BLANK TO BYTE 1 OF MESSAGE
         B     NEXTCHP                  NO
         MVC   WTOMSG+5(79),WTOMSG+4    AND BLANK ENTIRE FIELD
         MVC   WTOMSG+4(34),CMODEL      MOVE RESPONSE DATA
         WTO   MF=(E,WTOMSG)            DO WTO BECAUSE WE MUST BE STC
NEXTCHP  EQU   *
         LA    R4,2(,R4)                POINT TO NEXT PCHID SLOT
         LA    R3,1(,R3)                ADD 1 TO CHANNEL #
         BCT   R2,LOOP                  DO ALL 256 CHANNELS
FIN      EQU   *
         MOREND
         SPACE
PCHX     DC    X'0000'                   PCHID
CHP      DC    X'0000'                   CHPID NUMBER 00-FF
PCH      DC    C'4B1'
CMODEL   DC    CL04'    '                CPU MODEL
CCPUID   DC    CL06'      '              CPU SERIAL #
CCHAN    DC    CL25' PCHID XXX CHP 0.XX XXXXX'
*                   0123456789 123456789 123456789
DATA     DC    CL32' '
ATTR     DC    CL32' '
ACRO     DC    CL5' '
WTOMSG   WTO   '0123456789 123456789 123456789 123456789 123456789 1234*
               56789 123456789 123456789',                             *
               ROUTCDE=(2),MF=L
TRANTAB  DS    0CL256
         DC    256AL1(*-TRANTAB)   MAKE X'00'-X'FF' INTO THEMSELVES
         ORG   TRANTAB+C'A'
         DC    X'0A0B0C0D0E0F'           ABCDEF
         ORG   TRANTAB+C'0'
         DC    X'00010203040506070809'   0123456789
PCHID    DC    256X'0000'
         IOSDCHPD
         IOSDPATH
         IOSDSHID                      SYSTEM HOST ID MAPPING
         PRINT NOGEN
         CVT   DSECT=YES
         END
./ ADD NAME=CPCMD    0100-03311-03311-1200-00309-00309-00000-FILE066 00
         TITLE '*** CPCMD ***'
CPCMD    MOWSTART SP=250
CPCMD    AMODE 31
CPCMD    RMODE 24
*********************************************************************
*                                                                   *
* PROGRAM TO RUN ON MVS TO ISSUE VM/CP COMMAND.                     *
* MAY BE RUN AS A TSO COMMAND, EXECUTED AS A PROGRAM, OR RUN AS A   *
* STARTED TASK.                                                     *
* LINK WITH AC(1). NAME IS CPCMD WITH ALIAS CP.                     *
*                                                                   *
* E.G. (1) // EXEC PGM=CPCMD,PARM='Q CPUID'                         *
*      (2) CP Q CPUID                                               *
*      (3) // EXEC PGM=CPCMD                                        *
*          //SYSIN DD *                                             *
*          Q CPUID                                                  *
*          ATT 76A MVSXA 76A                                        *
*          /*                                                       *
*                                                                   *
* IF IN BATCH, AND A SYSIN DD IS PRESENT, THE PARM IS IGNORED AND   *
* THE COMMANDS ARE READ FROM THE SYSIN FILE.                        *
*                                                                   *
*********************************************************************
MOWWORK  DSECT
TIOT     DC    F'0'           EXTRACT WORK AREA, KEEP    (1)
TSO      DC    F'0'            THESE 3 TOGETHER AND      (2)
ASID     DC    F'0'             IN THIS ORDER.           (3)
SAVEREG  DC    2F'0'          PLACE TO SAVE REGISTERS
*
ACMD     DC    A(0)           THESE FOUR FULL WORDS      (1)
ABUF     DC    A(0)            MUST REMAIN               (2)
CMDL     DC    F'0'             IN THE SAME RELATIVE     (3)
RESPBUFL DC    F'0'              POSITIONS.              (4)
CMDFLG   DC    X'00'          INDIC. COMMAND, PROGRAM OR STARTED TASK
SYSINFLG EQU   X'80'
LPRFLG   EQU   X'40'          VM GUEST OR LPAR?
STCFLG   EQU   X'04'
BATFLG   EQU   X'02'
TSOFLG   EQU   X'01'
         DS    XL7            UNUSED
         SPACE 2
CPCMD    CSECT
         USING CVT,R10
         USING ASVT,R9
         USING ASCB,R8
         LR    R11,R1                   COPY A(PARM)
         L     R10,16                   A(CVT)
         L     R3,CVTECVT               POINT TO ECVT
         USING ECVT,R3
         CLC   =CL1' ',ECVTVMNM         ARE WE RUNNING UNDER VM?
         BNE   VMGST                    YES
         TPUT  =CL33'CMD NOT VALID. RUNNING NATIVE MVS',33
         B     FIN1
VMGST    EQU   *
         L     R9,CVTASVT               A(ASVT)
         LA    R9,ASVTFRST              -> FIRST ASVT ENTRY
         LA    R7,TIOT                  POINT TO RETURN AREA
         EXTRACT (7),FIELDS=(TSO,ASID,TIOT)  EXTR TO GET STUFF
         MVI   CMDFLG,TSOFLG            INITIALIZE CMD FLAG
         L     R7,TSO                   -> TO TSO INDICATOR
         TM    0(R7),X'80'              ARE WE ON TSO?
         BO    GOTTYPE                  IT WAS
         MVI   CMDFLG,BATFLG            NOW A 1, TEST FOR JOB
         L     R8,ASID                  GET ASID INTO A REG
         SLL   R8,2                     MULTIPLY BY 4
         L     R8,0(R8,R9)              NOW HAS A(OUR ASCB)
         CLC   ASCBJBNI,=F'0'           TEST FOR JOB
         BNE   GOTTYPE                  NOT ZERO, SO ITS A JOB
         MVI   CMDFLG,STCFLG            NOW ITS A 2, STC
GOTTYPE  EQU   *
         TM    CMDFLG,TSOFLG            IN TSO MODE?
         BO    GETPARM                  YES, SO GETPARM
         LA    R3,=CL8'SYSIN'           DDNAME TO LOOK FOR
         BAL   R10,TIOTSCAN             GO SEE IF THERE IS ONE
         BNE   GETPARM                  WASN'T A SYSIN
         OI    CMDFLG,SYSINFLG          SET SYSIN FLAG ON
         OPEN  (SYSIN,(INPUT))          OPEN IT
         B     COMP4                    AND GO GET WORK AREA
*********************************************************************
* DETERMINED WHO WE ARE, PROCESS ACCORDINGLY                        *
*********************************************************************
GETPARM  EQU   *
         LR    R1,R11         RESTORE A(PARM)
         ICM   R2,B'1111',0(R1)  POINT TO PARAMETER
         LH    R1,0(R2)       PICK UP LENGTH
         BL    COMP4          ONLY ONE PARM
         SH    R1,=H'4'       CALL FROM TMP
         SH    R1,2(R2)
         LA    R2,2(,R2)      PREFIX IS 4 BYTES
         AH    R2,0(R2)       SKIP OVER COMMAND NAME
         STH   R1,0(R2)       PUT LENGTH OF CP CMD IN CORRECT PLACE
COMP4    EQU   *
         LH    R5,BUFLEN              LENGTH OF BUFFER AREA
         GETMAIN RU,LV=(R5),SP=250,BNDRY=PAGE  FOR FOR RETURNED DATA
         ST    R1,ABUF                A(RESPBUF) - SAVE IT
         TM    CMDFLG,SYSINFLG+BATFLG READING FROM SYSIN?
         BO    CMDOK                  YES
         LH    R3,0(R2)               GET LENGTH OF COMMAND
         LTR   R3,R3                  IS THERE ANY LENGTH?
         BP    CMDOK                  GO TRY TO DO IT
NOCMDTXT EQU   *
         MVC   0(26,R1),=C'NO CP COMMAND TEXT ENTERED'
         MVI   26(R1),X'15'           NEW LINE CHAR
         MVC   RESPBUFL,=F'27'        LENGTH OF MESSAGE
         B     RESULT         PRETEND WE DID IT, BUT TELL ERROR MSG
CMDOK    EQU   *
         TM    CMDFLG,SYSINFLG+BATFLG PROCESSING A SYSIN FILE?
         BNO   CMDOK1                 NO, USE VALUE IN PARM
         GET   SYSIN                  GET A RECORD FROM SYSIN
         LA    R3,71(,R1)             POINT TO END OF RECORD
SCAN1    EQU   *
         CLI   0(R3),C' '             A BLANK
         BNE   SCAN2                  NO
         BCTR  R3,0                   BACK UP A CHAR
         B     SCAN1                  AND CHECK IT
SCAN2    EQU   *
         SR    R3,R1                  NOW R3 HAS LENGTH OF COMMAND
         LA    R3,1(R3)               ADD 1 BACK TO GET REAL LENGTH
         LR    R2,R1                  COPY POINTER TO COMMAND TEXT
         SH    R2,=H'2'               DO THIS SO MOVCMD INSTR WILL WORK
CMDOK1   EQU   *
         L     R1,ABUF                RESTORE REG 1
         ST    R3,CMDL                SAVE LENGTH
         LH    R5,BUFLEN              RELOAD LENGTH
         LA    R1,0(R1,R5)            GET EOBUFF.....
         SR    R1,R3                  ....MINUS CMD LENGTH AND .....
         N     R1,=F'-8'              .....ROUND BACK TO DOUBLEWORD.
         ST    R1,ACMD                SAVE COMMAND ADDRESS
         BCTR  R3,0                   AND
         EX    R3,MOVCMD              MOVE IT TO IT'S NEW HOME
         LR    R2,R1
         S     R1,ABUF                SUBT START OF RESP. AREA
         ST    R1,RESPBUFL            TO GET LENGTH
         LA    R3,1(,R3)              GET ORIGINAL CMD LENGTH
         LR    R0,R3                  AND COPY ITS VALUE
         BCTR  R2,0
MAKEUP   EQU   *
         LA    R1,0(R2,R3)            ENSURE
         OI    0(R1),X'40'               UPPER
         BCT   R3,MAKEUP                     CASE
         SPACE 3
*********************************************************************
* THE FOLLOWING TESTS FOR COMMANDS WE AREN'T ALLOWED TO ISSUE       *
*********************************************************************
         L     R5,CMDL                  GET COMMAND LENGTH
NONBLNK  EQU   *
         CLI   0(R1),X'40'              IS THIS A BLANK?
         BNE   CMDSTRT                  NO, GO TO CHECK COMMAND
         LA    R1,1(R1)                 POINT TO NEXT CHAR
         BCT   R0,NONBLNK               AND CHECK IT
         L     R1,ABUF
         B     NOCMDTXT
CMDSTRT  EQU   *
         CLC   =C'CP ',0(R1)            DID CMD START WITH CP?
         BNE   NOCPREFX                 NO
         LA    R1,3(,R1)                POINT TO START OF COMMAND
         SH    R0,=H'3'                 ADJUST LENGTH
         LR    R5,R0                    COPY LENGTH
         B     NONBLNK
NOCPREFX EQU   *
         MVI   WTOMSG+4,X'40'       MOVE A BLANK TO BYTE 1 OF MESSAGE
         MVC   WTOMSG+5(79),WTOMSG+4    AND BLANK ENTIRE FIELD
         MVC   WTOMSG+4(8),=C'WET207I ' SET MSGID
         BCTR  R5,0                     ADJUST FOR EXECUTED MOVE
         STM   R0,R1,SAVEREG            SAVE THESE REGS OVER WTO
         EX    R5,MVCCMD                PUT COMMAND IN WTO BUFFER
         WTO   MF=(E,WTOMSG)            ECHO COMMAND
         LM    R0,R1,SAVEREG            RESTORE THESE REGS
         CH    R0,=H'3'                 LENGTH OF COMMAND
         BL    ALLOWED
         CLC   =C'LOG',0(R1)            LOGOFF
         BE    NOTALOWD
         CLC   =C'I ',0(R1)             IPL
         BE    NOTALOWD
         CLC   =C'IPL',0(R1)            IPL
         BE    NOTALOWD
         CH    R0,=H'4'                 LENGTH OF COMMAND
         BL    ALLOWED
         CLC   =C'DISC',0(R1)           DISCONNECT
         BE    NOTALOWD
         CH    R0,=H'8'                 LENGTH OF COMMAND
         BL    ALLOWED
         CLC   =C'SHUTDOWN',0(R1)       SHUTDOWN
         BE    NOTALOWD
ALLOWED  EQU   *
         MODESET KEY=ZERO,MODE=SUP
         L     R5,ABUF           A(BUF)
         LH    R11,BUFLEN        LENGTH OF TOTAL AREA
         BCTR  R11,0             SUBTRACT ONE
         LA    R7,0(R5,R11)      COMPUTE END ADDRESS OF AREA
         PGSER R,FIX,A=(R5),EA=(R7),ECB=0  FIX PAGES IN STORAGE
         L     R8,ACMD           A(CMD)
         LRA   R8,0(R8)          POINT TO REAL ADDRESS OF CMD
         LRA   R9,0(R5)          POINT TO REAL ADDRESS OF BUF
         L     R10,CMDL          LENGTH OF COMMAND TO EXECUTE
         L     R11,RESPBUFL      LENGTH OF RETURN AREA
         O     R10,=X'40000000'  INDICATE RETURN RESPONSE IN BUFFER
         DC    X'838A0008'       DIAGNOSE INSTR - NO OPCODE
         BNZ   *+8               LEAVE LEN ALONE IF NOT ALL FIT
         ST    R11,RESPBUFL      LENGTH OF RESP
         PGSER R,FREE,A=(R5),EA=(R7)  NOW FREE UP PAGES AGAIN
         MODESET KEY=NZERO,MODE=PROB
         SPACE
RESULT   L     R2,RESPBUFL    LOAD IN LENGTH OF RETURNED TEXT
         LTR   R2,R2          SET COND CODE
         BNP   FIN            NO RESPONSE TO COMMAND
         SPACE
*********************************************************************
* PROCESS RESPONSE FOR CALLER                                       *
*********************************************************************
         L     R3,ABUF        POINT TO START OF RETURNED TEXT
         TM    CMDFLG,BATFLG  IS THIS BATCH EXECUTION?
         BNO   DOPUTS         NO, ITS A COMMAND OR STC
         OPEN  (SYSPRINT,(OUTPUT)) ONLY FOR JOB/BATCH EXECUTION
         TM    SYSPRINT+48,X'10'   DID IT OPEN?
         BNO   FIN            NO, SOME PROBLEM SO JUST END
         SPACE
DOPUTS   EQU   *
         LR    R1,R3          COPY POINTER TO START OF LINE
SCAN     CLI   0(R3),X'15'    NEW LINE CHAR
         BE    GETLEN         YES, SO CALCULATE LEN FOR TPUT
         LA    R3,1(R3)       POINT TO NEXT CHAR
         BCT   R2,SCAN        AND CHECK IT WHILE THERE ARE SOME
         TM    CMDFLG,SYSINFLG+BATFLG   PROCESSING A SYSIN STREAM?
         BO    CMDOK          YES, GET MORE TO DO
         B     FIN            NO MORE BUFFER
GETLEN   EQU   *
         LR    R0,R3          CALCULATE LENGTH OF TEXT TO PUT
         SR    R0,R1          LENGTH TO BE PUT
         STH   R0,SYSPRINT+82 SAVE THE LENGTH
         LR    R5,R0          COPY LENGTH OF TEXT
         LR    R7,R1          COPY POINTER TO DATA
         TPUT  (1),(0),R      ISSUE TPUT (NO-OP IN BATCH)
         TM    CMDFLG,TSOFLG  IS IT TSO?
         BO    NXTLINE        YES, SO DON'T DO PUT TO SYSPRINT
         TM    CMDFLG,BATFLG  IS IT BATCH?
         BO    BATCHPUT       YES, SO DO PUT TO SYSPRINT
         MVI   WTOMSG+4,X'40' MOVE IN A BLANK TO BYTE 1 OF MESSAGE
         MVC   WTOMSG+5(79),WTOMSG+4 AND BLANK ENTIRE FIELD
         BCTR  R5,0           SUBTRACT 1 FOR EXECUTED MOVE
         EX    R5,WTOTEXT     MOVE TEXT TO WTO MESSAGE AREA
         WTO   MF=(E,WTOMSG)  AND DO WTO BECAUSE WE MUST BE STC
         B     NXTLINE        GO TO NEXT LINE
BATCHPUT EQU   *
         PUT   SYSPRINT,(7)   WRITE OUTPUT TO SYSPRINT
NXTLINE  LA    R3,1(R3)       -> TO CHAR FOLLOWING X'15' FOR NEXT PUT
         BCT   R2,DOPUTS      SUBTRACT ONE FOR CHARS LEFT TO DO
         TM    CMDFLG,SYSINFLG+BATFLG   PROCESSING A SYSIN STREAM?
         BO    CMDOK          YES, GET MORE TO DO
         B     FIN            NO MORE BUFFER
NOTALOWD EQU   *
         LA    R8,30                    LENGTH OF RESPONSE + 1
         ST    R8,RESPBUFL              SAVE LENGTH
         L     R15,ABUF                 A(BUFFER)
         MVC   0(29,R15),=CL29'COMMAND NOT ALLOWED:          '
         MVI   29(R15),X'15'            LF
         TM    CMDFLG,LPRFLG            SPECIAL MESSAGE?
         BZ    CMDNAM                   NO
         MVC   21(8,R15),=CL8'NOT VM'
         B     RESULT
CMDNAM   EQU   *
         MVC   21(8,R15),0(R1)          MOVE IN COMMAND NAME
         B     RESULT                   RETURN
         SPACE 2
FIN      EQU   *
         CLOSE (SYSPRINT,,SYSIN)        EVEN IF IT WASN'T OPEN
         L     R1,ABUF                  ADDRESS OF WORK AREA TO FREE
         LH    R5,BUFLEN                AND LENGTH
         FREEMAIN R,LV=(5),A=(1),SP=250 FREE GOTTEN STORAGE
FIN1     EQU   *
         MOREND SP=250
         EJECT
***********************************************************************
*  CODE FOR TIOTSCAN SUB                                              *
***********************************************************************
TIOTSCAN EQU   *
         L     R2,TIOT          LOAD ADDRESS
         LA    R2,24(R2)        AND AGAIN
         XR    R4,R4            CLEAR A REGISTER
TIOTSC1  IC    R4,0(R2)         PUT A BYTE IN A REGISTER
         LTR   R4,R4            SEE IF IT WAS ZERO
         BZ    NOTIN
         TM    3(R2),B'00010000'   IS IT DD DYNAM?
         BO    *+10             YES, SO SKIP AROUND THIS
         CLC   0(8,R3),4(R2)    IS THIS SAME NAME AS WE ARE SEEKING
         BCR   8,R10            YES IT IS, SO JUST RETURN
         AR    R2,R4            POINT TO NEXT ENTRY
         B     TIOTSC1          GO BACK AND LOOK AT IT
NOTIN    CLI   *,0              SET CONDITION CODE NOT EQUAL
         BR    R10              RETURN WITH NON ZERO CONDITION CODE
         EJECT
         DS    0H
BUFLEN   DC    H'4096'          SIZE OF RESPONSE/COMMAND BUFFER
*                               MAY BE SMALLER, BUT DON'T MAKE BIGGER.
MVCCMD   MVC   WTOMSG+4+8(*-*),0(R1)    MOVE COMMAND TO WTO FOR ECHO
MOVCMD   MVC   0(*-*,R1),2(R2)
WTOTEXT  MVC   WTOMSG+4(*-*),0(R7)      EXECUTED MOVE INSTR
WTOMSG   WTO   '0123456789 123456789 123456789 123456789 123456789 1234*
               56789 123456789 123456789',                             *
               ROUTCDE=(2),MF=L
         PRINT NOGEN
SYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=(GL),LRECL=80,RECFM=FB,     *
               EODAD=FIN
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),LRECL=80,RECFM=U
         IHAASVT
         IHAASCB
         IHAECVT
         CVT   DSECT=YES
         END
./ ADD NAME=CPFSET   0146-94075-07141-1100-00052-00012-00051-TCACF0  00
         TITLE '*** CPFSET ***'
CPFSET   MOWSTART
CPFSET   AMODE  31
CPFSET   RMODE  ANY
**********************************************************************
* ESTABLISH COMMAND PROCESSOR FACILITY PREFIXES.                     *
* USE D OPDATA OPERATOR COMMAND TO SEE WHAT PREFIXES ARE DEFINED.    *
* DOC: AUTHORIZED ASSEMBLER SERVICES GUIDE                           *
* GOES IN SYS2.LINKLIB, AC(1)                                        *
**********************************************************************
MOWWORK  DSECT
         CPF    MF=(L,CPFLST)
CPFSET   CSECT
         LA     R10,NENT               NUMBER OF TABLE ENTRIES
         LA     R2,PFXOWN              POINT TO FIRST PREFIX
         LA     R3,PFXOWN+8            POINT TO FIRST OWNER
         MODESET MODE=SUP,KEY=ZERO     GO SUPERVISOR STATE/KEY ZERO
SET010   EQU    *
         CPF    REQUEST=DEFINE,PREFIX=(R2),OWNER=(R3),MF=(E,CPFLST)
         LA     R2,16(,R2)             POINT TO NEXT PREFIX
         LA     R3,16(,R3)             POINT TO NEXT OWNER
         BCT    R10,SET010
         MODESET MODE=PROB,KEY=NZERO   RETURN TO PROBLEM STATE/NON-ZERO
         MOREND
PFXOWN   EQU    *   PREFIX        OWNER
         DC     CL8'¢       ',CL8'PANV    '       CA-PANVALET SUBSYS
         DC     CL8'.       ',CL8'SLS0    '       STK NCS
*        DC     CL8'<       ',CL8'        '
         DC     CL8'(       ',CL8'OPSSATM '       AUTO OPS
         DC     CL8'+       ',CL8'DB2     '       DB2
*        DC     CL8'|       ',CL8'        '
         DC     CL8'&&      ',CL8'        '
         DC     CL8'!       ',CL8'OPSSOSF '       AUTO OPS
         DC     CL8'$       ',CL8'JES2    '       JES2
         DC     CL8'*       ',CL8'JES3    '       JES3
*        DC     CL8')       ',CL8'        '
*        DC     CL8';       ',CL8'        '       CMD DELIM
         DC     CL8'-       ',CL8'DB2     '       DB2
*        DC     CL8'/       ',CL8'        '       DON'T USE SEE CMDEXIT
*        DC     CL8',       ',CL8'        '
         DC     CL8'%       ',CL8'NETVIEW '       NETVIEW
         DC     CL8'_       ',CL8'SMC     '       STK SMC
*        DC     CL8'>       ',CL8'        '
         DC     CL8'?       ',CL8'OPSSECF '       AUTO OPS
         DC     CL8':       ',CL8'MIA     '       MIA
         DC     CL8'#       ',CL8'DIF     '       SRS DIF (X-37 TRAP)
         DC     CL8'@       ',CL8'EMC-SRDF'       SRDF
*        DC     CL8'''      ',CL8'        '
         DC     CL8'        ',CL8'        '
*        DC     CL8'"       ',CL8'        '
NENT     EQU    (*-PFXOWN)/16
         END
./ ADD NAME=CSALST   0100-03311-03311-1200-00084-00084-00000-FILE066 00
         TITLE '*** CSALST ***'
CSALST   MOWSTART
CSALST   AMODE 31
CSALST   RMODE 24
**********************************************************************
* SCAN ASCBS TO GET FRAME COUNTS USED BY EACH A/S                    *
**********************************************************************
         USING ASVT,R9
         USING ASCB,R10
         USING CVTFIX,R11
         SR    R7,R7                      ZERO ACCUMULATOR
         L     R11,16                     CVT ADDR
         S     R11,=F'256'                BACK UP TO START OF PREFIX
         TPUT  MESS0,L'MESS0              PUT HEADING
         L     R9,CVTASVT                 A(ASVT)
         LA    R8,ASVTFRST                -> A(FIRST ASCB)
         TM    ASVTFRST,ASVTAVAI          TEST FOR INUSE OR AVAILABLE
         BO    NEXTASVT                   NOT IN USE, TRY NEXT ASVT
INUSE    EQU   *
         L     R10,0(R8)                  POINT TO FIRST ASCB
         L     R3,ASCBJBNI                POINTER TO JOBNAME
         LTR   R3,R3                      IF ITS ZERO, NOT A JOB
         BNZ   MOVENAME                   ITS A JOB
         L     R3,ASCBJBNS                POINTER TO STC/MOUNT/LOGON
MOVENAME EQU   *
         MVC   MESS1(8),0(R3)             MOVE IN JOB NAME
         LH    R3,ASCBASID                GET NUMBER OF THIS A/S
         CVD   R3,DOUBLE                  MAKE HIM DECIMAL FOR HUMANS
         MVC   MESS1+10(04),=X'40202120'
         ED    MESS1+10(04),DOUBLE+6      EDIT NUMBER INTO IT
*        LH    R4,ASCBFMCT                GET FRAME COUNT
         L     R2,ASCBRSME                GET RSM SPACE BLOCK EXTENSION
         USING RAX,R2
         L     R4,RAXFMCT                 GET FRAME COUNT
         DROP  R2
         AR    R7,R4                      SUM OF TOTAL PAGES
         CVD   R4,DOUBLE                  MAKE IT DECIMAL
         MVC   MESS1+22(07),=X'4020206B202120'
         ED    MESS1+22(07),DOUBLE+5      EDIT NUMBER INTO IT
         L     R2,ASCBLDA                 GET VSM LOCAL DATA AREA
         USING LDA,R2                     IF NOT X'FFFFFFFF' THEN
*        L     R4,LDASMFL                    IEFUSI HAS GOT AT THEM
*        C     R4,=F'-1'
*        BE    *+8
*        MVI   MESS1+37,C'Y'             'Y' INDICATES IEFUSI CHANGED
*        L     R4,LDASMFR
*        C     R4,=F'-1'
*        BE    *+8
*        MVI   MESS1+42,C'Y'
*        L     R4,LDASMFEL
*        C     R4,=F'-1'
*        BE    *+8
*        MVI   MESS1+47,C'Y'
*        L     R4,LDASMFER
*        C     R4,=F'-1'
*        BE    *+8
*        MVI   MESS1+53,C'Y'
         TPUT  MESS1,L'MESS1              SHOW RESULT
NEXTASVT EQU   *
         LA    R8,4(R8)                   NEXT ASVT ENTRY
         CLC   0(4,R8),=X'80000000'       LAST ONE IN CHAIN?
         BE    FIN                        YES, WE'VE LOOKED AT THEM ALL
         TM    0(R8),ASVTAVAL             IS IT IN USE
         BO    NEXTASVT                   NO, SO TRY NEXT ONE
         B     INUSE                      YES, GO GET DATA
FIN      EQU   *
         MVC   MESS1(15),=CL15'TOTAL'
         CVD   R7,DOUBLE                  MAKE IT DECIMAL
         MVC   MESS1+22(07),=X'4020206B202120'
         ED    MESS1+22(07),DOUBLE+5      EDIT NUMBER INTO IT
         TPUT  MESS1,L'MESS1              SHOW RESULT
         MOREND
DOUBLE   DS    D
MESS0    DC    CL80'JOBNAME   ASID    PAGE FRAME COUNT SMFL SMFR SMFEL *
               SMFER'
*                   0123456789 123456789 123456789 123456789 123456789
MESS1    DC    CL80'           XXX         XX,XXX'
         PRINT NOGEN
         CVT   DSECT=YES,PREFIX=YES
         IHAASVT
         IHAASCB
         IARRAX
         IHALDA
         END
./ ADD NAME=DISASM3B 0120-91091-09118-1230-00180-00161-00056-TCACF0  00
         EJECT
***********************************************************************
* SVC NAME TABLE - SYSTEM SVCS                                        *
***********************************************************************
SVCOP    DS    0CL15                          SVC NAME TABLE
         DC    AL1(0),CL14'EXCP/XDAP'
SVCNAML  EQU   *-SVCOP                        LENGTH OF EACH ENTRY
         DC    AL1(01),CL14'WAIT/WAITR/...'
         DC    AL1(02),CL14'POST'
         DC    AL1(03),CL14'EXIT'
         DC    AL1(04),CL14'GETMAIN'
         DC    AL1(05),CL14'FREEMAIN'
         DC    AL1(06),CL14'LINK'
         DC    AL1(07),CL14'XCTL'
         DC    AL1(08),CL14'LOAD'
         DC    AL1(09),CL14'DELETE'
         DC    AL1(10),CL14'GET/FREEMAIN R'
         DC    AL1(11),CL14'TIME'
         DC    AL1(12),CL14'SYNCH'
         DC    AL1(13),CL14'ABEND'
         DC    AL1(14),CL14'SPIE'
         DC    AL1(15),CL14'ERREXCP'
         DC    AL1(16),CL14'PURGE'
         DC    AL1(17),CL14'RESTORE'
         DC    AL1(18),CL14'BLDL/FIND'
         DC    AL1(19),CL14'OPEN'
         DC    AL1(20),CL14'CLOSE'
         DC    AL1(21),CL14'STOW'
         DC    AL1(22),CL14'OPEN TYPE J'
         DC    AL1(23),CL14'CLOSE TYPE T'
         DC    AL1(24),CL14'DEVTYPE'
         DC    AL1(25),CL14'TRKBAL'
         DC    AL1(26),CL14'LOCATE, ETC'
         DC    AL1(27),CL14'OBTAIN'
         DC    AL1(28),CL14'    '
         DC    AL1(29),CL14'SCRATCH'
         DC    AL1(30),CL14'RENAME'
         DC    AL1(31),CL14'FEOV'
         DC    AL1(32),CL14'ALLOC'
         DC    AL1(33),CL14'IOHALT'
         DC    AL1(34),CL14'MGCR/QEDIT'
         DC    AL1(35),CL14'WTO/WTOR'
         DC    AL1(36),CL14'WTL'
         DC    AL1(37),CL14'SEGLD/SEGWT'
         DC    AL1(38),CL14'    '
         DC    AL1(39),CL14'LABEL'
         DC    AL1(40),CL14'EXTRACT'
         DC    AL1(41),CL14'IDENTIFY'
         DC    AL1(42),CL14'ATTACH'
         DC    AL1(43),CL14'CIRB'
         DC    AL1(44),CL14'CHAP'
         DC    AL1(45),CL14'OVLYBRCH'
         DC    AL1(46),CL14'TTIMER'
         DC    AL1(47),CL14'STIMER'
         DC    AL1(48),CL14'DEQ'
         DC    AL1(49),CL14'    '
         DC    AL1(50),CL14'    '
         DC    AL1(51),CL14'SNAP/SDUMP'
         DC    AL1(52),CL14'RESTART'
         DC    AL1(53),CL14'RELEX'
         DC    AL1(54),CL14'DISABLE'
         DC    AL1(55),CL14'EOV'
         DC    AL1(56),CL14'ENQ/RESERVE'
         DC    AL1(57),CL14'FREEDBUF'
         DC    AL1(58),CL14'RELBUF/REQBUF'
         DC    AL1(59),CL14'OLTEP'
         DC    AL1(60),CL14'(E)STAE/STAI'
         DC    AL1(61),CL14'IKJEGS6A'
         DC    AL1(62),CL14'DETACH'
         DC    AL1(63),CL14'CHKPT'
         DC    AL1(64),CL14'RDJFCB'
         DC    AL1(65),CL14'    '
         DC    AL1(66),CL14'BTAMTEST'
         DC    AL1(67),CL14'    '
         DC    AL1(68),CL14'SYNAD...'
         DC    AL1(69),CL14'BSP'
         DC    AL1(70),CL14'GSERV'
         DC    AL1(71),CL14'ASGNBFR, ETC'
         DC    AL1(72),CL14'''NO MACRO'''
         DC    AL1(73),CL14'SPAR'
         DC    AL1(74),CL14'DAR'
         DC    AL1(75),CL14'DQUEUE'
         DC    AL1(76),CL14'''NO MACRO'''
         DC    AL1(77),CL14'    '
         DC    AL1(78),CL14'LSPACE'
         DC    AL1(79),CL14'STATUS'
         DC    AL1(80),CL14'    '
         DC    AL1(81),CL14'SETPRT'
         DC    AL1(82),CL14'    '
         DC    AL1(83),CL14'SMFWTM'
         DC    AL1(84),CL14'GRAPHICS'
         DC    AL1(85),CL14'DDRSWAP'
         DC    AL1(86),CL14'ATLAS'
         DC    AL1(87),CL14'DOM'
         DC    AL1(88),CL14'     '
         DC    AL1(89),CL14'     '
         DC    AL1(90),CL14'     '
         DC    AL1(91),CL14'VOLSTAT'
         DC    AL1(92),CL14'TCBEXCP'
         DC    AL1(93),CL14'TGET/TPUT'
         DC    AL1(94),CL14'STCC'
         DC    AL1(95),CL14'SYSEVENT'
         DC    AL1(96),CL14'STAX'
         DC    AL1(97),CL14'IKJEGS9G'
         DC    AL1(98),CL14'PROTECT'
         DC    AL1(99),CL14'DYNALLOC'
         DC    AL1(100),CL14'IKJEFFIB'
         DC    AL1(101),CL14'QTIP'
         DC    AL1(102),CL14'AQCTL (TCAM)'
         DC    AL1(103),CL14'XLATE'
         DC    AL1(104),CL14'TOPCTL (TCAM)'
         DC    AL1(105),CL14'IMGLIB'
         DC    AL1(107),CL14'MODESET'
         DC    AL1(109),CL14'ESR TYPE 4'
         DC    AL1(110),CL14'       '
         DC    AL1(111),CL14'''NO MACRO'''
         DC    AL1(112),CL14'PGRLSE'
         DC    AL1(113),CL14'PGFIX/PGFREE/..'
         DC    AL1(114),CL14'EXCPVR'
         DC    AL1(116),CL14'ESR(TYPE 1)'
         DC    AL1(117),CL14'DEBCHK'
         DC    AL1(119),CL14'TESTAUTH'
         DC    AL1(120),CL14'GETMAIN/FREEMAIN'
         DC    AL1(121),CL14'VSAM'
         DC    AL1(122),CL14'ESR(TYPE 2)'
         DC    AL1(123),CL14'PURGEDQ'
         DC    AL1(124),CL14'TPIO'
         DC    AL1(125),CL14'EVENTS'
         DC    AL1(126),CL14' '
         DC    AL1(127),CL14' '
         DC    AL1(128),CL14' '
         DC    AL1(129),CL14' '
         DC    AL1(130),CL14'RACHECK'
         DC    AL1(131),CL14'RACINIT'
         DC    AL1(132),CL14'RACLIST'
         DC    AL1(133),CL14'RACDEF'
         DC    AL1(134),CL14' '
         DC    AL1(135),CL14' '
         DC    AL1(136),CL14' '
         DC    AL1(137),CL14'ESR(TYPE 6)'
         DC    AL1(138),CL14'PGSER (XA)'
         DC    AL1(139),CL14'CVAF...'
         DC    AL1(143),CL14'CRYPTO SUPP'
         DC    AL1(144),CL14'OPENMVS PTRACE'
         DC    AL1(145),CL14'EQA00SVC'
         DC    AL1(146),CL14'BPESVC00'
*** LAST IBM USED NUMBER
         DC    AL1(157),CL14'CA UNIVERSE'
         DC    AL1(159),CL14'CAS9SVC'
         DC    AL1(173),CL14' '
         DC    AL1(198),CL14' '
         DC    AL1(199),CL14' '
***********************************************************************
* SVC NAME TABLE - USER SVCS (SVCS BELOW 200 ARE RSVD FOR IBM)        *
***********************************************************************
SVCUSR   DC    AL1(200),CL14'             '    FIRST USER SVC
         DC    AL1(214),CL14'             '
         DC    AL1(215),CL14'             '
         DC    AL1(216),CL14'             '
         DC    AL1(219),CL14'             '
         DC    AL1(220),CL14'             '
         DC    AL1(236),CL14'             '
         DC    AL1(238),CL14'             '
         DC    AL1(240),CL14'             '
         DC    AL1(241),CL14'             '
         DC    AL1(242),CL14'             '
         DC    AL1(243),CL14'             '
         DC    AL1(244),CL14'             '
         DC    AL1(245),CL14'             '
         DC    AL1(246),CL14'             '
         DC    AL1(247),CL14'             '
         DC    AL1(248),CL14'             '
         DC    AL1(249),CL14'             '
         DC    AL1(250),CL14'             '
         DC    AL1(251),CL14'             '
         DC    AL1(252),CL14'             '
         DC    AL1(253),CL14'             '
         DC    AL1(254),CL14'             '
         DC    AL1(255),CL14'             '
         DC    X'FF'                   END OF TABLE
./ ADD NAME=DSSLVL   0100-03311-03311-1200-00058-00058-00000-FILE066 00
          MACRO
          ADRMCLVL
.*  ***************************************************************
.*
.*     MACRO NAME = ADRMCLVL
.*
.*     DESCRIPTIVE NAME =  DFDSS RELEASE LEVEL MACRO
.*
.*  5665-327
.*  CONTAINS RESTRICTED MATERIALS OF IBM
.*  (C) COPYRIGHT IBM CORP. 1984, 1986
.*  LICENSED MATERIALS - PROPERTY OF IBM
.*  REFER TO COPYRIGHT INSTRUCTIONS
.*  FORM NUMBER G120-2083.
.*
.*     STATUS = RELEASE 2 VERSION 1
.*
.*     FUNCTION =
.*               LOADS THE DFDSS MODULE THAT CONTAINS THE VERSION,
.*        RELEASE AND MODIFICATION LEVEL NUMBERS.
.*
.*
.*     INVOCATION = ASSEMBLER
.*
.*     CHANGE ACTIVITY =
.*
.*   ***************************************************************
* THIS MACRO PASSES THE DFDSS VERSION, RELEASE AND MODIFICATION LEVEL
         LOAD EP=ADRRELVL,ERRET=ADR1&SYSNDX
         LR   1,0
         L    1,0(1)
         B    ADR2&SYSNDX
ADR1&SYSNDX LA 1,4(0,0)
         SLL  1,24(0)
         B    ADR3&SYSNDX
ADR2&SYSNDX DELETE EP=ADRRELVL
ADR3&SYSNDX DS  0H
         MEND
DSSLVL   MOWSTART
         ADRMCLVL                         GET DFDSS LEVEL
         ST    R1,DSSVMR                  SAVE RESULT
         TM    DSSVMR,X'04'               TEST FOR SUCCESSFUL GET
         BZ    OK                         DFDSS IS THERE
         MVC   MSG+10(11),=C'UNAVAILABLE'
         TPUT  MSG,L'MSG                  UNAVAILABLE MSG
         B     FIN                        RETURN
OK       EQU   *
         DELETE EP=ADRRELVL               CLEAN UP
         O     R1,=X'F0F0F0F0'            MAKE IT PRINTABLE
         STCM  R1,B'0111',DSSVMR          SAVE IT IN MESSAGE
         TPUT  MSG,LMSG                   TELL RELEASE ETC
FIN      EQU   *
         MOREND
MSG      DC    C'DF/DSS IS AVAILABLE, '
         DC    C'VER/REL/MOD = '
DSSVMR   DC    C'VRM'
LMSG     EQU   *-MSG
         END
./ ADD NAME=DXCFSTR  0199-96007-11283-1058-00198-00016-00198-TCACF0  00
         TITLE '*** DXCFSTR ***'
DXCFSTR  MOWSTART
DXCFSTR  AMODE 31
***********************************************************************
* GET INFO ON CF STRUCTURES.                                          *
* SEE ALSO THE IXLMG MACRO AND THE MAPPING MACRO IXLYAMDA.            *
* GOES IN SYS2.LINKLIB, AC(1)                                         *
* NEEDS ENTRY IN IKJTSO00 TO BE ABLE TO RUN FROM TSO.                 *
*                                                                     *
* SUMMING THE STRUCTURE SIZES IS NOT ACCURATE. IT IS THE SIZE REGARD- *
* LESS OF WHICH CF SO OVER ESTIMATES THE REQUIRED CF SIZE. NEED TO    *
* SUM BY WHICH CF THE STRUCTURE IS IN, THOUGH WITH DUPLXED STRUCTURES *
* THIS IS PRETTY CLOSE.                                               *
***********************************************************************
         MODESET MODE=SUP,KEY=ZERO        MAKE OURSELVES SPECIAL
         OPEN  (SYSPRINT,(OUTPUT))        OPEN OUTPUT FILE
GETSTOR  EQU   *
         L     R0,XCFDATAL                GET LENGTH
         GETMAIN R,LV=(0)                 GET SOME STORAGE
         ST    R1,XCFDATA                 SAVE ITS ADDRESS
         LR    R10,R1                     POINT TO RETURNED DATA
         IXCQUERY REQINFO=STR_ALLDATA,ANSAREA=(R10),ANSLEN=XCFDATAL
         B     *+4(R15)                   BRANCH DEPENDING ON RC
         B     QOK                        R15 = 0
         B     NOSTOR                     R15 = 4, NOT ENOUGH ROOM
         B     IXCERR                     R15 = 8
         B     IXCERR                     R15 = 12
IXCERR   EQU   *
         MVC   MESS(80),=CL80'XCF QUERY ERROR (SYSTEM NOT PART OF SYSPL*
               EX ?)'
         PUT   SYSPRINT,MESS
         B     FIN
NOSTOR   EQU   *                          FREE STORAGE, GO GET ENOUGH
         USING QUAHDR,R10
         L     R11,QUAHTLEN               GET REQUIRED LENGTH
         L     R0,XCFDATAL                LENGTH TO FREE
         L     R1,XCFDATA                 ADDRESS OF AREA TO FREE
         FREEMAIN R,A=(R1),LV=(R0)        FREE TOO SMALL AREA
         ST    R11,XCFDATAL               SAVE REQD LENGTH
         B     GETSTOR                    AND GO GET THAT MUCH
QOK      EQU   *
         USING IXLYAMDAREA,R9             LOOK FOR STRUCTURE TYPE
         LA    R9,CFDATA                  DATA AREA
         IXLMG DATAAREA=(R9),DATALEN=CFDATAL,                          *
               CFNAME=ALL_CFS,                                         *
               RETCODE=RET,RSNCODE=RSN
         LTR   R15,R15                    GOOD RETURN?
         L     R8,IXLYAMDAREA_CFENT@      -> CF ENTRY
         USING IXLYAMDCF,R8
         UNPK  MESS0+9(9),IXLYAMDCF_CFCCRELEASE(5)  CF LEVEL INFO
*        UNPK  MESS0+9(9),X'64'(5,R8)     GET CF LEVEL INFO
         NC    MESS0+9(9),=8X'0F'         MAKE IT BINARY
         TR    MESS0+9(9),=C'0123456789ABCDEF' CONVERT TO CHARACTER
         MVI   MESS0+17,C' '
         PUT   SYSPRINT,MESS0
         SR    R7,R7                      CLEAR FOR ALLOC SIZE ACCUM
         SR    R6,R6                      CLEAR FOR USED SIZE ACCUM
         PUT   SYSPRINT,MESS              PUT OUT HEADING LINE 1
         MVC   MESS(80),MESS1
         PUT   SYSPRINT,MESS              PUT OUT HEADING LINE 2
         L     R2,QUAH#REC                NUMBER OF RECORDS FOLLOWING
         LA    R10,QUAHLENG(,R10)         POINT TO FIRST DATA REC
         USING QUASTR,R10
STRLP    EQU   *
         MVC   MESS(16),QUASTRNAME        GET STRUCTURE NAME
         MVC   MESS+22(8),QUASTRPOLNAME   POLICY NAME
         USING IXLYAMDAREA,R9             LOOK FOR STRUCTURE TYPE
         LA    R9,CFDATA                  DATA AREA
         IXLMG DATAAREA=(R9),DATALEN=CFDATAL,                          *
               STRNAME=QUASTRNAME,                                     *
               RETCODE=RET,RSNCODE=RSN
         LTR   R15,R15                    GOOD RETURN?
         BNZ   GOTTYPE                    NO - SO SKIP THIS
         L     R8,IXLYAMDAREA_CFENT@      -> CF ENTRY
         USING IXLYAMDCF,R8
         L     R8,IXLYAMDCF_STR@          -> STRUCTURE ENTRY
         USING IXLYAMDSTRL,R8
         MVC   MESS+17(4),=C'LIST'        LIST TYPE?
         CLI   IXLYAMDSTRL_TTY,IXLYAMDA_LIST
         BE    GOTTYPE
         MVC   MESS+17(4),=C'LOCK'        LOCK TYPE?
         CLI   IXLYAMDSTRL_TTY,IXLYAMDA_LOCK
         BE    GOTTYPE
         MVC   MESS+17(4),=C'CACH'        CACHE TYPE?
         CLI   IXLYAMDSTRL_TTY,IXLYAMDA_CACHE
*
GOTTYPE  EQU   *
         SR    R4,R4                      CLEAR FOR MULTIPLY
         L     R5,=F'4'                   CONVERT TO K
         M     R4,QUASTRSIZE              GET STRUCTURESIZE
         CVD   R5,DOUBLE                  MAKE IT DECIMAL
         MVC   MESS+49(12),=X'402020206B2020206B202120'
         ED    MESS+49(12),DOUBLE+3       EDIT NUMBER INTO IT
         AR    R7,R5                      AND ACCUMULATE TOTAL SIZE
         CLI   MESS+17,C' '               KNOWN STRUCTURE TYPE?
         BNE   *+6                        NO, SO NOT ALLOCATED
         AR    R6,R5                      ACCUMULATE ALLOCATED SIZE
*
         LR    R9,R10                     COPY ADDRESS
         A     R9,QUASTRPLO
         CR    R9,R10                     SAME ADDR, SO NO PREF CF
         BE    STRLP02
         USING QUASTRPL,R9
         MVC   MESS+41(8),QUASTRPLNAME    DESIRED CF
*
STRLP02  EQU   *
         LR    R9,R10                     COPY ADDRESS
         A     R9,QUASTRCFO
         CR    R9,R10                     SAME ADDR, SO NO ACTUAL CF
         BE    STRLP03A
         USING QUASTRCF,R9
         MVC   MESS+32(8),QUASTRCFNAME    ACTUAL CF
         CLC   MESS+32(8),MESS+41         COMPARE NAMES
         BE    STRLP03A                   SAME, SO NO PROBLEM HERE
         MVI   MESS+40,C'*'               INDICATE THEY'RE DIFFERENT
*
STRLP03A EQU   *
         TM    QUASTRSTATE1,QUASTRSTDPEND  CHANGE PENDING?
         BZ    STRLP03B                    NO
         MVC   MESS+70(07),=C'CHG_PND'
*
STRLP03B EQU   *
         MVC   MESS+62(07),=CL7'ALLOWED'   START WITH DUPLEXING ALLOWED
         TM    QUASTRFLG,QUASTRDUPLEXALLOWED     IS IT ALLOWED?
         BO    STRLP04                           YES.
         MVC   MESS+62(07),=CL7'ENA'
         TM    QUASTRFLG,QUASTRDUPLEXENABLED  IS IT ALREADY ENABLED?
         BO    STRLP04                           YES.
         MVC   MESS+62(07),=CL7' '         NEITHER ALLOWED OR ENABLED
*
STRLP04  EQU   *
         TM    QUASTRREBLDPHASE1,QUASTRREBLDDUPLEXESTABLISHED
         BZ    STRLP05                    DUPLEXING NOT ESTABLISHED
         MVC   MESS+66(03),=C'EST'        SAY IT IS, AND
         MVI   MESS+40,C' '               DOESN'T MATTER WHEN DUPLEXED
*
STRLP05  EQU   *
         TM    QUASTRFLG,QUASTRALLOWAUTOALT      AUTOALTER ALLOWED?
         BZ    STRLP99                           NO.
         MVC   MESS+70(08),=C'AUTOALT'    SAY IT IS
*
STRLP99  EQU   *
         PUT   SYSPRINT,MESS
         MVI   MESS,X'40'                 GET A BLANK
         MVC   MESS+1(79),MESS            AND CLEAR MESSAGE
         AH    R10,QUASTRLEN              POINT TO NEXT ENTRY
         BCT   R2,STRLP                   LOOP TILL NO MORE STRUCTURES
*
         MVC   MESS+49(12),=C'------------'
         PUT   SYSPRINT,MESS
*                             123456789 123456789 123456789 123456789
         MVC   MESS(44),=CL44'MAXIMUM SPACE THAT STRUCTURES COULD OCCUP*
               Y:'
         CVD   R7,DOUBLE                  MAKE TOTAL SPACE DECIMAL
         MVC   MESS+49(12),=X'402020206B2020206B202120'
         ED    MESS+49(12),DOUBLE+3       EDIT NUMBER INTO IT
         PUT   SYSPRINT,MESS              TELL US HOW MUCH USED
*                             123456789 123456789 123456789 123456789
         MVC   MESS(80),=CL80'(COMPARE THIS VALUE WITH THE SIZE OF THE *
               CF)'
         PUT   SYSPRINT,MESS              QUALIFYING COMMENT
*                             123456789 123456789 123456789 123456789
         MVC   MESS(44),=CL44'ALLOCATED SPACE:'
         SR    R7,R6                      CALCULATE USED SPACE
         CVD   R7,DOUBLE                  MAKE USED SPACE DECIMAL
         MVC   MESS+49(12),=X'402020206B2020206B202120'
         ED    MESS+49(12),DOUBLE+3       EDIT NUMBER INTO IT
         PUT   SYSPRINT,MESS              TELL US HOW MUCH USED
*                             123456789 123456789 123456789 123456789
         MVC   MESS(44),=CL44'UNALLOCATED SPACE:'
         CVD   R6,DOUBLE                  MAKE FREE SPACE DECIMAL
         MVC   MESS+49(12),=X'402020206B2020206B202120'
         ED    MESS+49(12),DOUBLE+3       EDIT NUMBER INTO IT
         PUT   SYSPRINT,MESS              TELL US HOW MUCH USED
FIN      EQU   *
         L     R0,XCFDATAL                LENGTH TO FREE
         L     R1,XCFDATA                 ADDRESS OF AREA TO FREE
         FREEMAIN R,A=(R1),LV=(R0)        FREE AREA
         CLOSE SYSPRINT                   CLOSE FILE
         MODESET MODE=PROB,KEY=NZERO      MAKE US UN-SPECIAL
         MOREND
DOUBLE   DC    D'0'
MESS0    DC    CL80'CF LEVEL:                                          *
                  MAX'
MESS     DC    CL80'STRUCTURE_NAME   TYPE POL_NAME  ALLOC    DESIRED   *
                 SIZE (K) DUPLEX'
MESS1    DC    CL80'---------------- ---- --------  -------  -------   *
                 -------- ------'
SYSPRINT DCB   DDNAME=SYSPRINT,RECFM=FB,MACRF=PM,DSORG=PS,LRECL=80
XCFDATAL DC    F'8192'               INITIAL LENGTH FOR GETMAIN
XCFDATA  DC    F'0'                  A(RETURNED DATA AREA)
RET      DC    F'0'                  RETURN CODE
RSN      DC    F'0'                  REASON CODE
CFDATAL  DC    AL4(8192*4)           CFDATA AREA LENGTH
CFDATA   DC    8192F'0'
         IXCYQUAA
         IXLYAMDA
         END
./ ADD NAME=IEECMDPF 0108-95181-10095-1601-00064-00061-00064-TCACF0  00
         TITLE '*** IEECMDPF ***'
IEECMDPF MOWSTART
IEECMDPF AMODE  31
IEECMDPF RMODE  ANY
**********************************************************************
* ESTABLISH COMMAND PREFIX EQUAL TO SYSTEM NAME.                     *
* DOC IS MVS/ESA SYSPLEX MIGRATION GUIDE GG24-4368-00.               *
* USE D OPDATA OPERATOR COMMAND TO SEE WHAT PREFIXES ARE DEFINED.    *
* GOES IN SYS2.LINKLIB, AC(1)                                        *
**********************************************************************
         USING CVT,R2
         L     R2,16                  A(CVT)
         NI    FLAGS,X'FF'-SWITCH     CLEAR SWITCH
         MVC   SYSNAME(8),CVTSNAME    GET SYSNAME FROM CVT
*        MODESET MODE=SUP,KEY=ZERO    GO SUPERVISOR STATE/KEY ZERO
RETRY    EQU   *
         CPF   REQUEST=DEFINE,        DEFINE PREFIX EQUAL TO SYSNAME   *
               PREFIX=SYSNAME,                                         *
               OWNER==C'IEECMDPF',                                     *
               FAILDISP=SYSPURGE,                                      *
               REMOVE=YES,                                             *
               MF=(E,CPFLST)
         LTR   R15,R15                SEE IF PREFIX WAS SET OK
         BZ    SUCCESS                YES IT WAS
         TM    FLAGS,SWITCH           SEE IF ALREADY TRIED
         BO    ERROR                  WE HAVE SO DON'T TRY AGAIN
         C     R15,=F'8'              ALREADY DEFINED?
         BNE   ERROR                  NO
         C     R0,=F'8'               SEE IF PREFIX ALREADY DEFINED
         BNE   ERROR                  SOME OTHER ERROR
         CPF   REQUEST=DELETE,        DELETE EXISTING DEFINITION       *
               PREFIX=SYSNAME,                                         *
               MF=(E,CPFLST)
         OI    FLAGS,SWITCH           SET FLAG TO SAY WE'RE RETRYING
         B     RETRY                  TRY AGAIN
ERROR    EQU   *
         MVC   ERRSYS,SYSNAME         MOVE SYSNAME INTO MSG
         LA    R2,ERRMSG              POINT TO MSG
         WTO   TEXT=(R2),DESC=4
         B     FIN
SUCCESS  EQU   *
         MVC   OKSYS,SYSNAME          MOVE SYSNAME INTO MSG
         LA    R2,OKMSG               POINT TO MSG
         WTO   TEXT=(R2),DESC=4
FIN      EQU    *
*        MODESET MODE=PROB,KEY=NZERO   RETURN TO PROBLEM STATE/NON-ZERO
         MOREND
OKMSG    DS    0H
         DC    Y(OKEND-OKSTART)
OKSTART  DC    CL42'SVS102I COMMAND PREFIX DEFINED FOR SYSTEM '
OKSYS    DC    CL8' '
OKEND    EQU   *
ERRMSG   DS    0H
         DC    Y(ERREND-ERRSTART)
ERRSTART DC    CL49'SVS103W ERROR DEFINING COMMAND PREFIX FOR SYSTEM '
ERRSYS   DC    CL8' '
ERREND   EQU   *
SYSNAME  DC    CL8' '
FLAGS    DC    X'00'
SWITCH   EQU   X'80'                  ALREADY RETRIED
         CPF   MF=(L,CPFLST)
         PRINT NOGEN
         CVT   DSECT=YES
         END
./ ADD NAME=INFO     0100-03311-03311-1200-00333-00333-00000-FILE066 00
         TITLE '*** INFO ***'
INFO     MOWSTART
INFO     AMODE  24
INFO     RMODE  24
***********************************************************************
* PROGRAM HAS TWO OPTIONS, 1 - TO SET UP A MEMBER OF THE PDS (WHICH   *
* IS IN INFO INPUT FORMAT) WITH A KEYWORD TABLE. PARM=KWD             *
*                          2 - TO DO A KEYWORD SEARCH OF THE PDS AND  *
* DISPLAY TITLE LINES MUCH LIKE INFO DOES. PARM=KEYWORD TO LOOK FOR,  *
* OR BLANK FOR ALL TITLES.                                            *
***********************************************************************
MOWWORK  DSECT
CARD     DC    CL80' '
KEYWORD  DC    CL16' '
KWDTAB   DC    CL24' '                  16 - KEYWORD, 8 - MEMBERNAME
MEMLST   DC    750CL8' '                LIST OF MEMBER NAMES
INFO     CSECT
         LR    R11,RB                   COPY BASE REGISTER
         LA    R11,4095(R11)            ADJUST IT
         LA    R11,1(R11)               ALL THE WAY
         USING INFO+4096,R11            TELL ASSEMBLER
         SPACE
         L     R1,0(R1)                 MAYBE WE HAVE A PARM
         LH    R2,0(R1)                 IF SO IT WILL HAVE LENGTH
         LR    R9,R2                    COPY IT FOR USE AT SEARCH
         LR    R10,R1                   COPY IT FOR USE AT SEARCH
         LTR   R2,R2                    SO TEST IT
         BZ    NOPARM                   AND SKIP IF THERE WASN'T
         CLC   2(3,R1),=C'KWD'          WAS KWD SPECIFIED?
         BNE   SEARCH                   NO, SEARCH FOR KEYWORD
         OI    FLAG,FLAGKWD             SET BIT FOR BUILDING KEYWORDS
NOPARM   EQU   *
         OPEN  (SYSPRINT,(OUTPUT))      OPEN SYSPRINT
* READ DIRECTORY GETTING LIST OF ALL MEMBER NAMES
         USING DIRBLK,R2
         USING PDS2,R3
         OPEN  (PDSDIR)                 OPEN PDS DIRECTORY
         LA    R7,MEMLST
NEXTENT  EQU   *
         GET   PDSDIR                   GET A DIRECTORY RECORD
         LR    R2,R1                    COPY REG
         LH    R10,COUNT                COUNT OF BYTES IN THIS BLOCK
         AR    R10,R2                   POINT TO END OF BLOCK
         LA    R3,2(R2)                 POINT TO FIRST DATA PIECE
NEXTNAME EQU   *
         CLI   PDS2NAME,C'$'            MEMBER NAME BEGINS WITH A $?
         BE    NEXT001                  SKIP THIS ONE
         MVC   0(8,R7),PDS2NAME         MOVE NAME TO BLDL LIST NAME
         LA    R7,8(R7)                 NEXT SLOT
         CLC   PDS2NAME,=8X'FF'         LAST NAME IN DIRECTORY?
         BE    GOTMEMS                  NO, NOT YET
NEXT001  EQU   *
         SR    R5,R5                    ZERO REGISTER
         IC    R5,PDS2INDC              GET BYTE WITH USERCT
         N     R5,=X'0000001F'          TURN OFF OTHER BITS
         SLL   R5,1                     CONVERT HALFWORDS INTO BYTES
         LA    R3,12(R5,R3)             BUMP POINTER TO NEXT NAME
         CR    R3,R10                   MORE ENTRIES IN BLOCK
         BL    NEXTNAME                 GO GET THEM
         B     NEXTENT                  NEED ANOTHER BLOCK
         EJECT
GOTMEMS  EQU   *
         TM    FLAG,FLAGKWD             TEST BIT FOR BUILDING KEYWORDS
         BZ    CLOSEDIR                 SKIP IF NOT DOING KEYWORDS
         LA    R8,MEMLST                GET ADDRES OF MEMBER LIST
         SR    R7,R8                    GET LENGTH OF LIST IN BYTES
         SRL   R7,3                     DIVIDE BY 8, NOW # MEMBERS
         MVC   CARD(80),=CL80'PDS CONTAINSXXXX MEMBERS (MAX=750)'
         CVD   R7,DOUBLE                MAKE IT DECIMAL
         MVC   CARD+12(4),=X'40202120'
         ED    CARD+12(4),DOUBLE+6      EDIT NUMBER INTO IT
         PUT   SYSPRINT,CARD
CLOSEDIR EQU   *
         CLOSE PDSDIR                   CLOSE PDS DIRECTORY
         TM    FLAG,FLAGKWD             ARE WE BUILDING KEYWORDS
         BZ    SEARCH                   NO, WE'RE LOOKING FOR THEM
         OPEN  (SORTIN,(OUTPUT))
         OPEN  (PDS,(INPUT))            OPEN PDS
         LA    R10,MEMLST               POINT TO MEMBER LIST
         LH    R2,PDS+62                GET BLKSIZE
         GETMAIN R,LV=(R2)              GET AREA
         ST    R1,DATA                  SAVE ITS ADDRESS
         LA    R8,KWDTAB                POINT TO KEYWORD AREA
GOT001   EQU   *
         FIND  PDS,(R10),D              DO FIND FOR MEMBER
         LTR   R15,R15                  GOOD FIND?
         L     R9,DATA                  POINT TO DATA AREA AGAIN
         READ  DECB,SF,,(9),MF=E        GET RECORD FROM MEMBER
         CHECK DECB
         BAL   R14,GETKWDS              GO TO BUILD KEYWORD TABLE
         LA    R10,8(R10)               POINT TO NEXT MEMBER SLOT
         CLC   0(8,R10),=8X'FF'         CHECK MEMBER NAME
         BNE   GOT001                   GO DO NEXT MEMBER
         CLOSE SORTIN                   FINISHED GETTING KEY WORDS
         LA    R1,SORTPARM              POINT TO SORT PARMS
         LINK  EP=SORT                  GO SORT KEYWORD LIST
         SPACE 5
         BAL   R14,BLDGLOSS             MAKE LIST OF KWD REFS
         B     FIN
         EJECT
SEARCH   EQU   *
         LA    R7,SAVE15                POINT TO WORK AREA
         EXTRACT (7),FIELDS=TSO         GET INFO
         L     R7,SAVE15                ADDRESS
         TM    0(R7),X'80'              IS THIS TSO?
         BO    SEARCH00                 YES
         OI    FLAG,FLAGBAT             SET BATCH FLAG
         OPEN  (SYSPRINT,(OUTPUT))      OPEN SYSPRINT
SEARCH00 EQU   *
         LTR   R9,R9                    LETS TAKE A LOOK
         BP    SEARCH01                 SPECIFIC KEYWORD
         OI    FLAG,FLAGALLT            SET FLAG TO LIST ALL TITLES
         B     SEARCH02
SEARCH01 EQU   *
         BCTR  R9,0                     REDUCE LENGTH BY 1
         MVI   KEYWORD,C' '             BLANK OUT KEYWORD
         MVC   KEYWORD+1(15),KEYWORD
         EX    R9,MVCSKWD               MOVE IN KEYWORD
         OC    KEYWORD(16),=CL16' '     MAKE SURE ITS UPPERCASE
SEARCH02 EQU   *
         OPEN  (KWDS,(INPUT))           OPEN KEYWORD MEMBER
         LA    R9,MEMLST                POINT TO MEMBER LIST
KWD000   EQU   *
         GET   KWDS                     GET A RECORD
         TM    FLAG,FLAGALLT            ALL TITLES REQUIRED?
         BO    KWD005                   YES
         CLC   0(16,R1),KEYWORD         A MATCH?
         BL    KWD000                   NOT YET
         BH    KWD020                   PASSED IT
         LA    R5,7                     MAX MEMBER NAMES ON CARD
         LA    R1,17(R1)                1ST MEMBER NAME
KWD010   EQU   *
         CLC   0(8,R1),=CL8' '          BLANK NAME?
         BE    KWD020                   NO MORE NAMES
         MVC   0(8,R9),0(R1)
         LA    R9,8(R9)                 NEXT OUTPUT SLOT
         LA    R1,9(R1)                 NEXT INPUT SLOT
         BCT   R5,KWD010                NEXT NAME
         B     KWD000                   GET NEXT CARD
KWD020   EQU   *
         MVC   0(8,R9),=8X'FF'          END OF LIST MARKER
         CLOSE KWDS                     GOT THE NAMES NOW
         SPACE 5
KWD005   EQU   *
         SR    R3,R3                    CLEAR FOR COUNTER
         OPEN  (PDS,(INPUT))            OPEN PDS
         LA    R10,MEMLST               POINT TO MEMBER LIST
         LH    R2,PDS+62                GET BLKSIZE
         GETMAIN R,LV=(R2)              GET AREA
         ST    R1,DATA                  SAVE ITS ADDRESS
GOT005   EQU   *
         CLC   0(8,R10),=8X'FF'         CHECK MEMBER NAME
         BE    GOT020                   GO DO NEXT MEMBER
         FIND  PDS,(R10),D              DO FIND FOR MEMBER
         LTR   R15,R15                  GOOD FIND?
         L     R9,DATA                  POINT TO DATA AREA AGAIN
         READ  DECB,SF,,(9),MF=E        GET RECORD FROM MEMBER
         CHECK DECB
         LA    R3,1(R3)                 INCREMENT COUNTER
         BAL   R14,GETTITLE             GO GET TITLE LINES
         LA    R10,8(R10)               POINT TO NEXT MEMBER SLOT
         B     GOT005                   GO DO NEXT MEMBER
GOT020   EQU   *
         B     FIN
         EJECT
FIN      EQU   *
         CLOSE SYSPRINT
         LH    R0,PDS+62                LENGTH OF AREA
         L     R1,DATA                  ADDRESS OF DATA
         FREEMAIN R,A=(1),LV=(0)        FREE DATA AREA
         CLOSE (PDS)                    DONE NOW
         MOREND
         EJECT
GETKWDS  EQU   *
* PROCESS DATA AND EXTRACT KEYWORDS FROM RECORDS
         ST    R14,SAVE14               SAVE RETURN REG
GETK000  EQU   *
         CLC   0(2,R9),=C'K '           KEYWORD LINE?
         BE    GETK001                  YES
         L     R14,SAVE14               RESTORE REG 14
         CLI   0(R9),C' '               END OF ALL HEADING JUNK
         BER   R14                      YES, RETURN TO CALLER
         LA    R9,80(R9)                NEXT DATA RECORD
         B     GETK000                  TRY AGAIN
GETK001  EQU   *
         LA    R15,2(R9)           POINT TO STRING TO SEARCH
         LA    R3,78               LENGTH OF STRING TO SEARCH
GETK002  EQU   *
         EX    R3,TRTNONBL         FIND A NONBLANK
         BZ    DONE                BRANCH IF ALL BLANKS
         LR    R14,R1              GET ADDRESS OF STRING
         SR    R14,R15             GET LENGTH OF PRECEDING BLANKS
         SR    R3,R14              GET LENGTH OF REMAINING TEXT
         LR    R15,R1              GET ADDRESS OF NONBLANK
         EX    R3,TRTBLANK         FIND A BLANK
         BZ    LAST                BRANCH IF NOT FOUND
         LR    R14,R1              GET ADDRESS OF BLANK
         SR    R14,R15             GET LENGTH OF FIELD
LAST     EQU   *
         SR    R3,R14              REDUCE LENGTH TO SEARCH
         LTR   R3,R3
         BNP   DONE
         BCTR  R14,0               LESS 1 FOR MOVE
         MVI   0(R8),C' '          A BLANK
         MVC   1(23,R8),0(R8)      AND 24 MORE
         EX    R14,MVCKWD          MOVE KEYWORD TO TABLE
         MVC   16(8,R8),0(R10)     PUT MEMBER NAME IN TABLE
         LA    R15,1(R14,R15)      POINT TO NEXT STARTING SLOT
         ST    R15,SAVE15
         PUT   SORTIN,(R8)         NEXT OUTPUT SLOT
         L     R15,SAVE15
         B     GETK002
DONE     EQU   *
         LA    R9,80(R9)                NEXT DATA RECORD
         B     GETK000                  TRY AGAIN
         EJECT
BLDGLOSS EQU   *
* BUILD THE PSEUDO GLOSSARY
         ST    R14,SAVE14               SAVE IT
         OPEN  (SORTOUT,(INPUT))        READ IN SORTED DATA
         OPEN  (KWDDATA,(OUTPUT))       OPEN GLOSSARY FILE
         MVI   CARD,C' '                BLANK OUTPUT CARD
         MVC   CARD+1(79),CARD           AREA
         LA    R10,CARD+17              MEMBER NAME SLOT
         LA    R9,7                     LOOP LIMITER
         GET   SORTOUT                  GET A RECORD
         MVC   CARD(16),0(R1)           COPY STARTUP DATA
GLO000   EQU   *
         CLC   CARD(16),0(R1)           SAME KWD AS PREVIOUSLY FOUND?
         BNE   GLO100                   NO, NEW RECORD
         MVC   0(8,R10),16(R1)          MOVE MEMBER NAME INTO CARD
         LA    R10,9(R10)               NEXT SLOT
         GET   SORTOUT                  GET A RECORD
         BCT   R9,GLO000                GO GET NEW INPUT
GLO100   EQU   *
         LR    R9,R1                    SAVE IT
         PUT   KWDDATA,CARD             PUT IT OUT
         MVI   CARD,C' '                BLANK OUTPUT CARD
         MVC   CARD+1(79),CARD           AREA
         LR    R1,R9                    RELOAD POINTER
         MVC   CARD(16),0(R1)           COPY STARTUP DATA
         LA    R10,CARD+17
         LA    R9,7
         B     GLO000                   GO GET NEW CARD
SORTEND  EQU   *
         CLOSE KWDDATA
         L     R14,SAVE14               RELOAD RETURN REG
         BR    R14                      RETURN TO CALLER
         EJECT
GETTITLE EQU   *
* GET TITLE LINES NOW
         ST    R14,SAVE14               SAVE RETURN REG
GETT000  EQU   *
         CLC   0(2,R9),=C'T '           TITLE LINE?
         BE    GETT001                  YES
         L     R14,SAVE14               RESTORE REG 14
         CLI   0(R9),C' '               END OF ALL HEADING JUNK
         BER   R14                      YES, RETURN TO CALLER
         LA    R9,80(R9)                NEXT DATA RECORD
         B     GETT000                  TRY AGAIN
GETT001  EQU   *
         MVI   CARD,C' '                BLANK CARD
         MVC   CARD+1(79),CARD
         CVD   R3,DOUBLE                MAKE IT DECIMAL
         MVC   CARD(04),=X'40202120'
         ED    CARD(04),DOUBLE+6        EDIT NUMBER INTO IT
         MVI   CARD+4,C'.'
         MVC   CARD+6(8),0(R10)         MOVE MEMBER NAME INTO CARD
         MVC   CARD+16(65),2(R9)        MOVE IN TITLE
         TPUT  CARD+1,79                DISPLAY TITLE
         L     R14,SAVE14
         TM    FLAG,FLAGBAT             BATCH?
         BZR   R14                      NO, SO RETURN
         PUT   SYSPRINT,CARD+1
         L     R14,SAVE14
         BR    R14
         EJECT
DOUBLE   DC    D'0'
DATA     DC    F'0'
SAVE14   DC    F'0'
SAVE15   DC    F'0'
MVCSKWD  MVC   KEYWORD(*-*),2(R10)      EXECUTED MOVE
MVCKWD   MVC   0(*-*,R8),0(R15)         EXECUTED MOVE
READLST  READ  DECB,SF,PDS,,'S',MF=L
SORTPARM DC    X'80',AL3(SORTLST)
         CNOP  2,4
SORTLST  DC    AL2(LISTEND-LISTBEG)
LISTBEG  DC    A(SORTA)
         DC    A(SORTZ)
         DC    A(RECA)
         DC    A(RECZ)
         DC    A(0)           A(E15)
         DC    A(0)           A(E35)
         DC    C'SORT'        DDNAME CHARS
         DC    F'256000'      MAIN STOR VALUE
         DC    X'FF'          MSG OPTION FLAG
         DC    C'(I)'         MSG OPTION
LISTEND  EQU   *
SORTA    DC    C' SORT FIELDS=(1,16,CH,A,16,8,CH,A)'
SORTZ    DC    C' '
RECA     DC    C' RECORD LENGTH=24,TYPE=F'
RECZ     DC    C' '
KWDS     DCB   DDNAME=KWDS,RECFM=FB,LRECL=80,DSORG=PS,MACRF=GL,        *
               EODAD=GOT020
KWDDATA  DCB   DDNAME=KWDDATA,RECFM=FB,LRECL=80,DSORG=PS,MACRF=PM
SYSPRINT DCB   DDNAME=SYSPRINT,RECFM=FB,LRECL=80,DSORG=PS,MACRF=PM
SORTIN   DCB   DDNAME=SORTIN,RECFM=FB,LRECL=24,DSORG=PS,MACRF=PM
SORTOUT  DCB   DDNAME=SORTOUT,RECFM=FB,LRECL=24,DSORG=PS,MACRF=GL,     *
               EODAD=SORTEND
PDSDIR   DCB   DDNAME=PDS,RECFM=U,BLKSIZE=256,DSORG=PS,MACRF=GL,       *
               EODAD=GOTMEMS
PDS      DCB   DDNAME=PDS,RECFM=FB,LRECL=80,DSORG=PO,MACRF=(R,W)
TRTNONBL TRT   0(0,R15),TABNONBL   (EXECUTED)
TRTBLANK TRT   0(0,R15),TABBLANK   (EXECUTED)
TABNONBL DC    64X'FF'
         DC    X'00'               BLANK
         DC    42X'FF'
         DC    X'00'               COMMA
         DC    148X'FF'
TABBLANK DC    64X'00'
         DC    X'40'               BLANK
         DC    42X'00'
         DC    X'6B'               COMMA
         DC    148X'00'
FLAG     DC    X'00'
FLAGKWD  EQU   X'80'
FLAGALLT EQU   X'40'
FLAGBAT  EQU   X'20'
DIRBLK   DSECT
COUNT    DC    H'0'
ENTRIES  DC    254C' '
         IHAPDS PDSBLDL=NO
         END
./ ADD NAME=IOCDSLST 0126-00169-11027-1018-00280-00247-00280-TCACF0  00
         TITLE 'IOCDS Utility'
****Start of Specifications********************************************
*
* MODULE NAME: IOCDSLST
*
* FUNCTION:    Display Processor IOCDS details.
*
* STATUS:      MVS/ESA 4.3.0
*
* ATTRIBUTES:  Disk resident.
*
* AUTHOR:      Ashley Street a.street@btinternet.com
*
* ENTRY CONDITIONS:
*
*        IOCDLIST :-
*        Gpr14 = Return address
*        Gpr15 = A(Called routine)
*
*
* EXTERNAL REFERENCES:
*
*
* MACROS :
*        MODESET
*        STORAGE
*        OPEN
*        PUT
*        CLOSE
*
* NOTES:
*        None.
*
* CHANGE ACTIVITY:
*
*        Ver 1 Rel 1 Fix 00  - New module devlopment (Base code).
*
* ACF NOTES:
*
*   To figure out the parameter list zap ICPIOCP.ICPPMVS
*   at the 0A7A (SVC 122) instruction to 0000.
*
*   Run the following job:
*
*   //IOCDSREP EXEC PGM=ICPIOCP,REGION=64M,
*   // PARM='REPORT=A,LINECOUNT=60'
*   //STEPLIB  DD DISP=SHR,DSN=SYS1.LINKLIB
*   //SYSPRINT DD SYSOUT=*,DCB=RECFM=FA
*   //SYSUDUMP DD SYSOUT=*
*
*   and examine where R1?? points to see the parameter list.
*   It should look similar to
*       1D700000 10000100 00000000 00000000 810F0000    00010000
*
****End of Specifications**********************************************
IOCDSLST CSECT
IOCDSLST AMODE 24
IOCDSLST RMODE 24
         BAKR  R14,0                    Save status etc on Stack
         LR    R12,R15                  Setup my base
         USING IOCDSLST,R12             Base reg assignment
         LA    R13,SAVE                 Set up R13 for other linkage
*
         MODESET MF=(E,SUPRMOD)         Get in 'Supervisor' state
         STORAGE OBTAIN,                                               X
               LENGTH=STORLEN,                                         X
               ADDR=(2),                                               X
               LOC=BELOW,                                              X
               COND=NO
         ST    R2,SVC122PL              save it for later
*
         LA    R4,MESSBUFF              address of message buffer
         L     R5,=A(80*IOCDTABE)       length of buffer
         XR    R7,R7                    length of zero
         ICM   R7,B'1000',=C' '         pad byte of blank
         MVCL  R4,R6                    clear the message buffer
*
         LA    R9,IOCDTABA              IOCDS table
         LA    R10,IOCDTABE             Maximum entries to check
         LA    R11,MESSBUFF             Point to message buffer
         XR    R3,R3                    count of entries read
LOOP1    EQU   *
         LR    R4,R2                    storage area
         LA    R5,2048
         LA    R5,2048(R5)              length of area
         XR    R7,R7                    clear for move long
         MVCL  R4,R6                    and clear buffer
         MVC   0(4,R2),=X'10000100'     set up parameter list
         MVC   4(4,R2),=X'00000000'
         MVC   8(3,R2),=X'000000'
         MVC   11(1,R2),0(R9)           iocds number: 00, 01, 02, 03
*        MVC   12(4,R2),=X'800F0001'    this was for 2064 processor
         MVC   12(4,R2),=X'810F0000'    2084s and up
         MVC   16(4,R2),=X'00010000'
         BAL   R14,ISSUESV              and issue Service Call
*
         CLI   9(R2),DSNOTIN            Not installed ?
         BE    SETBSIDE                 if so, try the other side
         CLI   9(R2),DSNOSIDE           Non existent side ?
         BE    SCRIO                    if so, finish off
*
         LR    R8,R2                    data block retrieved
*        AH    R8,=H'512'               offset
         AH    R8,=H'768'               offset
         MVC   1(2,R11),1(R9)           IOCDS number
         CLI   9(R2),DSEMPTY            IOCDS not created ?
         BE    CLOSEDS                  if so, close it again
         MVC   9(8,R11),0(R8)           IOCDS title
         UNPK  WORK1,8(4,R8)            sort out the date
         MVC   46(5,R11),WORK1+2        and place in message
         UNPK  WORK1,12(4,R8)           sort out the time
         MVC   54(2,R11),WORK1          in goes hours
         MVI   56(R11),C':'
         MVC   57(2,R11),WORK1+2        minutes and ....
         MVI   59(R11),C':'
         MVC   60(2,R11),WORK1+4        seconds
*
*        MVC   64(32,R11),192(R8)       Get IODF data
         MVC   64(12,R11),192(R8)       Get IODF data
*
         MVC   24(5,R11),=C'LPAR '      default to 'LPAR' mode
         CLC   270(2,R8),=X'2084'       2084 and up can only be LPAR
         BNL   CHKSTAT
         TM    23(R8),X'02'             LPAR mode ?
         BO    CHKSTAT                  if not, check IOCDS status
         TM    23(R8),X'04'             LPAR mode ?
         BO    CHKSTAT                  if not, check IOCDS status
         TM    23(R8),X'08'             LPAR mode ?
         BO    CHKSTAT                  if not, check IOCDS status
         MVC   24(5,R11),=C'Basic'      indicate LPAR mode
CHKSTAT  EQU   *
         CLI   31(R8),DSACTIVE          Active IOCDS ?
         BE    SETACT1                  if so, indicate that
         CLI   31(R8),DSUPDATE          Active + Updated IOCDS ?
         BNE   CLOSEDS                  if not, nothing to add
         MVC   34(7,R11),=C'Act/Upd'    indicate active/updated one
         B     CLOSEDS                  and close IOCDS
SETACT1  EQU   *
         MVC   34(6,R11),=C'Active'     indicate active IOCDS
CLOSEDS  EQU   *
         MVC   0(4,R2),=X'10000100'     Set up parms
         MVC   4(4,R2),=X'00000000'
         MVC   8(3,R2),=X'000000'
         MVC   11(1,R2),0(R9)
         MVC   12(4,R2),=X'40000295'    close the dataset
         BAL   R14,ISSUESV              issue Service Call
         LA    R9,ENTLEN(R9)            bump through table
         LA    R11,MESSLEN(,R11)        bump on through message buffer
         LA    R3,1(,R3)                increment read count
         BCT   R10,LOOP1                and loop
         B     SCRIO                    And display all the info.
*
ISSUESV  EQU   *
         LA    R1,SVC122PL              address of parameter list
         LA    R15,6                    routing code for Service Call
         SVC   122                      issue service call
         BR    R14                      and return to caller
*
SETBSIDE EQU   *
         TM    PROCFLAG,SIDEB           already on the 'B' side ?
         BO    SCRIO                    if so, display the details
         OI    PROCFLAG,SIDEB           set the 'B' side flag on
         LA    R9,IOCDTABB              IOCDS 'B' side entries
         LA    R10,IOCDSCNT             Maximum entries to check
         B     LOOP1                    and back to the loop
SCRIO    EQU   *
         LA    R5,TITLE1                Start at title line
         LA    R6,MESSLEN               length of message
         LA    R3,2(,R3)                entries to display
         OPEN  (PRINTER,OUTPUT)         Open Printer DCB
SCRIO1   EQU   *
         PUT   PRINTER,(R5)             and display message
         LA    R5,MESSLEN(R5)           on through messages
         BCT   R3,SCRIO1                and round we go
END      EQU   *
         CLOSE (PRINTER)                close the printer
         L     R2,SVC122PL              address of data to free
         STORAGE RELEASE,                                              X
               LENGTH=STORLEN,                                         X
               ADDR=(2),                                               X
               COND=NO
         MODESET MF=(E,PROBMOD)         Get back in 'Problem' state
         XR    R15,R15                  clear return code
         PR                             Restore callers status
*
*---------------------------------------------------------------------
*
* Internal Control blocks etc
*
         LTORG
STORLEN  EQU   4096                     Size of SCCB buffer
PROCFLAG DC    X'00'                    Processing flag
SIDEA    EQU   X'00'                    Side 'A' processing
SIDEB    EQU   X'01'                    Side 'B' processing
*
SAVESTOR DS    F                        Save area for Storage address
SAVE     DS    18F                      'Old fashioned' save area
SAVER10  DS    F                        Save area for Reg 10
*
SUPRMOD  MODESET KEY=ZERO,MODE=SUP,MF=L
PROBMOD  MODESET KEY=NZERO,MODE=PROB,MF=L
*
PRINTER  DCB   DDNAME=SYSPRINT,                                        X
               MACRF=(PM),                                             X
               LRECL=80,                                               X
               RECFM=F,                                                X
               DSORG=PS
*
SVC122PL DC    F'0'                     SVC 122 Parameter List
         DC    A(PARMLIST)
PARMLIST DC    X'00410002'              Read IOCDS request
BLANKS   DC    C' '                     Blanks buffer
WORK1    DC    CL7'0'                   Work area
*
* IOCDS Table (Maximum of 10 IOCDS's per side)
*
IOCDTABA DC    X'00',C'A0'
ENTLEN   EQU   (*-IOCDTABA)
         DC    X'01',C'A1'
         DC    X'02',C'A2'
         DC    X'03',C'A3'
         DC    X'04',C'A4'
         DC    X'05',C'A5'
         DC    X'06',C'A6'
         DC    X'07',C'A7'
         DC    X'08',C'A8'
         DC    X'09',C'A9'
IOCDTABB DC    X'10',C'B0'
         DC    X'11',C'B1'
         DC    X'12',C'B2'
         DC    X'13',C'B3'
         DC    X'14',C'B4'
         DC    X'15',C'B5'
         DC    X'16',C'B6'
         DC    X'17',C'B7'
         DC    X'18',C'B8'
         DC    X'19',C'B9'
IOCDTABE EQU   (*-IOCDTABA)/ENTLEN
IOCDSCNT EQU   IOCDTABE/2
*
* IOCDS Status flags
*
DSCLOSE  EQU   X'64'    - Close specified
DSBUSY   EQU   X'65'    - Busy
DSNOTIN  EQU   X'66'    - Not installed
DSINV    EQU   X'6A'    - Invalid State
DSREADER EQU   X'70'    - Read request past EOF
DSEMPTY  EQU   X'80'    - Not created
DSNOSIDE EQU   X'82'    - Non existent side
DSREADOK EQU   X'C8'    - Read successfully
DSACTIVE EQU   X'C9'    - Read successfully/Active
DSUPDATE EQU   X'CA'    - Active/Updated since POR
DSXXX    EQU   X'CF'    - ???
*
MESSTAB  EQU   *
TITLE1   DC    CL80' ID     IOCDS Title     Type      Status      Date X
                    Time    IODF name'
MESSLEN  EQU   (*-TITLE1)
TITLE2   DC    CL80' --     -----------     ----      ------      ---- X
                    ----    -----------'
MESSBUFF DS    (80*IOCDTABE)X'00'       Message buffer area
*
         REGEQU
AR0      EQU   0
AR1      EQU   1
AR2      EQU   2
AR3      EQU   3
AR4      EQU   4
AR5      EQU   5
AR6      EQU   6
AR7      EQU   7
AR8      EQU   8
AR9      EQU   9
AR10     EQU   10
AR11     EQU   11
AR12     EQU   12
AR13     EQU   13
AR14     EQU   14
AR15     EQU   15
         END
./ ADD NAME=IPLSTAT  0148-00189-09187-1551-00274-00023-00264-TCACF0  00
         TITLE '*** IPLSTAT ***'
IPLSTAT  MOWSTART
IPLSTAT  AMODE 31
IPLSTAT  RMODE 24
***********************************************************************
* DISPLAY IPL TIMING STATS. EACH PHASE OF AN IPL RECORDS ITS TIME IN  *
* A CONTROL BLOCK IN ECSA. NOT SURE WHAT EACH ENTRY REPRESENTS BUT    *
* IT'S AN INTERESTING DISPLAY.                                        *
* SEE IPCS VERBX BLSAIPST OR IPLDATA STATUS                           *
*                                                                     *
* The data collection for IPLDATA STATUS was just a little            *
* thing I hacked together in OS/390 1.3 to help me find a             *
* starting point of where to look when I got asked to help            *
* diagnose "why did that IPL take so long?" problems.                 *
* It presents things in four phases IPL-NIP-IEEVIPL-IEEMB860          *
* because that happens to be how the system initialization            *
* code is structured.  But I was not trying to create any             *
* 'official' terminolgy.  From an internal code point of view,        *
* IPL ends when NIP starts.  From a customer point of view,           *
* IPL more likely is considered to have ended when the system         *
* is ready to run applications - after the network is up, the         *
* database is up, and the applications are up.                        *
*                                                                     *
* Jim Mulder   z/OS System Test   IBM Corp.  Poughkeepsie,  NY        *
***********************************************************************
         L     R4,16                 A(CVT)
         USING CVT,R4
         L     R2,CVTECVT            A(ECVT)
         USING ECVT,R2
         L     R2,ECVTIPST           POINT TO IPL TIMIMG STATS
         USING IHAIPST,R2
         LA    R3,IPSTDATA
         USING IPSTITEM,R3
         SR    R10,R10               CLEAR FOR LATER USE
         OPEN  (SYSPRINT,(OUTPUT))   OPEN OUTPUT FILE
         PUT   SYSPRINT,MESS0
         LA    R9,STAGE
LP1      EQU   *
         MVC   MESS+00(3),=C'RIM'
         CLI   IPSTITEMKEY,IPSTKEYIRIM          RIM PHASE?
         BE    GOTKEY
         MVC   MESS+00(3),=C'NIP'
         CLI   IPSTITEMKEY,IPSTKEYNIPRIM        NIP PHASE?
         BE    GOTKEY
         MVC   MESS+00(3),=C'MSI'
         CLI   IPSTITEMKEY,IPSTKEYMSIFUNC       MSI PHASE?
         BE    GOTKEY
         SR    R11,R11
         IC    R11,IPSTITEMLEN
         CLI   IPSTITEMKEY,IPSTKEY04            04 KEY?
         BE    SKIP
         CLI   IPSTITEMKEY,IPSTKEY05            05 KEY?
         BE    SKIP
         CLI   IPSTITEMKEY,IPSTKEY06            06 KEY?
         BE    SKIP
         CLI   IPSTITEMKEY,IPSTKEY07            07 KEY?
         BE    SKIP
         CLI   IPSTITEMKEY,IPSTKEYFF            FF KEY?
         BE    SKIP
GOTKEY   EQU   *
         MVC   MESS+06(2),IPSTITEMDATA          GET ITEM CODE
         IC    R10,IPSTITEMLEN
         LR    R11,R10                          COPY LENGTH
         SH    R10,=H'3'                        ADJUST FOR MVC
*        EX    R10,MVCDATA1
         ICM   R7,B'1111',IPSTITEMDATA+2
         CLI   IPSTITEMKEY,IPSTKEYMSIFUNC       MSI PHASE?
         BNE   DOPUT
*        EX    R10,MVCDATA2
         MVC   MESS+06(8),IPSTITEMDATA          GET ITEM CODE
         ICM   R7,B'1111',IPSTITEMDATA+8
DOPUT    EQU   *
         XC    WKCELL2,WKCELL2
         MVC   WKCELL2+2(4),IPSTITEMDATA+8
         STCM  R7,B'1111',WKCELL2+2
*        CVD   R7,DOUBLE                        MAKE IT DECIMAL
*        MVC   MESS+13(12),=X'402020206B2020206B202120'
*        ED    MESS+13(12),DOUBLE+3             EDIT NUMBER INTO IT
*
         BRAS  R7,IPST90                time-units to time
         MVC   MESS+14(13),=X'F021207A20207A20204B202020'
         ED    MESS+14(13),RESULT
         MVI   MESS+14,X'40'
*
         MVC   MESS+29(SLEN),0(R9)
         LA    R9,SLEN(,R9)
*
         PUT   SYSPRINT,MESS
*        SETMODE 24
*        TPUT  MESS,L'MESS
*        SETMODE 31
SKIP     EQU   *
         LA    R3,2(R3,R11)             POINT TO NEXT ITEM
         C     R3,IPSTNEXT
         BL    LP1
         CLOSE (SYSPRINT)
         B     FIN
*
IPST90   DS 0H                     CODE FROM ROLAND SCHIRADIN
         LM    R14,R15,=X'8126D60E46000000' SINCE 1972
         LM    R0,R1,WKCELL2                TIME-UNITS
         ALR   R14,R0
         ALR   R15,R1
         BRC   12,NOINCR
         AL    R14,=F'1'
NOINCR   DS    0H
         STM   R14,R15,WKCELL2
         LA    R1,WKCELL2              pass TOD clock value
*
         STCKCONV STCKVAL=WKCELL2,     GET TOD TO CONVERT              *
               CONVVAL=RESULT,         PUTTING RESULTS HERE            *
               TIMETYPE=DEC,           WITH TIME IN DECIMAL FORMAT     *
               DATETYPE=MMDDYYYY       AND DATE IN THIS FORMAT
         BR    R7
*
FIN      EQU   *
         MOREND
*
MVCDATA1 MVC   MESS+11(*-*),IPSTITEMDATA+2
MVCDATA2 MVC   MESS+11(*-*),IPSTITEMDATA
DOUBLE   DC    D'0'
WKCELL2  DC    XL8'00'
RESULT   DC    CL16' '       HHMMSSTTTTTT0000MMDDYYYY........
* You challenge my memory - it was 1996 when I wrote this code.
* It looks like the time units are the middle 4 bytes of
* 8-byte TOD clock units.  So you zero an 8-byte field, copy the 4-byte
* time units into the middle of the 8-byte field, add the time it was
* at the beginning of 1972 (X'8126D60E46000000'), pass the result to
* BLSUXTOD, and use the time portion (throw away the date) which is
* returned.
*
* Jim Mulder   z/OS System Test   IBM Corp.  Poughkeepsie,  NY
*
*                   0123456789 123456789 123456789 123456789 123456789
MESS0    DC    CL80'KEY  CODE           VALUE          TIME'
MESS     DC    CL80' '
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),LRECL=80,RECFM=FB
*
* THIS TABLE IS CREATED FROM THE OUTPUT OF THE IPCS COMMAND
*                123456789 123456789 123456789 123456789 123456789 123
STAGE    EQU   *
         DC    C'IEAIPL10 ISNIRIM - Read SCPINFO                     '
SLEN     EQU   *-STAGE
         DC    C'IEAIPL20 Test Block storage to 2G                   '
         DC    C'IEAIPL11 Fast FIND service                          '
         DC    C'IEAIPL31 LOAD service                               '
         DC    C'IEAIPL30 IPLWTO service                             '
         DC    C'IEAIPL46 Read SCHIBs into IPL workspace             '
         DC    C'IEAIPL49 Process Load and Default parameters        '
         DC    C'IEAIPL50 IPL parmlib - process LOADxx and NUCLSTxx  '
         DC    C'IEAIPL51 System architecture                        '
         DC    C'IEAIPL43 Find and Open IODF data set                '
         DC    C'IEAIPL60 Read NCRs from IODF                        '
         DC    C'IEAIPL70 UIM environment - load CBD and IOS services'
         DC    C'IEAIPL71 Build DFT for each device                  '
         DC    C'IEAIPL08 Read EDT information from IODF             '
         DC    C'IEAIPL40 Read MLTs from nucleus                     '
         DC    C'IEAIPL42 Read NMLs from nucleus (IEANynnn modules)  '
         DC    C'IEAIPL41 Read PDS directory entries and CESD records'
         DC    C'IEAIPL05 Build and sort NUCMAP                      '
         DC    C'IEAIPL02 Load nucleus modules                       '
         DC    C'IEAIPL04 Allocate PFT and SQA/ESQA                  '
         DC    C'IEAIPL14 Build LSQA/ELSQA for Master                '
         DC    C'IEAIPL09 IAXMI - PFT, master RAB,  etc.             '
         DC    C'IEAIPL07 Update AMODE for nucleus resident SVCs     '
         DC    C'IEAIPL03 Build UCBs, ULUT, etc.                     '
         DC    C'IEAIPL18 Copy and relocate EDT to ESQA              '
         DC    C'IEAIPL99 Page frame table and cleanup               '
         DC    C'IEAVNIP0 NIP Base                                   '
         DC    C'IEAVNIPM Invoke NIP RIMs                            '
         DC    C'IEAVNPE6 Service Processor Interface                '
         DC    C'IEAVNPFF Loadwait/Restart                           '
         DC    C'IEAVNPA6 RTM - RTCT and recording buffer            '
         DC    C'IEAVNPC6 WTO                                        '
         DC    C'IEAVNPC3 Issue messages from IPL message queue      '
         DC    C'IEAVNP24 SMS Open/Mount                             '
         DC    C'IEAVNP06 Machine Check                              '
         DC    C'IEAVNP27 Reconfiguration                            '
         DC    C'IEAVNPA2 IOS - Non-DASD UCBs                        '
         DC    C'IEAVNPCA NIP Console                                '
         DC    C'IEAVNPB2 IOS - DASD UCBs                            '
         DC    C'IEAVNP11 Locate and Open master calalog             '
         DC    C'IEAVNPC7 Open SYS1.SVCLIB                           '
         DC    C'IEAVNPOP Open PARMLIB                               '
         DC    C'IEAVNPIL Process IEALSTxx                           '
         DC    C'IEAVNPC4 Prompt for System Parameters               '
         DC    C'IEAVNP03 Merge and analyze system parameters        '
         DC    C'IEAVNPCF Process system name and system variables   '
         DC    C'IEAVNP76 Open LOGREC                                '
         DC    C'IEAVNPE8 RSM - Process REAL=                        '
         DC    C'IEAVNP23 Build GRS blocks in SQA                    '
         DC    C'IEAVNP04 ASM - Open page and swap data sets         '
         DC    C'IEAVNPA8 VSM - Expand SQA                           '
         DC    C'IEAVNP14 ASM part 2 - Build SQA control blocks      '
         DC    C'IEAVNPGD Move console data to ESQA                  '
         DC    C'IEAVNP25 Process SVC=                               '
         DC    C'???                                                 '
         DC    C'IEAVNP05 LPA, APF                                   '
         DC    C'IEAVNP44 ASA Reuse stuff                            '
         DC    C'IEAVNPB1 Process CSCBLOC=                           '
         DC    C'IEAVNPE2 RACF SAF                                   '
         DC    C'IEAVNPB8 Create CSA                                 '
         DC    C'IEAVNP47 ENF                                        '
         DC    C'IEAVNPD6 RTM - SDUMP, ABDUMP, ESTAE                 '
         DC    C'IEAVNP09 Build ASVT                                 '
         DC    C'IEAVNPD8 RSM - Frame queues, VRREGN= and RSU=       '
         DC    C'IEAVNP10 SRM - OPT=, IPS=, etc.                     '
         DC    C'IEAVNPD1 ABDUMP                                     '
         DC    C'IEAVNPD2 SDUMP                                      '
         DC    C'IEAVNPCX Context services, registration services    '
         DC    C'IEAVNPX1 NIP cleanup                                '
         DC    C'IEAVNPF5 PCAUTH                                     '
         DC    C'IEAVNPF8 RASP                                       '
         DC    C'IEAVNP1F SRM - I/O measurement blocks               '
         DC    C'IEAVNPC2 IOS - Move CDT to SQA                      '
         DC    C'IEAVNP51 TRACE                                      '
         DC    C'IEAVNP20 Process CLOCK=                             '
         DC    C'IEAVNP21 TOD clock                                  '
         DC    C'IEAVNP57 SDUMP                                      '
         DC    C'IEAVNPF9 XCF                                        '
         DC    C'IEAVNP33 GRS                                        '
         DC    C'IEAVNPED PROD                                       '
         DC    C'IEAVNP26 SMS                                        '
         DC    C'IEAVNPE5 LNKLST                                     '
         DC    C'IEAVNPD5 Load pageable device support modules       '
         DC    C'IEAVNP88 Allocation move EDT II                     '
         DC    C'IEAVNPA1 CONSOLE                                    '
         DC    C'IEAVNPDC WLM                                        '
         DC    C'IEAVNP16 EXCP appendages                            '
         DC    C'IEAVNP13 Prepare NIP/MSI interface                  '
         DC    C'IEAVNP17 GTF Monitor Call interface                 '
         DC    C'IEAVNPG8 VSM defined monitor call enablement        '
         DC    C'IEAVNP18 PARMLIB Scan Routine interface             '
         DC    C'IEAVNPF2 Process IOS=                               '
         DC    C'IEAVNP15 Process VATLST                             '
         DC    C'IEAVNPRR RRS                                        '
         DC    C'IEAVNPOE USS                                        '
         DC    C'IEAVNPSC                                            '
         DC    C'IEAVNPLE System LE RIM                              '
         DC    C'IEAVNPUN Unicode                                    '
         DC    C'IEAVNPXL                                            '
         DC    C'IEAVNP1B Close catalog                              '
         DC    C'IEAVNIPX Nip final cleanup                          '
         DC    C'IEETRACE Master trace                               '
         DC    C'ISNMSI   SPI                                        '
         DC    C'UCMPECBM CONSOLE address space                      '
         DC    C'ENFPC005 CONSOLE ready ENF                          '
         DC    C'IEFSCHIN IEFSCHAS address space                     '
         DC    C'IEFJSINT Subsystem interface                        '
         DC    C'IEFSJLOD JESCT                                      '
         DC    C'IAZINIT  JESXCF address space                       '
         DC    C'IAZFSII  FSI trace                                  '
         DC    C'IEFQBINT SWA manager                                '
         DC    C'IEFAB4I0 ALLOCAS address space                      '
         DC    C'------>  Stage time                                 '
         DC    C'ILRTMRLG ASM                                        '
         DC    C'IECVIOSI IOS dynamic pathing                        '
         DC    C'ATBINSYS APPC                                       '
         DC    C'IKJEFXSR TSO                                        '
         DC    C'IXGBLF00 Logger                                     '
         DC    C'HWIAMIN1                                            '
         DC    C'COMMNDXX COMMANDxx processing                       '
         DC    C'SMFWAIT  SMF                                        '
         DC    C'SECPROD  Security server                            '
         DC    C'IEFJSIN2 SSN= subsystem                             '
         DC    C'IEFHB4I2 ALLOCAS - UCB scan                         '
         DC    C'CSRINIT  Windowing services                         '
         DC    C'FINSHMSI Wait for attached CMDs                     '
         DC    C'IEEMB860                                            '
         IHAIPST
         PRINT NOGEN
         CVT   DSECT=YES
         IHAECVT
         END
./ ADD NAME=JULSUB   0109-86071-04117-0937-00570-00562-00022-TCACF0  00
         TITLE '   J U L S U B   '
************************************************************
*                                                          *
*        'JULSUB'                                          *
*                                                          *
************************************************************
         SPACE
*        WRITTEN BY. BILL GODFREY,  PLANNING RESEARCH CORPORATION.
*        INSTALLATION. PRC COMPUTER CENTER, MCLEAN VA.
*        DATE WRITTEN. JUNE 4 1976.
*        DATE UPDATED. APRIL 23 1980.
*        ATTRIBUTES. RE-ENTRANT.
*        REMARKS.
*            THIS SUBPROGRAM CONVERTS A DATE FROM ONE FORMAT
*            TO ANOTHER. THE DIFFERENT FORMATS ARE:
*
*            INPUT
*               1   JULIAN       BINARY    F'YYYYDDD'
*               2   STANDARD     BINARY    F'YYYYMMDD'
*               3   JULIAN       PACKED    PL4'YYYYDDDF'
*
*            OUTPUT
*               1   JULIAN       BINARY    F'YYYYDDD'
*               2   STANDARD     BINARY    F'YYYYMMDD'
*               4   STANDARD     8-CHAR    CL8'MM/DD/YY'
*               8   ALPHA        8-CHAR    CL8'03JUN76 '
*              16   PROSE        20-CHAR   CL20'JUNE 3 1976'
*              32   FRSTLAST     BINARY    F'0' 1 - FIRST OF MONTH
*                                               2 - LAST OF MONTH
*              64   WEEKDAYCODE  BINARY    F'0' (SATURDAY)
*             128   WEEKDAY      12-CHAR   CL12'SATURDAY'
*             256   TIME         BINARY    F'100THS SEC SINCE MIDNITE'
*             512   TIME         8-CHAR    CL8'HH:MM:SS'
*
*            INPUT MUST BE EITHER JULIAN OR STANDARD.
*
*            PASS THE FOLLOWING PARAMETERS VIA A LIST OF ADDRESSES
*            POINTED TO BY REGISTER 1
*               1   THE INPUT DATE
*               2   A FULLWORD CONTAINING THE NUMERIC CODE
*                   WHICH DEFINES THE INPUT FORMAT
*               3   THE RECEIVING FIELD FOR OUTPUT
*               4   A FULLWORD CONTAINING THE NUMERIC CODE
*                   WHICH DEFINES THE OUTPUT FORMAT
*               5   A 256 BYTE WORKAREA (ON DOUBLEWORD BOUNDARY)
*            NOTES.
*               1) MAKE OUTPUT 00YY IF INPUT IS 00YY.
*               2) FOR CURRENT DATE, USE TYPE 1 DATE ZERO.
         SPACE
         MACRO
         STAMP
         LCLC  &ASMTIME
&ASMTIME SETC  '&SYSTIME'(1,5)
         DC    CL16' &SYSDATE &ASMTIME '
         MEND
         SPACE
JULSUB   CSECT
JULSUB   AMODE 31
JULSUB   RMODE ANY
         USING *,R12
         B     @PROLOG-*(,15)
         DC    AL1(11),CL11'JULSUB   '
         STAMP
@PROLOG  STM   14,12,12(13)
         LR    R12,15
         LR    R2,R1
*        GETMAIN R,LV=@DATAL       GET SAVEAREA ADDRESS
         L     R1,16(,R1)          GET SAVEAREA ADDRESS
         ST    13,4(,1)
         ST    1,8(,13)
         LR    13,1
         LR    R1,R2
         USING @DATA,13
         SPACE
         LM    R2,R3,0(R1)         GET INPUT AND DESCRIPTOR
         LM    R4,R5,8(R1)         GET OUTPUT AND DESCRIPTOR
         MVC   INPUT(4),0(R2)      COPY INPUT
         XC    DOUBLE,DOUBLE
         SLR   R14,R14             ZERO R14
         ST    R14,FRSTLAST
         ST    R14,TIMEB
         CLI   3(R3),INP003        INPUT JULIAN PACKED? INPUT TYPE 3
         BNE   INP01               NO - BRANCH
         SPACE
*              INPUT IS JULIAN PACKED
         SPACE
         MVC   DOUBLE+4(4),INPUT   MOVE INPUT
         OI    DOUBLE+7,X'0F'      SET SIGN - SHOULD ALREADY BE DONE
         CVB   R1,DOUBLE
         ST    R1,JB
JULCOMM  L     R14,DOUBLE+4        SAVE 00YYDDDF
         LH    R1,DOUBLE+4         GET 00YY
         SLL   R1,16               GET 00YY0000
         SRL   R1,12               GET 00000YY0
         ST    R1,DOUBLE+4         STORE BACK 00000YY0
         OI    DOUBLE+7,X'0F'      SET SIGN
         CVB   R1,DOUBLE
         ST    R1,YYYYB
*        CH    R1,=H'99'            Y2K, ALWAYS ADD
*        BH    *+8
         AH    R1,=H'2000'
         ST    R1,CENTB
         UNPK  YYYYC,DOUBLE+5(3)     SAVE YYYY CHAR
         MVC   YYC,YYYYC+2
*
         ST    R14,DOUBLE+4        RESTORE 00YYDDDF
         XC    DOUBLE(6),DOUBLE    00YYDDDF TO 0000DDDF
         OI    DOUBLE+7,X'0F'      SET SIGN
         UNPK  DDDC,DOUBLE+4(4)    SAVE DDD CHAR
         CVB   R1,DOUBLE           CONVERT DDD TO BINARY
         ST    R1,DDDB             SAVE DDD BINARY
         SPACE
         BAL   R9,TODD
         BAL   R9,TOSB
         BAL   R9,TOMON
         BAL   R9,TOPROSE
         BAL   R9,TOWEEK
         BAL   R9,TOTIME
         BAL   R9,OUTPUT
         B     EXIT0
         SPACE
INP01    CLI   3(R3),INP001        INPUT JULIAN BINARY? INPUT TYPE 1
         BNE   INP02               NO - BRANCH
         L     R1,INPUT            GET BINARY YYYYDDD
         LTR   R1,R1               ZERO?
         BNZ   INP01A              NO - BRANCH
         TIME  BIN
         ST    R0,TIMEB            SAVE TIME
         SLR   R0,R0
         STM   R0,R1,DOUBLE
         CVB   R1,DOUBLE
         B     INP01B
INP01A   CVD   R1,DOUBLE           TO DECIMAL
INP01B   ST    R1,JB
         B     JULCOMM             PROCEED AS IF INP003
         SPACE
*              CONVERT JULIAN DATE TO MONTH-DAY-YEAR
*
*                 INPUT  - YYYYB AND DDDB   (ALSO YYC)
*
*                 OUTPUT - MMB AND DDB, MMC AND DDC, FRSTLAST
         SPACE
TODD     MVC   DPM(26),DAYSPMON
         TM    YYYYB+3,B'00000011' IS YEAR A MULTIPLE OF 4?
         BNZ   DPM365              NO - BRANCH
         CLC   YYC,=C'00'          DIVISIBLE BY 100?
         BNE   DPM366              NO - BRANCH
         L     R15,CENTB
         SLR   R14,R14
         D     R14,=F'400'
         LTR   R14,R14             EVENLY DIVISIBLE BY 400?
         BNZ   DPM365              NO - NOT A LEAP YEAR
DPM366   MVI   DPM+3,29            CHANGE FEB TO 29 DAYS
DPM365   EQU   *
         LA    R14,2               INDEX FOR DPM
         LR    R0,R14              INDEX INCREMENT
         L     R1,DDDB             DAY OF YEAR
DPMLOOP  CH    R1,DPM-2(R14)       DAY LESS THAN OR EQ ENTRY?
         BE    DPMEND              EQUAL - BRANCH
         BL    DPMWIN              LESS - BRANCH
         SH    R1,DPM-2(R14)       NO, SUBTRACT ENTRY FROM DAY
         ALR   R14,R0              ADD 2 TO INDEX
         B     DPMLOOP             LOOP
DPMEND   MVI   FRSTLAST+3,2        LAST DAY OF MONTH
         B     DPMCOMM
DPMWIN   CH    R1,=H'1'            FIRST OF MONTH?
         BNE   DPMCOMM             NO - BRANCH
         MVI   FRSTLAST+3,1        FIRST DAY OF MONTH
DPMCOMM  SRL   R14,1               HALVE INDEX TO GET MM
         ST    R1,DDB              SAVE DD BINARY
         CVD   R1,DOUBLE           CONVERT TO PACKED
         OI    DOUBLE+7,X'0F'      SET SIGN
         UNPK  DDC,DOUBLE+6(2)     SAVE DD CHAR
         ST    R14,MMB             SAVE MM BINARY
         CVD   R14,DOUBLE          CONVERT TO PACKED
         OI    DOUBLE+7,X'0F'      SET SIGN
         UNPK  MMC,DOUBLE+6(2)     SAVE MM CHAR
         MVI   SLASH1,C'/'
         MVI   SLASH2,C'/'
         BR    R9
         SPACE
*              CONVERT MONTH NUMBER TO MONTH NAME
*
*                 INPUT  - MMB     (ALSO DDC AND YYC FOR MOVE)
*
*                 OUTPUT - MONTH AND ALPHA
         SPACE
TOMON    L     R15,MMB
         MH    R15,=H'9'           MULT BY 9
         LA    R15,ALPHAMON-9(R15) ADDRESS OF ENTRY
         MVC   MONTH,0(R15)        SAVE PROSE MONTH
         MVC   ALPHA+2(3),0(R15)   SAVE ALPHA MONTH
         MVC   ALPHA(2),DDC
         MVC   ALPHA+5(2),YYC
         MVI   ALPHA+7,C' '
         BR    R9
         SPACE
*              BUILD PROSE DATE
*
*                 INPUT  - MONTH, DDC, YYYYC
         SPACE
TOPROSE  TM    3(R5),OUT016
         BZR   R9
         MVI   PROSE,C' '
         MVC   PROSE+1(L'PROSE-1),PROSE
         MVC   PROSE(9),MONTH
         LA    R1,PROSE+9
PROSE01  CLI   0(R1),C' '          BLANK?
         BNE   PROSE02             NO - FOUND LAST LETTER
         BCT   R1,PROSE01          BACK UP AND BRANCH
PROSE02  MVC   2(2,R1),DDC
         CLI   2(R1),C'0'          LEADING ZERO?
         BNE   PROSE03             NO - BRANCH
         MVC   2(1,R1),3(R1)       YES - SHIFT
         MVI   3(R1),C' '
         BCTR  R1,0
PROSE03  EQU   *
*        MVI   4(R1),C','          COMMA AFTER DAY
*        LA    R1,1(,R1)           ADD 1 FOR COMMA
         MVC   5(4,R1),YYYYC
         CLC   5(2,R1),=C'00'      IS THIS DATE 20XX?
         BNE   PROSE04             NO
         MVC   5(2,R1),=C'20'      MAKE YY = 20
         BR    R9
PROSE04  EQU   *
*        CLC   5(2,R1),=C'00'      IS THIS DATE 19XX?
*        BNER  R9                  NO
*        MVC   5(2,R1),=C'19'      MAKE YY = 19
         BR    R9
         SPACE
*              INPUT IS YYYY/MM/DD BINARY - INPUT TYPE 2
         SPACE
INP02    L     R1,INPUT
         CVD   R1,DOUBLE           GET 0000000Y YYYMMDDF
         LM    R14,R15,DOUBLE
         NC    DOUBLE,=X'0000000000000FFF' ISOLATE 00000DDF
         CVB   R1,DOUBLE
         ST    R1,DDB
         OI    DOUBLE+7,X'0F'
         UNPK  DDC,DOUBLE+6(2)
*
         STM   R14,R15,DOUBLE
         NC    DOUBLE,=X'00000000000FF00F' ISOLATE 000MM00F
         L     R1,DOUBLE+4
         SRL   R1,8
         ST    R1,DOUBLE+4
         OI    DOUBLE+7,X'0F'
         CVB   R1,DOUBLE
         CH    R1,=H'12'
         BNH   *+8
         LA    R1,13               SET ALL BAD MONTHS TO 13
         ST    R1,MMB
         UNPK  MMC,DOUBLE+6(2)
*
         SRDL  R14,4               GET YYYYMMDD
         SLR   R14,R14             GET 00000000 IN R14
         SRL   R15,12              GET 000YYYYM IN R15
         STM   R14,R15,DOUBLE
         OI    DOUBLE+7,X'0F'
         CVB   R1,DOUBLE
         ST    R1,YYYYB
*        CH    R1,=H'99'           Y2K, ALWAYS ADD
*        BH    *+8
         AH    R1,=H'2000'
         ST    R1,CENTB
         UNPK  YYYYC,DOUBLE+5(3)
         MVC   YYC,YYYYC+2
         MVI   SLASH1,C'/'
         MVI   SLASH2,C'/'
*
         BAL   R9,TOSB
         BAL   R9,TOJUL
         BAL   R9,TOMON
         BAL   R9,TOPROSE
         BAL   R9,TOWEEK
         BAL   R9,TOTIME
         BAL   R9,OUTPUT
         B     EXIT0
         SPACE
*              CONVERT M/D/Y TO JULIAN
*
*                 INPUT  - MMB, DDB, YYYYB
*
*                 OUTPUT - DDDB, DDDC, JB
         SPACE
TOJUL    MVC   DPM(26),DAYSPMON
         TM    YYYYB+3,B'00000011' IS YEAR A MULTIPLE OF 4?
         BNZ   JUL365              NO - BRANCH
         CLC   YYC,=C'00'          DIVISIBLE BY 100?
         BNE   JUL366              NO - BRANCH
         L     R15,CENTB
         SLR   R14,R14
         D     R14,=F'400'
         LTR   R14,R14             EVENLY DIVISIBLE BY 400?
         BNZ   JUL365              NO - NOT A LEAP YEAR
JUL366   MVI   DPM+3,29             CHANGE FEB TO 29 DAYS
JUL365   EQU   *
         L     R15,DDB              GET DAYS IN CURRENT MONTH
         LR    R0,R15               SAVE IT TO COMPARE FOR LAST DAY
         L     R14,MMB              GET CURRENT MONTH
         BCTR  R14,0                GET NO. OF COMPLETED MONTHS
         LA    R1,DPM
         LTR   R14,R14              JANUARY?
         BNP   JULEND               YES - BRANCH
         B     *+8
JULOOP   LA    R1,2(,R1)            POINT TO NEXT MONTH
         AH    R15,0(,R1)           ADD DAYS IN MONTH TO TOTAL
         BCT   R14,JULOOP
JULEND   CH    R0,0(,R1)            LAST DAY OF MONTH?
         BNE   *+8                  NO
         MVI   FRSTLAST+3,2         YES
         CH    R0,=H'1'             FIRST DAY OF MONTH?
         BNE   *+8                  NO
         MVI   FRSTLAST+3,1         YES
         ST    R15,DDDB             SAVE DDD
         CVD   R15,DOUBLE
         OI    DOUBLE+7,X'0F'       SET SIGN
         UNPK  DDDC,DOUBLE+4(4)     SAVE DDD CHAR
         MVC   JC(2),YYC
         PACK  DOUBLE,JC
         CVB   R1,DOUBLE
         ST    R1,JB
         BR    R9
         SPACE
*
*
*
         SPACE
TOSB     MVC   WORK(4),YYYYC
         MVC   WORK+4(2),MMC
         MVC   WORK+6(2),DDC
         PACK  DOUBLE,WORK(8)
         CVB   R1,DOUBLE
         ST    R1,SB
         BR    R9
         SPACE
*              GET DAY OF WEEK
*
*                 INPUT  - MMB, DDB, YYYYB
*
*                 OUTPUT - WEEKB, WEEKC
*
*              N = D + 2M + 3(M+1)/5 + Y + Y/4 - Y/100 + Y/400 + 2
*
*                 WHERE M = 3-14 (JAN,FEB ARE 13,14 OF Y-1)
*
*                 N/7 LEAVES REMAINDER 0-6, 0 INDICATING SATURDAY
*
TOWEEK   TM    3(R5),OUT064+OUT128
         BZR   R9
         L     R1,DDB              SET N = D
         L     R15,CENTB
         L     R14,MMB
         CH    R14,=H'2'           JAN OR FEB?
         BH    WEEKMMOK
         BE    WEEKFEB
         LA    R14,13              SET M=13
         B     WEEKYMIN
WEEKFEB  LA    R14,14              SET M=14
WEEKYMIN BCTR  R15,0               SET Y = Y-1
WEEKMMOK LR    R0,R14              COPY M
         ALR   R0,R0               GET 2M
         ALR   R1,R0               SET N = N + 2M
         LR    R0,R15              SAVE REDEFINED Y
         SPACE
         LA    R14,1(,R14)         GET M+1
         MH    R14,=H'3'           GET 3(M+1)
         SRDL  R14,32              SHIFT INTO R15, ZERO R14
         D     R14,=F'5'           GET 3(M+1)/5 IN R15
         ALR   R1,R15              SET N = N + 3(M+1)/5
         SPACE
         LR    R15,R0              GET Y
         ALR   R1,R15              SET N = N + Y
         SLR   R14,R14             ZERO R14
         D     R14,=F'4'           GET Y/4
         ALR   R1,R15              SET N = N + Y/4
         SPACE
         LR    R15,R0              GET Y
         SLR   R14,R14             ZERO R14
         D     R14,=F'100'         GET Y/100
         SLR   R1,R15              SET N = N - Y/100
         SPACE
         LR    R15,R0              GET Y
         SLR   R14,R14             ZERO R14
         D     R14,=F'400'         GET Y/400
         ALR   R1,R15              SET N = N + Y/400
         LA    R15,2               GET 2
         ALR   R1,R15              SET N = N + 2
         SLR   R0,R0               ZERO R0
         D     R0,=F'7'            SET N = N/7
         ST    R0,WEEKB            SAVE REMAINDER
         LR    R1,R0
         MH    R1,=H'9'
         LA    R14,WEEKDAYS(R1)    POINT TO NAME
         MVC   WEEKC(9),0(R14)     MOVE NAME
         MVC   WEEKC+9(3),WEEKBLNK PLUS 3 BLANKS
         BR    R9
         SPACE
*
*              CONVERT TIMEB TO TIMEC
*
*                 DIVIDE BY 10,10,10,6,10,6,10,6
*
TOTIME   TM    2(R5),OUT512
         BNOR  R9
         L     R15,TIMEB
         LA    R6,10               INITIAL DIVISOR
         LA    R7,12               SET DIVISOR MASK
         LA    R8,32               SHIFT COUNT
DECLOOP  SR    R14,R14
         DR    R14,R6
         LR    R0,R14              SAVE REMAINDER
         SRDL  R0,4                SHIFT INTO R1
         SH    R8,=H'4'            DECREMENT SHIFT COUNT
         LTR   R15,R15             QUOTIENT ZERO?
         BZ    TOTIMX              YES - BRANCH
         CL    R8,=F'24'           IF COUNT LT 24
         BNL   DECLOOP             NO - BRANCH
         XR    R6,R7               10 TO 6 TO 10 ETC
         B     DECLOOP
TOTIMX   SRL   R1,0(R8)            SHIFT REMAINING BITS
         SRL   R1,4                GET 0HHMMSST
         ST    R1,DOUBLE
         OI    DOUBLE+3,X'0F'
         MVC   DOUBLE+6(10),=X'402120204B20204B2020'
         ED    DOUBLE+6(10),DOUBLE
         MVC   TIMEC,DOUBLE+8
         BR    R9
         SPACE
OUTPUT   LR    R1,R4
         TM    3(R5),OUT001
         BZ    *+14
         MVC   0(4,R1),JB
         LA    R1,4(,R1)
         TM    3(R5),OUT002
         BZ    *+14
         MVC   0(4,R1),SB
         LA    R1,4(,R1)
         TM    3(R5),OUT004
         BZ    *+14
         MVC   0(8,R1),SC
         LA    R1,8(,R1)
         TM    3(R5),OUT008
         BZ    *+14
         MVC   0(8,R1),ALPHA
         LA    R1,8(,R1)
         TM    3(R5),OUT016
         BZ    *+14
         MVC   0(L'PROSE,R1),PROSE
         LA    R1,L'PROSE(,R1)
         TM    3(R5),OUT032
         BZ    *+14
         MVC   0(4,R1),FRSTLAST
         LA    R1,4(,R1)
         TM    3(R5),OUT064
         BZ    *+14
         MVC   0(4,R1),WEEKB
         LA    R1,4(,R1)
         TM    3(R5),OUT128
         BZ    *+14
         MVC   0(12,R1),WEEKC
         LA    R1,12(,R1)
         TM    2(R5),OUT256
         BZ    *+14
         MVC   0(4,R1),TIMEB
         LA    R1,4(,R1)
         TM    2(R5),OUT512
         BZ    *+14
         MVC   0(8,R1),TIMEC
         LA    R1,8(,R1)
         BR    R9
         SPACE
EXIT0    SR    15,15
EXIT     LR    1,13
         L     13,4(,13)
         ST    15,16(,13)
*        FREEMAIN R,A=(1),LV=@DATAL  (COMMENT)
         LM    14,12,12(13)
         BR    14
         SPACE
************************************************************
*                                                          *
*        CONSTANTS                                         *
*                                                          *
************************************************************
         SPACE
DAYSPMON DC    H'31,28,31,30,31,30,31,31,30,31,30,31,999'
ALPHAMON DC    CL36'JANUARY  FEBRUARY MARCH    APRIL    '
         DC    CL36'MAY      JUNE     JULY     AUGUST   '
         DC    CL36'SEPTEMBEROCTOBER  NOVEMBER DECEMBER '
         DC    CL09'UNKNOWN  '
WEEKDAYS DC    CL36'SATURDAY SUNDAY   MONDAY   TUESDAY  '
         DC    CL27'WEDNESDAYTHURSDAY FRIDAY   '
WEEKBLNK EQU   WEEKDAYS+15         3 BLANKS
         LTORG
         SPACE
************************************************************
*                                                          *
*        DSECTS                                            *
*                                                          *
************************************************************
         SPACE
@DATA    DSECT
         DS    18F
INPUT    DS    CL8
DOUBLE   DS    D
WORK     DS    8C
SC       DS    0CL8
MMC      DS    CL2
SLASH1   DS    C
DDC      DS    CL2
SLASH2   DS    C
YYC      DS    CL2
YYYYC    DS    CL4
DDB      DS    F
MMB      DS    F
YYYYB    DS    F
CENTB    DS    F
DDDB     DS    F
JB       DS    F
SB       DS    F
WEEKB    DS    F
FRSTLAST DS    F
TIMEB    DS    F
TIMEC    DS    CL8
JC       DS    0CL5
         DS    CL2
DDDC     DS    CL3
MONTH    DS    CL9
ALPHA    DS    0CL8
         DS    CL2
MON      DS    CL3
         DS    CL2
         DS    CL1                 BLANK FILLER LAST BYTE OF ALPHA
WEEKC    DS    CL12
PROSE    DS    CL20
DPM      DS    13H
@DATAL   EQU   *-@DATA
         SPACE
INP001   EQU   1
INP002   EQU   2
INP003   EQU   3
OUT001   EQU   1
OUT002   EQU   2
OUT004   EQU   4
OUT008   EQU   8
OUT016   EQU   16
OUT032   EQU   32
OUT064   EQU   64
OUT128   EQU   128
OUT256   EQU   1
OUT512   EQU   2
         SPACE
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
./ ADD NAME=LASTCLPA 0120-87092-16320-0750-00267-00245-00267-SBGOLOB 41
         TITLE '*** LASTCLPA ***'
LASTCLPA MOWSTART
LASTCLPA AMODE  31
LASTCLPA RMODE  24
***********************************************************************
* THIS PROGRAM IS USED TO DETERMINE THE DATE AND TIME OF THE MOST     *
* RECENT CLPA. IT CAN BE USED TO VERIFY IF THE OPERATOR REALLY DID    *
* DO A CLPA IN RESPONSE TO IEA101A AT IPL TIME.                       *
* UNDER ESA GOES IN SYS2.LINKLIB, SETCODE AC(1).                      *
***********************************************************************
         USING CVTMAP,R11
         L     R11,16                   A(CVT)
         ICM   R1,15,0(R1)              POINT TO PARAMETER
         LH    R2,0(R1)                 PICK UP LENGTH
         BL    COMP4                    ONLY ONE PARM
         SH    R2,=H'4'                 SUBTRACT 2 1/2 WDS OF LENGTH
         SH    R2,2(R1)                 SUBTRACT LENGTH OF COMMAND NAME
         BZ    NOPARM                   NO LENGTH LEFT, NO PARM
         AH    R1,2(R1)                 SKIP OVER COMMAND NAME
         LA    R1,4(,R1)                AND 4 BYTES OF LENGTH
COMP4    EQU   *
         LTR   R2,R2                    TEST FOR NOT ZERO
         BNZ   PARM                     PARM SUPPLIED
NOPARM   EQU   *
*        SETMODE 31                     31-BIT ADDRESSING ON
         L     R2,CVTASMVT              A(ASMVT)
         L     R5,8(R2)                 A(PAGING ART)
         L     R3,24(R5)                A(DSN LIST)
         MVC   PAGEDSN(44),0(R3)      PLPA NAME (ALWAYS FIRST IN LIST)
*        SETMODE 24                     BACK TO 24-BIT ADDRESSES
         B     OPEN
PARM     EQU   *
         BCTR  R2,0                     LESS ONE FOR EXECUTE
         EX    R2,MVCDSN1               MOVE NAME TO OUR DATA AREA
OPEN     EQU   *
         USING SHWOUT,R10
         USING SHWASSOC,R9
***********************************************************************
*  USE SHOWCAT FOR STARTERS TO GET CATALOG ACB AND CI FOR DSET        *
***********************************************************************
         LA    R10,AREA                      -> TO RETURN DATA AREA
         SHOWCAT AREA=AREA,NAME=PAGEDSN      ISSUE MACRO TO GET INFO
         BAL   R14,SETPTR                    SET -> TO ASSOC
         MVC   CI(3),SHWACI                  CI OF THE ASSOCIATED ENTRY
         L     R2,SHWACBP                    GET CATALOG ACB POINTER
         ST    R2,ACBA                       AND SAVE IT
         TM    48(R2),X'10'                  IS ACB OPEN?
         BO    SETPL                         YES, SO OK TO GO ON
         TPUT  =C'CATALOG NOT OPEN',16       TELL CALLER
         B     RETURN                        AND EXIT
         SPACE
***********************************************************************
* SET UP CATALOG FIELD PARAMETER LIST                                 *
***********************************************************************
SETPL    EQU   *
         USING CTGFL,R9
         LA    R9,FLD1
         MVI   CTGFLDNO,X'01'                1 ENTRY
         LA    R2,FLDNM1                     A(FIELDNAME)
         MVC   0(08,R2),=C'ENTNAME '         MOVE IN FIELD NAME
         ST    R2,CTGFLDNM                   SAVE IT
         XC    CTGFLCHN(4),CTGFLCHN          ZERO IT OUT
         SPACE
         LA    R9,FLD2
         MVI   CTGFLDNO,X'01'                1 ENTRY
         LA    R2,FLDNM2                     A(FIELDNAME)
         MVC   0(08,R2),=C'DEVTYP  '         MOVE IN FIELD NAME
         ST    R2,CTGFLDNM                   SAVE IT
         XC    CTGFLCHN(4),CTGFLCHN          ZERO IT OUT
         SPACE
         LA    R9,FLD3
         MVI   CTGFLDNO,X'01'                1 ENTRY
         LA    R2,FLDNM3                     A(FIELDNAME)
         MVC   0(08,R2),=C'VOLSER  '         MOVE IN FIELD NAME
         ST    R2,CTGFLDNM                   SAVE IT
         XC    CTGFLCHN(4),CTGFLCHN          ZERO IT OUT
         DROP  R9
         SPACE
***********************************************************************
* SET UP CATALOG PARAMETER LIST                                       *
***********************************************************************
         USING CTGPL,R1
         LA    R1,CATPL            -> CATALOG PARAMETER LIST
         OI    CTGOPTN1,CTGBYPSS
         NI    CTGOPTN1,255-(CTGNAME+CTGCNAME)   CI AND ACB PROVIDED
         XC    CTGOPTN2(1),CTGOPTN2              CLEAR
         OI    CTGOPTN3,CTGLOC+CTGNUM+CTGAM0
         LA    R2,CI               ADDRESS OF CONTROL INTERVAL
         ST    R2,CTGENT           SAVE IT
         LA    R2,ACBA             A(CATALOG ACB)
         ST    R2,CTGCAT           SAVE IT IN PARM LIST
         LA    R2,AREA             -> WORK AREA
         ST    R2,CTGWKA           SAVE IT IN PARM LIST
         MVI   CTGTYPE,C'D'        INDICATE 'DATA' REQD
         MVI   CTGNOFLD,X'03'      NUMBER OF FPLS
         LA    R2,FLD1             POINT TO CTGFIELD
         ST    R2,CTGFIELD         SAVE IT IN PARM LIST
         LA    R2,FLD2             POINT TO CTGFIELD
         ST    R2,CTGFL2           SAVE IT IN PARM LIST
         LA    R2,FLD3             POINT TO CTGFIELD
         ST    R2,CTGFL3           SAVE IT IN PARM LIST
         SPACE
         SVC   26                  ISSUE CATALOG SVC
         LTR   R15,R15             HOW DID WE DO?
         EJECT
         MVC   S99TUKY2+6(44),AREA+4    MOVE PAGEDSN INTO ALLOC LIST
         MVC   S99TUKY4+6(6),AREA+4+44+4  MOVE VOLSER INTO ALLOC LIST
         LA    R4,DTYP            -> TO DEVICE TYPE TABLE
         LA    R1,AREA+4+44       -> TO DEVICE TYPE
TYPLP    EQU   *
         CLC   0(4,R1),0(R4)      FIND MATCHING TYPE IN TABLE
         BE    GOTTYP             GOT IT
         LA    R4,8(R4)           -> NEXT ENTRY IN TABLE
         B     TYPLP              GO AND TEST IT
GOTTYP   EQU   *
         MVC   S99TUKY5+6(4),4(R4)  INDICATE UNIT(XXXX)
         MVI   S99VERB,X'01'      INDICATE ALLOC DSNAME(XXXXXXXX)
         LA    R1,S99RBPTR        ADDR OF PARM LIST FOR DYNALLOC.
         DYNALLOC ,               ALLOCATE DATASET
         LTR   R15,R15            CHECK RETURN CODE, ASSUME OK
         OPEN  PLPA               -> OPEN PLPA PAGE DATASET
         GET   PLPA               GET THE FIRST RECORD
         LR    R9,R11             COPY CVT ADDR
* --------------------------------------------------------------- *
*            USE CVTOSLV3 TO DETERMINE THE SYSTEM LEVEL.          *
*            IT MUST BE Z/OS 1.2 OR HBB7705 OR HIGHER.            *
* --------------------------------------------------------------- *
*                                 X'4F3' OFF THE CVT IS CVTOSLV3.
         TM    X'4F3'(R9),X'10'   IS THIS HBB7705 OR MORE?
         BNO   GOTTIM             NO. USE THE FIRST RECORD.
         GET   PLPA               GET THE SECOND RECORD
GOTTIM   EQU   *
         MVC   TSTAMP(8),32(R1)   MOVE DATA TO OUR DATA AREA
         CLOSE PLPA               CLOSE DATASET
         MVI   S99VERB,X'02'      INDICATE FREE DDNAME(XXXXXXXX)
         LA    R1,S99TUPLF        -> TO FREE TEXT UNITS
         ST    R1,S99TXTPP        AND SAVE IN PARM LIST
         LA    R1,S99RBPTR        ADDR OF PARM LIST FOR DYNALLOC.
         DYNALLOC ,               UNALLOCATE DATASET
         LTR   R15,R15            CHECK RETURN CODE, ASSUME OK
         MVC   TZONE(4),CVTTZ     MOVE TIME ZONE OFFSET INTO OUR LIST
         LA    R1,ARGS            -> TO ARGS FOR TODCN
         L     R15,=V(TODCN)      ADDRESS OF TIMESTAMP CONVERTER
         BALR  R14,R15            AND GO THERE
         MVC   TRET(2),=C'00'
         PACK  DOUBLE+4(4),TRET(7)
         LA    R1,PTRS
         L     R15,=V(JULSUB)
         BALR  R14,R15
         LA    R15,MSGDATA
         MVC   MSGDATA(9),DAYDATE+20 DAY OF WEEK
         LA    R15,MSGDATA+9
BACK1    CLI   0(R15),C' '
         BNE   *+8
         BCT   R15,BACK1
         LA    R15,2(,R15)
         MVC   0(20,R15),DAYDATE   MONTH DAY YEAR
         LA    R15,20(,R15)
BACK2    CLI   0(R15),C' '
         BNE   *+8
         BCT   R15,BACK2
         LA    R15,2(,R15)
         MVI   0(R15),C'('
         MVC   1(2,R15),TRET+2     YY
         MVI   3(R15),C'.'
         MVC   4(3,R15),TRET+4     DDD
         MVI   7(R15),C')'
         LA    R15,9(,R15)
         MVC   0(2,R15),=C'AT'
         LA    R15,3(,R15)         POINT TO WHERE HH.MM WILL GO
         MVC   0(8,R15),TRET+7     MOVE TIME IN
         MVI   2(R15),C':'         MOVE IN A COLON
         MVI   5(R15),C':'         MOVE IN A COLON
*        SETMODE 24
         TPUT  MSG,LMSG            TELL CALLER
*        SETMODE 31
RETURN   EQU   *
         MOREND
SETPTR   DS    0H
         LA    R9,SHWASS           -> ASSOC PTRS
         CLI   SHWTYPE,C'D'        DATA TYPE?
         BER   R14                 YES, RETURN
         CLI   SHWTYPE,C'I'        INDEX TYPE?
         BER   R14                 RETURN
         LA    R9,SHWASS0          -> TO ASSOC PTRS
         BR    R14                 RETURN
         EJECT
MSG      DC    C'LAST CLPA WAS ON '
MSGDATA  DC    CL60' '
LMSG     EQU   *-MSG
ARGS     DC    A(TZONE)
         DC    A(TSTAMP)
         DC    X'80',AL3(TRET)
TZONE    DC    F'0'
TSTAMP   DC    XL8'FFFFFFFFFFFFFFFF'
TRET     DC    CL24' '             RETURNED IS YYYYDDDHH.MM.SS.MMMMMM
DTYP     EQU   *
         DC    X'3010200F',C'3390'
         DC    X'3010200E',C'3380'
         DC    X'3010200C',C'3375'
         DC    X'3010200B',C'3350'
         DC    X'30102009',C'3330'
         DC    X'3010200D',C'3330'   3330-1
PLPA     DCB   DDNAME=PLPA,DSORG=PS,RECFM=U,BLKSIZE=80,MACRF=GL
S99RBPTR DC    X'80',AL3(S99RB)       SVC 99 REQUEST BLOCK PTR
S99RB    DS    0F
S99RBLN  DC    AL1(20)                LENGTH=20 BYTES
S99VERB  DC    X'01'                  VERB CODE=01 (DSNAME ALLOC)
S99FLAG1 DC    X'1000'                DONT USE EXISTING ALLOC
S99ERROR DC    AL2(0)                 ERROR CODE
S99INFO  DC    AL2(0)                 INFO  CODE
S99TXTPP DC    A(S99TUPLA)            POINTER TO TEXT UNIT POINTERS
S99RSVD1 DC    A(0)                   RESERVED
S99FLAG2 DC    A(0)                   FLAGS 2
S99TUPLA DC    A(S99TUKY1)            TEXT UNIT POINTERS
         DC    A(S99TUKY2)
         DC    A(S99TUKY3)
         DC    A(S99TUKY4)
         DC    X'80',AL3(S99TUKY5)    LAST PARM
S99TUPLF DC    X'80',AL3(S99TUKY1)    LAST PARM
S99TUNIT DS    0F
S99TUKY1 DC    X'0001',X'0001',X'0004',C'PLPA'           DDN=PLPA
S99TUKY2 DC    X'0002',X'0001',X'002C',CL44'*    '       DSNAME
S99TUKY3 DC    X'0004',X'0001',X'0001',X'08'             SHR
S99TUKY4 DC    X'0010',X'0001',X'0006',CL6'VOLSER'       VOLSER
S99TUKY5 DC    X'0015',X'0001',X'0004',CL4'3390'         DEVTYP
         DS    0D
S99LENG  EQU   *-S99RBPTR                 LENGTH
* WORK AREAS FOR JULSUB ROUTINE FOR DAY DATE CONVERSION
DOUBLE   DS    D
INPARM   DC    F'3'
DAYDATE  DC    CL48' '
OUTPARM  DC    AL4(16+128)
WORK     DS    32D
PTRS     DC    AL4(DOUBLE+4)
         DC    AL4(INPARM)
         DC    AL4(DAYDATE)
         DC    AL4(OUTPARM)
         DC    X'80',AL3(WORK)
* WORK AREAS ETC FOR DSN LOOKUP
MVCDSN1  MVC   PAGEDSN(*-*),0(R1)       EXECUTED MOVE
PAGEDSN  DC    CL44' '
ACBA     DC    F'0'
CI       DC    CL3' '
FLDNM1   DC    CL8' '
FLDNM2   DC    CL8' '
FLDNM3   DC    CL8' '
AREA     DC    H'512'               WORK AREA FOR
         DC    510C' '              SHOWCAT AND SUBSEQUENTLY
         DC    2C' '                USED BY OTHER PARTS OF PGM
         SPACE
         DS    0F
CATPL    DC    (LCTGPL)X'00'
CTGFL2   DC    F'0'
CTGFL3   DC    F'0'
FLD1     DC    (LCTGFL)X'00'
FLD2     DC    (LCTGFL)X'00'
FLD3     DC    (LCTGFL)X'00'
         EJECT
         IEZCTGPL
         SPACE 5
         IEZCTGFL
         SPACE 5
         IGGSHWPL
         SPACE 5
         CVT   DSECT=YES
         END
./ ADD NAME=LASTXCF  0100-03311-03311-1200-00173-00173-00000-FILE066 00
         TITLE '*** LASTXCF ***'
LASTXCF  MOWSTART
LASTXCF  AMODE   31
LASTXCF  RMODE   24
***********************************************************************
* THIS PROGRAM IS USED TO DETERMINE THE DATE AND TIME OF THE SYSPLEX  *
* START. CHECKS THE TIMESTAMP IN THE XCF DATASET.                     *
* GOES IN SYS2.LINKLIB.                                               *
***********************************************************************
         USING CVTMAP,R11
         L     R11,16                  A(CVT)
         USING ECVT,R10
         L     R10,CVTECVT             A(ECVT)
         MVC   MSG+5(8),ECVTSPLX       MOVE SYSPLEX NAME TO MSG AREA
         MVC   S99TUKY2+6(14),=C'SYS1.?PLX.XCFP'    SETUP XCF DSNAME
         MVC   S99TUKY2+11(4),ECVTSPLX     PLUG IN PLEX NAME
         DROP  R10
         USING IHADCB,R5
         USING IOBSTDRD,R4
         L     R0,=F'1024'             LENGTH OF AREA FOR DATA
         STCM  R0,B'0011',XCFDATA+6    SAVE IT IN CCW
         GETMAIN R,LV=(0)              GET THE AREA
         ST    R1,XCFDATA              SAVE IT'S ADDRESS IN THE CCW
         LR    R10,R1                  COPY ADDRESS OF AREA
*
         MVI   S99VERB,X'01'           INDICATE ALLOC DSNAME(XXXXXXXX)
         LA    R1,S99RBPTR             ADDR OF PARM LIST FOR DYNALLOC.
         DYNALLOC ,                    ALLOCATE DATASET
         LTR   R15,R15                 CHECK RETURN CODE, ASSUME OK
         LA    R1,XCFDCB               POINT TO THE DCB
         OPEN  MF=(E,(1))              OPEN THE DATASET
         LA    R4,IOBE
         LA    R1,ECBE
         MVI   IOBFLAG1,IOBCMDCH+IOBUNREL+IOBSPSVC
         STCM  R1,B'0111',IOBECBPB
         LA    R5,DCBE
         STCM  R5,B'0111',IOBDCBPB
         ICM   R5,B'0111',DCBDEBA
         USING DEBBASIC,R5
         LA    R1,DEBBASND
         USING DEBDASD,R1
         MVC   IOBCC(4),DEBSTRCC      START CYL/HD OF DATASET CCCCHHHH
*        MVC   IOBHH(2),DEBSTRHH      HEAD NUMBER             HHHH
         MVI   IOBR,X'01'             RECORD NUMBER           RR
         LA    R0,HDRECDCW
         ST    R0,IOBSTART
         LA    R0,IOBCC
         STCM  R0,B'0111',HDRECDCW+9
         DROP  R1,R4,R5
         L     R15,RDHEAD              GO READ A RECORD
         BALR  R14,R15
* DONE READ
*        MVC   TSTAMP(8),12(R10)  MOVE TIMESTAMP (LAST TO JOIN TIME)
         MVC   TSTAMP(8),28(R10)  MOVE TIMESTAMP (SYSPLEX START TIME)
         LA    R1,XCFDCB          POINT TO THE DCB
         CLOSE MF=(E,(1))         CLOSE THE DATASET
         MVI   S99VERB,X'02'      INDICATE FREE DDNAME(XXXXXXXX)
         LA    R1,S99TUPLF        -> TO FREE TEXT UNITS
         ST    R1,S99TXTPP        AND SAVE IN PARM LIST
         LA    R1,S99RBPTR        ADDR OF PARM LIST FOR DYNALLOC.
         DYNALLOC ,               UNALLOCATE DATASET
         LTR   R15,R15            CHECK RETURN CODE, ASSUME OK
         MVC   TZONE(4),CVTTZ     MOVE TIME ZONE OFFSET INTO OUR LIST
         LA    R1,ARGS            -> TO ARGS FOR TODCN
         L     R15,=V(TODCN)      ADDRESS OF TIMESTAMP CONVERTER
         BALR  R14,R15            AND GO THERE
         MVC   TRET(2),=C'00'
         PACK  DOUBLE+4(4),TRET(7)
         LA    R1,PTRS
         L     R15,=V(JULSUB)
         BALR  R14,R15
         LA    R15,MSGDATA
         MVC   MSGDATA(9),DAYDATE+20 DAY OF WEEK
         LA    R15,MSGDATA+9
BACK1    CLI   0(R15),C' '
         BNE   *+8
         BCT   R15,BACK1
         LA    R15,2(,R15)
         MVC   0(20,R15),DAYDATE   MONTH DAY YEAR
         LA    R15,20(,R15)
BACK2    CLI   0(R15),C' '
         BNE   *+8
         BCT   R15,BACK2
         LA    R15,2(,R15)
         MVI   0(R15),C'('
         MVC   1(2,R15),TRET+2     YY
         MVI   3(R15),C'.'
         MVC   4(3,R15),TRET+4     DDD
         MVI   7(R15),C')'
         LA    R15,9(,R15)
         MVC   0(2,R15),=C'AT'
         LA    R15,3(,R15)         POINT TO WHERE HH.MM WILL GO
         MVC   0(8,R15),TRET+7     MOVE TIME IN
         MVI   2(R15),C':'         MOVE IN A COLON
         MVI   5(R15),C':'         MOVE IN A COLON
         SETMODE 24
         TPUT  MSG,LMSG            TELL CALLER
         SETMODE 31
RETURN   EQU   *
         MOREND
HEADREAD EQU   *
         MVI   XCFDATA,X'1E'           READ COUNT KEY & DATA
         XC    ECBE,ECBE               CLEAR ECB
         LA    R1,IOBE                 POINT TO IOB
         SVC   0                       EXCP
         LA    R1,ECBE                 POINT TO ECB
         LA    R0,1
         SVC   1                       WAIT
         CLI   ECBE,X'7F'              I/O COMPLETED?
*        BER   R14                     YES
         BR    R14                     RETURN
         EJECT
MSG      DC    C'LAST SYSPLEX? START WAS ON '
MSGDATA  DC    CL60' '
LMSG     EQU   *-MSG
ARGS     DC    A(TZONE)
         DC    A(TSTAMP)
         DC    X'80',AL3(TRET)
TZONE    DC    F'0'
TSTAMP   DC    XL8'FFFFFFFFFFFFFFFF'
TRET     DC    CL24' '             RETURNED IS YYYYDDDHH.MM.SS.MMMMMM
XCFDS    DCB   DDNAME=XCFDS,DSORG=PS,RECFM=U,BLKSIZE=32760,MACRF=GL
* WORK AREAS FOR JULSUB ROUTINE FOR DAY DATE CONVERSION
DOUBLE   DS    D
INPARM   DC    F'3'
DAYDATE  DC    CL48' '
OUTPARM  DC    AL4(16+128)
WORK     DS    32D
PTRS     DC    AL4(DOUBLE+4)
         DC    AL4(INPARM)
         DC    AL4(DAYDATE)
         DC    AL4(OUTPARM)
         DC    X'80',AL3(WORK)
RDHEAD   DC    A(HEADREAD)
XCFDCB   DC    X'80',AL3(DCBE)
DCBE     DCB   DDNAME=XCFDS,DSORG=DA,DEVD=DA,MACRF=E
HDRECDCW CCW   X'23',*+15,64,1
         CCW   X'31',0,64,5
         CCW   X'08',*-8,00,0
XCFDATA  DC    XL6'00',AL2(00)
ECBE     DC    F'0'
IOBE     DC    XL40'00'
*
S99RBPTR DC    X'80',AL3(S99RB)       SVC 99 REQUEST BLOCK PTR
S99RB    DS    0F
S99RBLN  DC    AL1(20)                LENGTH=20 BYTES
S99VERB  DC    X'01'                  VERB CODE=01 (DSNAME ALLOC)
S99FLAG1 DC    X'1000'                DONT USE EXISTING ALLOC
S99ERROR DC    AL2(0)                 ERROR CODE
S99INFO  DC    AL2(0)                 INFO  CODE
S99TXTPP DC    A(S99TUPLA)            POINTER TO TEXT UNIT POINTERS
S99RSVD1 DC    A(0)                   RESERVED
S99FLAG2 DC    A(0)                   FLAGS 2
S99TUPLA DC    A(S99TUKY1)            TEXT UNIT POINTERS
         DC    A(S99TUKY2)
         DC    X'80',AL3(S99TUKY3)    LAST PARM (ALLOC)
S99TUPLF DC    X'80',AL3(S99TUKY1)    LAST PARM (FREE)
S99TUNIT DS    0F
S99TUKY1 DC    X'0001',X'0001',X'0005',C'XCFDS'          DDN=XCFDS
S99TUKY2 DC    X'0002',X'0001',X'002C',CL44'*    '       DSNAME
S99TUKY3 DC    X'0004',X'0001',X'0001',X'08'             SHR
         DS    0D
S99LENG  EQU   *-S99RBPTR                 LENGTH
         DS    0F
         PRINT NOGEN
         CVT   DSECT=YES
         IHAECVT
         DCBD  DEVD=DA,DSORG=XA
         IEZIOB
         IEZDEB LIST=YES
TIOT     DSECT
         IEFTIOT1
         END
./ ADD NAME=LELVL    0128-98091-07094-1528-00083-00014-00077-TCACF0  00
         TITLE '*** LELVL ***'
***********************************************************************
* PROGRAM REPORTS ON THE CURRENT LE LEVEL AND PLATFORM.               *
* DOC IS LE PROGRAM REF.                                              *
***********************************************************************
LELVL    CEEENTRY PPA=MAINPPA,BASE=11,AUTO=WORKSIZE,MAIN=YES,          *
               EXECOPS=YES,PARMREG=1
         USING CEECAA,R12
         USING WORKAREA,R13
         CALL  CEEGPID,(CEE_VER_ID,PLAT_ID,0),VL
         UNPK  MSGT+12(7),CEE_VER_ID+1         JUST UNPACK THE DATA
         NC    MSGT+12(7),=6X'0F'              MAKE IT BINARY
         TR    MSGT+12(7),=C'0123456789ABCDEF' CONVERT TO CHARACTER
         MVI   MSGT+18,C','
         L     R1,PLAT_ID
         CVD   R1,DOUBLE                       MAKE IT DECIMAL
         MVC   MSGT+31(2),=X'4021'
         ED    MSGT+31(02),DOUBLE+7            EDIT NUMBER INTO IT
         MVI   MSGT+34,C'='
         BCTR  R1,0
         SLL   R1,3                            MULTIPLY BY 8
         LA    R2,PLAT_NAM                     POINT TO NAMES TABLE
         AR    R2,R1                           POINT TO OUR NAME
         MVC   MSGT+36(8),0(R2)                MOVE NAME INTO MESSAGE
         CALL  CEEMOUT,(MSG,DEST,0),VL         DISPLAY RESULTS
         MVI   MSGT,X'40'                      CLEAR MESSAGE LINE
         MVC   MSGT+1(L'MSGT-1),MSGT
* PROCESS DATA FROM CEECAA
         MVC   MSGT(08),=C'OS = MVS'
         CLI   CEECAASYSTM,CEECAASYMVS         IS THIS MVS?
         BE    GETHW                           YES
         MVC   MSGT(08),=C'OS =  VM'           ONLY OTHER POSSIBILITY
GETHW    EQU   *
         MVC   MSGT+10(16),=C'H/W = 370 NON-XA'
         CLI   CEECAAHRDWR,CEECAAHW370
         BE    GETSUBS
         MVC   MSGT+10(16),=C'H/W = 370 XA    '
         CLI   CEECAAHRDWR,CEECAAHWXA
         BE    GETSUBS
         MVC   MSGT+10(16),=C'H/W = 370 ESA   '
         CLI   CEECAAHRDWR,CEECAAHWESA
         BE    GETSUBS
GETSUBS  EQU   *
         MVC   MSGT+28(14),=C'SUBSYS =   TSO'
         CLI   CEECAASBSYS,CEECAASSTSO
         BE    PUTCAA
         MVC   MSGT+28(14),=C'SUBSYS =  CICS'
         CLI   CEECAASBSYS,CEECAASSCIC
         BE    PUTCAA
         MVC   MSGT+28(14),=C'SUBSYS = BATCH'
         CLI   CEECAASBSYS,CEECAASSNON
         BE    PUTCAA
PUTCAA   EQU   *
         CALL  CEEMOUT,(MSG,DEST,0),VL        DISPLAY RESULTS
         MVI   MSGT,X'40'                     CLEAR MESSAGE LINE
         MVC   MSGT+1(L'MSGT-1),MSGT
         CALL  CEEMOUT,(MSG,DEST,0),VL        PUT OUT A BLANK LINE
FIN      EQU   *
         CEETERM RC=0,MODIFIER=0
DOUBLE   DC    D'0'
DEST     DC    F'2'
MSG      DC    Y(MSGLEN)
MSGT     DC    CL80'LE LEVEL IS VVRRMM, PLATFORM IS X'
MSGLEN   EQU   *-MSGT
CEE_VER_ID DC  F'999'           LE VERSION PPVVRRMM FORM
PLAT_ID  DC    F'1'             3 = Z/OS, 4 = AS/400, 5 = VSE
PLAT_NAM DC    CL8'???   '      1
         DC    CL8'OS/2  '      2   SEE EXAMPLES IN LE PGM REF.
         DC    CL8'Z/OS  '      3
         DC    CL8'AS/400'      4
         DC    CL8'VSE   '      5
         REQU
MAINPPA  CEEPPA
WORKAREA DSECT
         ORG   *+CEEDSASZ
         DS    0D
WORKSIZE EQU   *-WORKAREA
         CEEDSA
         CEECAA
         END
CEEUOPT  CSECT
         CEEXOPT RPTOPTS=(ON)
         END
./ ADD NAME=LNKLST   0100-03311-03311-1200-00094-00094-00000-FILE066 00
         TITLE '*** DISPLAY LINKLIST LIBRARY NAMES ***'
LNKLST   MOWSTART
LNKLST   AMODE 31
LNKLST   RMODE 24
***********************************************************************
* PROGRAM LISTS NAMES OF LINKLIST LIBRARIES                           *
* GOES IN SYS2.LINKLIB, AC=1. PUT ENTRY IN IKJTSO00                   *
*                                                                     *
* LOOK INTO REDOING USING CSVDYNL REQUEST=LIST                        *
***********************************************************************
         L     R2,16                   A(CVT)
         USING CVT,R2
         L     R3,CVTECVT              A(ECVT)
         USING ECVT,R3
         L     R10,ECVTDLCB
         USING CSVDLCB$,R10
         L     R4,DLCBLLT              A(LINKLIB LIST)
         USING LLT,R4
         MVC   LINE+07(8),DLCBLNAM
         L     R9,LLTCOUNT             NUMBER OF ENTRIES IN LIST
         CVD   R9,DOUBLE               MAKE IT DECIMAL
         MVC   LINE+24(04),=X'40202120'
         ED    LINE+24(04),DOUBLE+6    EDIT NUMBER INTO IT
         TPUT  LINE,L'LINE             SHOW RESULT
         SR    R8,R8                   CLEAR FOR EXT COUNTER
         SR    R6,R6                   CLEAR
         LA    R7,LLTDSNL              GET LENGTH OF DSN ENTRY PART
         MR    R6,R9                   FIND OFFSET TO APF PLACE
         LA    R7,8(R4,R7)             POINT TO APF ENTRIES
         USING LLTANTRY,R7             TELL ASSEMBLER
         LA    R4,LLTENTRY             PAST FUNNY HEADING GARBAGE
         USING LLTENTRY,R4
         SR    R5,R5                   CLEAR IT OUT
NEXTNAME EQU   *
         IC    R5,LLTDSLTH             GET LENGTH OF NAME
         MVC   LINE+7(44),LLTDSN       COPY NAME TO OUTPUT AREA
         LOCATE LOCLIST                GET VOLSER
         XC    UWORK,UWORK             CLEAR WORK AREA
         MODESET MODE=SUP
UCBLOOP  EQU   *
         UCBSCAN ADDRESS,WORKAREA=UWORK,UCBPTR=UCBPTR,NOPIN,           *
               DYNAMIC=YES,RANGE=ALL,DEVCLASS=DASD,LOC=ANY
         LTR   R15,R15                 SUCCESSFUL?
         BNZ   FIN                     END OF UCBS
         L     R11,UCBPTR              GET UCB ADDRESS
         USING UCBOB,R11
         CLC   UCBVOLI,VOLSER          IS THIS OUR VOLUME'S UCB?
         BNE   UCBLOOP                 CONTINUE SEARCHING UCB TABLE
UCBFND   EQU   *
         MODESET MODE=PROB
         XC    BUFLIST(BFLHLN+BFLELN),BUFLIST ZERO BUFFER LIST
         OI    BFLHFL,BFLHDSCB         DSCBS TO BE READ WITH
         MVI   BFLHNOE,1               ONE BUFFER LIST ENTRY
         LA    R6,DS1FMTID             ADDRESS OF DSCB BUFFER
         ST    R6,BFLEBUF              STORE IN BUFFER LIST
         MVI   BFLELTH,DSCBLTH         DATA PORTION OF DSCB READ
         LA    R10,LLTDSN              A(DSNAME)
         CVAFDIR ACCESS=READ,DSN=(R10),UCB=(R11),BUFLIST=BUFLIST
         USING DS1FMTID,R6             POINT TO F1 DSCB
         SR    R1,R1                   CLEAR
         IC    R1,DS1NOEPV             GET # EXTS
         AR    R8,R1                   ADD TO TOTAL
         MVC   LINE(6),VOLSER          PUT VOLSER IN LINE
         TPUT  LINE,L'LINE             DISPLAY NAME OF LIBRARY
         LA    R4,LLTDSNL(R4)          POINT TO NEXT NAME
         BCT   R9,NEXTNAME             GET NEXT NAME
         MVC   LINE(80),=CL80'LINKLST HAS???? EXTENTS'
         CVD   R8,DOUBLE               MAKE IT DECIMAL
         MVC   LINE+11(04),=X'40202120'
         ED    LINE+11(04),DOUBLE+6    EDIT NUMBER INTO IT
         TPUT  LINE,L'LINE             SHOW RESULT
FIN      EQU   *
         MOREND
DOUBLE   DC    D'0'                    WORK SPACE
LINE     DC    CL80'LNKLST XXXXXXXX CONTAINS???? LIBRARIES'
CATBLOCK DC    265C' '
VOLSER   EQU   CATBLOCK+6
BUFLIST  ICVAFBFL DSECT=NO
*  UCB LOOKUP WORK AREA AND PARM LIST VARIABLES
FLAG     DC    X'00'
UCBPTR   DC    F'0'              PTR TO UCB
UWORK    DS    XL100             WORK AREA, MUST BE ZEROED
         SPACE 1
         IECSDSL1 (1)
DSCBLTH  EQU   *-IECSDSL1-L'DS1DSNAM
LOCLIST  CAMLST NAME,LINE+7,,CATBLOCK
         CSVDLCB$
         PRINT NOGEN
         IHALLT
         CVT   DSECT=YES
         IHAECVT
CVPL     ICVAFPL
         IEFUCBOB LIST=NO
         END
./ ADD NAME=LPARCAP  0125-04063-11217-1404-00241-00045-00203-TCACF0  00
         TITLE '*** LPARCAP ***'
LPARCAP  MOWSTART
LPARCAP  AMODE 31
LPARCAP  RMODE 24
***********************************************************************
* GET CAPACITY (ILM) INFO FROM LPAR                                   *
* GOES IN SYS2.LINKLIB, AC(1)                                         *
***********************************************************************
MOWWORK  DSECT
DOUBLE   DC    D'0'
CECMSUS  DC    F'0'                    CEC MSUS
NUMCPS   DC    F'0'                    NUMBER OS CPS (NOT ICF/IFLS)
SUMWTS   DC    F'0'                    SUM OF OS LPAR WEIGHTS
RETCODE  DC    F'0'                    RETURN CODE
QVSDATA  DC    CL256' '
QVSDATAL EQU   (*-QVSDATA)
LPARTAB  DC    16CL16' '               ROOM FOR 16 LPARS
*         ORG   LPARTAB
*LPARNAM  DC    CL8' '                  LPAR NAME
*LPARWT   DC    F'0'                    LPAR WEIGHT
*LPARCP   DC    F'0'                    LPAR NUM CPUS
LPARCAP  CSECT
         LA    R11,QVSDATA             -> TO DATA AREA
         USING QVS,R11                 TELL ASSEMBLER
         LA    R1,QVSDATAL             GET LENGTH OF DATA AREA
         ST    R1,QVSLEN               SAVE IT
         LR    R1,R11                  COPY ADDRESS FOR PARM POINTER
         SYSEVENT QVS
         MVC   MSG+00(04),QVSCECMACHINETYPE            MACHINE TYPE
         MVC   MSG+05(16),QVSCECMODELID                MODEL
         MVC   MSG+22(16),QVSCECSEQUENCECODE           SERIAL #
*        MVC   MSG+40(16),QVSCECMANUFACTURERNAME
*        MVC   MSG+45(04),QVSCECPLANTOFMANUFACTURE
         ICM   R1,B'1111',QVSCECCAPACITY               MACHINE MSUS
         ST    R1,CECMSUS                              SAVE IT
         CVD   R1,DOUBLE
         MVC   MSG+38(07),=X'4020206B202120'
         ED    MSG+38(07),DOUBLE+5  EDIT NUMBER INTO IT
         MVC   MSG+46(08),QVSIMGLOGICALPARTITIONNAME   LPAR NAME
*        MVC   MSG+60(16),QVSIMGLOGICALPARTITIONID
         ICM   R1,B'1111',QVSIMGCAPACITY               LPAR MSUS
         CVD   R1,DOUBLE
         MVC   MSG+54(07),=X'4020206B202120'
         ED    MSG+54(07),DOUBLE+5  EDIT NUMBER INTO IT
*        MVC   MSG+00(08),QVSVMNAME
*        MVC   MSG+00(16),QVSVMCAPACITY
         OPEN  (SYSPRINT,(OUTPUT))
         PUT   SYSPRINT,MSG0
*        TPUT  MSG0,L'MSG0
*        TPUT  MSG,L'MSG
* OBTAIN 1 PAGE AND FIX IT (FOR THE PRSM BUFFER)
         MODESET  MODE=SUP,KEY=ZERO
         GETMAIN  RU,LV=4096,BNDRY=PAGE     GETMAIN 1 PAGE
         LR    R8,R1                  KEEP ADDRESS OF PAGE
         L     R7,=F'4096'
         AR    R7,R8                  END ADDRESS
         PGFIX R,A=(R8),ECB=0,EA=(R7) FIX THE PAGE FOR DIAGNOSE
         ST    R15,RETCODE
         MODESET MODE=PROB,KEY=NZERO
         L     R1,RETCODE             TEST RC FROM FIX
         LTR   R1,R1
         BZ    FIX0
         TPUT  =C'** BAD RETURN CODE AFTER PGFIX **',33
         B     END0
* ISSUE DIAGNOSE INSTRUCTION TO GET PRSM DATA
FIX0     DS    0H
         MODESET MODE=SUP,KEY=ZERO
         LRA   R1,0(R8,0)                  LOAD REAL ADDRESS
         LA    R0,4
         DC    X'83',X'10',X'0204'         DIAGNOSE CODE 0204
         LTR   R0,R0
         BNZ   FIN
         MODESET MODE=PROB,KEY=NZERO
         LR    R5,R8
         USING DDBL1,R5
         LH    R2,DDBNUMPP                 NUMBER OF PHYSICAL PROCS.
         ST    R2,NUMCPS                   SAVE IT TO ADJUST LATER
         SR    R2,R2                       CLEAR REG
         IC    R2,DDBNUMCP                 NUM LPARS - LOOP COUNTER
         LA    R2,1(,R2)                   ADD 1 FOR THE 'PHYSICAL'
         LA    R7,LPARTAB                  POINT TO LPAR TABLE
         LR    R4,R5
         AH    R4,DDBORGPN                 POINTING TO 1ST LPAR
         USING DDBPPDTA,R4
         XC    SUMWTS(4),SUMWTS            ZERO SUM OF WEIGHTS
PARTLOOP EQU   *
         MVC   0(8,R7),DDBPRNAM            GET LPAR NAME
         SR    R3,R3
         IC    R3,DDBNMVP                  GET NUMBER OF PROCESSORS
         ST    R3,08(,R7)                  SAVE LPARCP
         LH    R1,DDBPRELS                 WEIGHT OF THIS PROCESSOR
         ST    R1,12(,R7)                  SAVE IT TOO
         MVC   08(1,R7),DDBPUSE            SAVE PROCESSOR USE FLAG
         TM    DDBPUSE,DDBPICF             IS PROCESSOR AN ICF/IFL?
         BO    CPLP                        YES - SO DON'T COUNT IT
         A     R1,SUMWTS                   ADD THIS LPAR WT TO TOTAL
         ST    R1,SUMWTS                   AND SAVE NEW TOTAL.
CPLP     EQU   *
         C     R2,=F'1'                    LAST ENTRY - PP ENTRY?
         BNE   CPLP1
         TM    DDBPUSE,DDBPICF             ICF/IFL?
         BZ    CPLP1
         L     R1,NUMCPS                   GET NUMBER OF CPS
         BCTR  R1,0                        SUBTRACT ONE
         ST    R1,NUMCPS                   SAVE IT
CPLP1    EQU   *
         LA    R4,PRPRLENG(,R4)            BUMP OVER CP SECTION
         BCT   R3,CPLP
         LA    R7,16(,R7)                  NEXT SLOT
         LA    R4,PRPALENG(,R4)
         BCT   R2,PARTLOOP                 NEXT PARTITION
END0     DS    0H                          POINT TO NEXT ENTRY
* FREE THE ALLOCATED PAGE
         MODESET  MODE=SUP,KEY=ZERO
         L     R7,=F'4096'
         AR    R7,R8                       END ADDRESS
         PGFREE R,A=(R8),ECB=0,EA=(R7)     UNFIX PAGE IN MEMORY
         FREEMAIN RC,LV=4096,A=(8)
         MODESET  MODE=PROB,KEY=NZERO
***********************************************************************
* NOW PROCESS THE LPAR TABLE                                          *
***********************************************************************
*                                                                     *
* Item RTA000174591                                                   *
*                                                                     *
*  MVS PARTITION NAME                    SYSW                         *
*  IMAGE CAPACITY                         127                         *
*  NUMBER OF CONFIGURED PARTITIONS          7                         *
*  NUMBER OF PHYSICAL PROCESSORS           11                         *
*                     CP                    9                         *
*                     ICF                   2                         *
*  WAIT COMPLETION                         NO                         *
*  DISPATCH INTERVAL                  DYNAMIC                         *
*                                                                     *
*  --------- PARTITION DATA -----------------  -- LOGICAL             *
*                     ----MSU----  -CAPPING--  PROCESSOR-             *
*  NAME       S   WGT  DEF    ACT  DEF   WLM%  NUM   TYPE             *
*  SYSJ       A   506    0    147  NO     0.0    9   CP               *
*  SYSD       A    14    0      0  NO     0.0    1   CP               *
*  SYSL       A    11    0      0  NO     0.0    1   CP               *
*  CMCC       A    47    0      3  NO     0.0    2   CP               *
*  SYSW       A   421    0    130  YES    0.0    4   CP               *
*  *PHYSICAL*                                                         *
*                                                                     *
* For LPs with processor resource capping, PR/SM LPAR enforces the    *
* processing weights to within 3.6% of the LP's physical CP share for *
* logical CPs entitled to 1/10 or more of one physical CP. Typically, *
* PR/SM LPAR will manage processing weights to within 1% of the LP's  *
* physical CP share.                                                  *
*                                                                     *
* So for your system the calculations work as follows:                *
*                                                                     *
* Weight per LCP is 421/4 LCPs = 105.25.                              *
* The capacity of a Physical CP (PCP) is 999/9=111.                   *
* The LCP share per PCP is 95%.                                       *
* So the 3.6% share for this LPAR is 3.8 (.036*105.25)                *
* This gives a resulting weight range of 101.2 <-> 108.8              *
* And a resulting utilization range of 40.5% <-> 43.6% (calculated as *
* (101.2*4)/999=.405 and (108.8*4)/999=.436                           *
* With the 1C9 rated at 302 MSU this says the range of expected       *
* capacity is 122 MSUs<->132 MSUs. (.405*302=122, and .436*302=132).  *
*                                                                     *
* So the range of Actual capacity which can be seen by this LPAR is   *
* 122 to 132 and so your value of 130 is within the expected range,   *
* though a little higher than the 1%.                                 *
***********************************************************************
         LA    R2,16                       MAX NUMBER OF LPARS
         LA    R7,LPARTAB                  POINT TO LPAR TABLE
LISTLPAR EQU   *
         MVC   MSG+46(08),0(R7)            LPAR NAME
         TM    8(R7),DDBPICF               ICF/IPL?
         BO    NOCALC
         SR    R4,R4                       CLEAR FOR DIVIDE
         L     R5,12(R7)                   LPAR WEIGHT
         D     R4,SUMWTS                   DIVIDE BY TOTAL WEIGHT
         LR    R5,R4
         SR    R4,R4
         M     R4,CECMSUS                  MULTIPLY BY CEC MSUS
         D     R4,=F'10'
         CVD   R5,DOUBLE                   LPAR WEIGHT
         MVC   MSG+54(07),=X'402021204B2020'
         ED    MSG+54(07),DOUBLE+5  EDIT NUMBER INTO IT
NOCALC   EQU   *
         LH    R1,10(R7)                   GET NUM CPS
         CVD   R1,DOUBLE
         MVC   MSG+61(04),=X'40202120'
         ED    MSG+61(04),DOUBLE+6
         L     R1,12(R7)                   GET WEIGHT
         CVD   R1,DOUBLE
         MVC   MSG+65(04),=X'40202120'
         ED    MSG+65(04),DOUBLE+6
         PUT   SYSPRINT,MSG
*        TPUT  MSG,L'MSG
         MVI   MSG,C' '                    CLEAR OUT MESSAGE
         MVC   MSG+1(L'MSG-1),MSG
         LA    R7,16(,R7)                  POINT TO NEXT LPAR ENTRY
         CLC   0(8,R7),=C'PHYSICAL'
         BE    FIN
         BCT   R2,LISTLPAR
FIN      EQU   *
         CLOSE (SYSPRINT)
         MOREND
MSG0     DC    CL80'MACH/----MODEL ID----/---SERIAL #-----/---CEC/--LPA*
               R--/---MSU/-CP/-WT/'
MSG      DC    CL80' '
SYSPRINT DCB   DDNAME=SYSPRINT,MACRF=PM,DSORG=PS
         IRAQVS
* THIS DSECT DESCRIBES THE CONTENTS OF THE PR/SM BUFFER (OCO)
* RETURNED BY THE DIAGNOSE X'204' INSTRUCTION. MAPPED BY ERBDDBL1.
* DOC IS IN RMF DATA AREAS, LY28-1303
DDBL1    DSECT
* HEADER
DDBNUMCP DS    CL1     HOW MANY PARTITIONS
DDBFLAG1 DS    CL1     TIMER INFORMATION BLOCK HEADER FLAGS
DDBGTMSL DS    CL2     TIME SLICE
DDBNUMPP DS    CL2     HOW MANY PHYSICAL PROCESSORS
DDBORGPN DS    H       OFFSET TO ENTRY FOR CURRENT PARTITION
DDBTODCK DS    D       TOD
PRPRFLEN EQU   (*-DDBL1)
* ENTRY FOR PARTITION
DDBPPDTA DS    0F
DDBLPNN  DS    CL1     PARTITION NUMBER
DDBNMVP  DS    CL1     HOW MANY LOGICAL PROCESSORS FOR THIS PARTITION
         DS    CL6     RESERVED
DDBPRNAM DS    CL8     NAME OF THE PARTITION
PRPALENG EQU   (*-DDBPPDTA)
* ENTRY FOR LOGICAL PROCESSOR IN USE BY THE PARTITION
DDBVPDBS DS    0F
DDBVPADR DS    CL2     LOGICAL PROCESSOR NUMBER
         DS    CL2     RESERVED
DDBPUSE  DS    CL1     PROCESSOR USE FLAG
DDBPSTD  EQU   X'00'   STANDARD PROCESSOR
DDBPICF  EQU   X'01'   ICF/IFL PROCESSOR
DDBVPFGS DS    CL1     FLAG (WAIT ASSIST, ETC)
DDBWSTAS EQU   X'80'   WAIT COMPLETION FLAG
DDBCAPFL EQU   X'40'   PARTITION CAPPING FLAG
DDBPRELS DS    H       WEIGHT OF PARTITION
DDBPDTIM DS    D       TIME A LOGICAL PROC. WAS DISPATCHED ON A PHYS.
DDBEFFDT DS    CL8
PRPRLENG EQU   (*-DDBVPDBS)
         CVT   DSECT=YES
./ ADD NAME=MONJOBS  0176-02081-11313-1103-01325-01229-01325-TCACF0  00
         TITLE 'MONJOBS: LOOK FOR CPU LOOPS AND VIRTUAL STORAGE CREEP'
***********************************************************************
*                                                                     *
*   WARNING- THIS CODE USES PROTECT KEY 0 AND SUPERVISOR STATE,       *
*   SO IT CAN DO SERIOUS DAMAGE. REVIEW THE LOGIC AND TEST THIS       *
*   THOROUGHLY BEFORE USING IN A PRODUCTION ENVIRONMENT. THIS CODE    *
*   MAY OR MAY NOT FUNCTION PROPERLY IN EVERY ENVIRONMENT.            *
*                                                                     *
***********************************************************************
* MACRO LIBS NEEDED: SYS1.MACLIB                                      *
*                    SYS1.MODGEN                                      *
*                                                                     *
* LINKAGE EDITOR PARMS: DEFAULT                                       *
*                                                                     *
* GOES IN SYS2.PP.LINKLIB, AC(1)                                      *
*                                                                     *
* PURPOSE:                                                            *
*        MONJOBS SCANS THE ASCB CHAIN LOOKING FOR JOBS THAT ARE       *
*        USING POOR JUDGEMENT IN THEIR USE OF CPU RESOURCE            *
*        THE BASIC FUNCTIONS ARE:                                     *
*        1) IF JOB CLASS = EXPRESS & CPU TIME > 6 SECONDS: CANCEL     *
*        2) MAINTAIN A TABLE OF JOBS AND FIND CPU DELTAS              *
*           A. IF DELTA > 5 MINUTES AND (NO CHANGE IN SHORT WAIT      *
*              OR IO COUNT) THEN ISSUE WTO                            *
*           B. IF NON-SWAPPABLE STC RUN SRB TO GET LDA VALUES         *
*              IF VIRTUAL MEMORY CREEP FOUND, ISSUE WTO               *
*                                                                     *
* CHANGE LOG:                                                         *
*  SUPERVALU, INC 12-2001  ALAN FIELD, ALAN RECKNER                   *
*     ORIGINAL CODE WAS MODIFIED                                      *
*  12-2001 ALAN FIELD -                                               *
*          ADDED PARM TO BE ABLE TO SET WAKE-UP TIME AND DELTA        *
*          VIZ. PARM='WW,DDD' WHERE TIMES ARE IN SECONDS.             *
*          CHANGES LIMIT & LOOPCPU VALUES                             *
*  3-20-02 AR DOCUMENTED THE ORIGINAL CODE, IDENTIFIED SOME           *
*          UNUSED CODE, STARTED TO ADD LOGIC TO USE TRUE DELTA        *
*  CPU TIME RATHER THAN ACCUMULATED CPU FROM START. A CICS REGION     *
*  CAN RUN FINE FOR DAYS AND THEN GO INTO A LOOP.                     *
*  4-2-02 AR- ADD LOGIC TO SRB ROUTINE TO FIND PROGRAM NAME           *
*             ADDED EXCLTBL LIST OF JOBNAMES TO EXCLUDE BECAUSE       *
*             THEY ALWAYS EAT A LOT OF CPU                            *
*   CHANGED RMODE ANY TO RMODE 24 SO DCB STAYS BELOW 16 MEG LINE      *
*  4-15-02 AR- IS DEBUG VERSION, ORIGINAL CODE IS MONJOBSB            *
*             LOOK FOR R13 MISUSE                                     *
*    CHANGE VERSION # AT LINE 25000   #################               *
*  4-30-02 AR- MON142I MESSAGE # FOR STC, FOR AUTO OPS TO USE         *
*  6-17-02 AR- CHANGED LOGIC TO CHECK EXCLTBL FOR JOB, STC, TSO       *
*          AND ADD WLM, GRS, OTHERS TO EXCLTBL THAT SEEM TO HAVE      *
*          BOGUS ALERT MESSAGES FOR EXCESSIVE CPU USAGE               *
*  7-18-02 AR- CHECK CICS REGION FOR EXCESSIVE CPU EVEN IF THERE      *
*          IS SOME I/O. REGION IS OK, BUT THERE IS A BAD TRAN.        *
*  9-15-11 AR-FROM ALAN FIELD. ADD BOISE CICS JOBNAMES                *
* 11-09-11 ACF - MSGIDS TO TCMCT0'S MODS                              *
*                                                                     *
*                                                                     *
* NOTES:                                                              *
*                                                                     *
*                 REGISTER CONVENTIONS =                              *
*                                                                     *
*                    REGISTER  0       = UNUSED                       *
*                    REGISTER  1       = ADDRESS OF INPUT PARAMETERS  *
*                    REGISTER  2       = WORK                         *
*                    REGISTER  3       = TBLENTRY DSECT               *
*                    REGISTER  4       = WORK                         *
*                    REGISTER  5       = ASVT                         *
*                    REGISTER  6       = SRB                          *
*                    REGISTER  7       = CSCB                         *
*                    REGISTER  8       = ASCB                         *
*                    REGISTER  9       = ADDRESS SPACE COUNTER        *
*                    REGISTER  10      = ADDRESS SPACE VECTOR POINTER *
*  AR 4-15-02 NOT    REGISTER  11      = CALCULATION BLOCK            *
*             NOW    REGISTER  11      = WORKAREA
*                    REGISTER  12      = MODULE BASE REGISTER         *
* AR 4-15-02 NOT     REGISTER  13      = WORKAREA                     *
*            NOW     REGISTER  13      = LINKAGE ONLY
*                    REGISTER  14      = WORK                         *
*                    REGISTER  15      = WORK                         *
*                                                                     *
*                PATCH LABEL = N/A                                    *
*                                                                     *
*                ATTRIBUTES =                                         *
*                                                                     *
*             ENTRY POINTS = MONJOBS (ONLY ENTRY POINT)               *
*                                                                     *
*             INPUT =                                                 *
*                                                                     *
*             OUTPUT =                                                *
*                                                                     *
*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *
*                                                                     *
*                RETURN CODE = ZERO                                   *
*                                                                     *
*             EXIT - ERROR = AT PROGRAM END VIA BRANCH REGISTER 14    *
*                                                                     *
*                OUTPUT = NONE                                        *
*                                                                     *
*                RETURN CODE =                                        *
*                                                                     *
*             EXTERNAL REFERENCES =                                   *
*  3-20-02 LOAD EP=MONJOBSS  TO LOAD SRB ROUTINES                     *
*  3-20-02 LINK EP=IRXJCL    EXECUTE SOME REXX CODE TO NOTIFY SOMEBODY*
*                                                                     *
*                                                                     *
*                ROUTINES =                                           *
*                                                                     *
*                DATA AREAS =                                         *
*                                                                     *
*             TABLES = NONE                                           *
*                                                                     *
*             MACROS = SAVE, RETURN                                   *
*                                                                     *
*             MESSAGES = NONE                                         *
*                                                                     *
*             ABEND CODES =                                           *
***********************************************************************
         EJECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5          USE FOR ASVT
R6       EQU   6
R7       EQU   7          USE FOR CHAIN
R8       EQU   8          USE FOR ASCB
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
FPR0     EQU   0
FPR2     EQU   2
FPR4     EQU   4
FPR6     EQU   6
ZERO     EQU   0
ONE      EQU   1
TWO      EQU   2
THREE    EQU   3
FOUR     EQU   4
FIVE     EQU   5
SIX      EQU   6
SEVEN    EQU   7
EIGHT    EQU   8
NINE     EQU   9
TEN      EQU   10
ELEVEN   EQU   11
TWELVE   EQU   12
FOURTEEN EQU   14
FIFTEEN  EQU   15
SIXTEEN  EQU   16
SEVNTEEN EQU   17
EIGHTEEN EQU   18
TWENTY   EQU   20
POSTED   EQU   B'01000000'
MASK0111 EQU   B'00000111'
MASK1000 EQU   B'00001000'
MASK1110 EQU   B'00001110'
ALLBITS  EQU   B'11111111'
MONJOBS  AMODE 31
*ONJOBS  RMODE ANY
MONJOBS  RMODE 24
         EJECT
***********************************************************************
*      MODULE ENTRY POINT                                             *
***********************************************************************
         SPACE 3
MONJOBS  CSECT
         USING MONJOBS,R15         TEMPORARY ADDRESSABILITY
         B     BEGIN               SKIP OVER THE EYECATCHER
         DC    CL8'MONJOBS'
         DC    CL8'&SYSDATE'
         DC    CL8'&SYSTIME'
*
BEGIN    DS    0H
         SAVE  (14,12)             SAVE THE CALLER REGISTERS
         LR    R12,R15             SET UP MODULE BASE REGISTER
         DROP  R15                 FORGET THAT
         USING MONJOBS,R12         MODULE ADDRESSABILITY
         L     R10,ZERO(R1)        GET THE PARAMETER ADDRESS
*  AR 4-15-02 WHY R10 ???
         L     R1,0(,R1)           PARM POINTER
         LH    R2,0(,R1)           GET PARM LENGTH
         LTR   R2,R2               ANY LENGTH
         BZ    NOPARM              NO, SO USE CODED VALUES
         LA    R4,2(R1)            -> TO PARM DATA
         LR    R3,R4               COPY REG
LP1      EQU   *
         CLI   0(R4),C','          LOOK FOR COMMA
         BE    LP2                 FOUND IT
         LA    R4,1(,R4)           NEXT CHAR
         B     LP1                 LOOK AGAIN
LP2      EQU   *
         SR    R4,R3               LENGTH OF NUMBER TO PACK
         BAL   R14,PACKIT          GO CONVERT NUMBER
         MH    R5,=H'100'          CONVERT TO 1/100THS SECOND
         ST    R5,LIMIT      **    GO TO SLEEP FOR THIS VALUE
         LA    R4,2(,R4)           POINT TO START OF NEXT NUMBER
         SR    R2,R4               REMAINING LENGTH OF PARM
         AR    R3,R4               -> START OF NEXT NUMBER
         LR    R4,R2               GET LENGT IN CORRECT REG
         BAL   R14,PACKIT
         MH    R5,=H'100'          CONVERT TO 1/100THS SECOND
         ST    R5,LOOPCPU     **   CPU LOOPING LIMIT
NOPARM   EQU   *
         GETMAIN R,LV=WRKLNGTH,LOC=(BELOW,ANY) GET A SAVE/WORK AREA
         XC    ZERO(256,R1),ZERO(R1) MAKE SURE IT'S BINARY ZEROES
         LR    R11,R1              SAVE WORK AREA ADDRESS
         ST    R13,FOUR(R11)       LINK FORWARD
         ST    R11,EIGHT(R13)      LINK BACKWARD
         LR    R13,R11             ESTABLISH WORK AREA
         USING WORKAREA,R11        FIELD ADDRESSABILITY
*
***********************************************************************
*      BUILD EXCLTBL 4-2-02. LIST OF JOBS THAT ROUTINELY EAT A LOT    *
*            OF CPU, SO DO NOT CREATE AN ALERT FOR THEM.
***********************************************************************
         GETMAIN RC,LV=4096,LOC=ANY FOR EXCLTBL
*
         LTR   R15,R15             MAKE SURE THE GETMAIN WORKED
         BNZ   FAILURE             NOPE, WE BETTER FIND OUT WHY
         ST    R1,WRKEXCT          SAVE EXCLTBL ADDRESS
         LR    R4,R1                POINT TO BEGIN OF TABLE
         ST    R4,WRKEXCTE          END OF TABLE MARKER
         MVC   4085(7,R1),=C'EXCLTBL'    EYECATCHER AT TABLE END
         L     R2,=F'4085'
P10010   MVI   0(R1),C' '          BLANK OUT TABLE
         LA    R1,1(R1)
         BCT   R2,P10010           LOOP UNTIL DONE
*
         OPEN  (SYSIN,INPUT),MODE=31
         LTR   R15,R15             DID IT WORK
         BNZ   FAILURE             NOPE, WE BETTER FIND OUT WHY
*
P10090   GET   SYSIN               USE WRKMSG TO INPUT DATA
**   CANNOT DO THIS KIND OF ERROR CHECKING ON GET/PUT
**       LTR   R15,R15             IS IT OK
**       BNZ   FAILURE             NOPE
*
         MVC   WRKMSGT(80),0(R1)    POINT TO BEGIN OF CARD USING R1
         LA    R2,WRKMSGT           POINT TO BEGIN OF CARD
         LA    R3,0                 MAX 8 BYTE JOBNAME
         CLI   0(R2),C'*'           COMMENT IN COL 1
         BE    P10090               YES IGNORE THE CARD
         ST    R4,WRKTABLE          ADDR OF BEGIN OF THIS ENTRY
P10200   CLI   0(R2),C' '           BLANK IS END OF NAME
         BE    P10250
**    * AND % ARE VALID, BUT NO LOGIC CHECKING IS NEEDED HERE
**       CLI   0(R2),C'*'           WILD CARD
**       BE    P10250               YES
**       CLI   0(R2),C'%'           DO NOT CARE CHARACTER
**       BE    P10250
         MVC   1(1,R4),0(R2)        MOVE TO EXCLTBL ENTRY +1
         LA    R2,1(R2)             BUMP TO NEXT COLUMN
         LA    R4,1(R4)
         LA    R3,1(R3)             LENGTH OF FIELD
         CH    R3,=H'8'             MAX 8 BYTES
         BL    P10200               LOOP UNTIL 8 BYTES ARE DONE
P10250   EQU   *                    FIND LENGTH OF FIELD
         L     R4,WRKTABLE          ADDR OF BEGIN OF THIS ENTRY
         STC   R3,0(0,R4)           STORE LENGTH INTO FIELD
*  9 BYTE ENTRY IS L12345678 WHERE L IS THE LENGTH OF THE JOBNAME
         ST    R4,WRKEXCTE          ADDRESS OF LAST TABLE ENTRY
         LA    R4,9(R4)             BUMP TO NEXT EMPTY ENTRY
         L     R2,WRKEXCT
         LA    R2,4085(R2)          BUMP TO END OF TABLE
         CR    R4,R2
         BL    P10090               ROOM TO ADD MORE ENTRIES
*
P10600   EQU   *                   END OF FILE ON SYSIN
         CLOSE (SYSIN,),MODE=31
         LTR   R15,R15             MAKE SURE THE GETMAIN WORKED
         BNZ   FAILURE             NOPE, WE BETTER FIND OUT WHY
         EJECT
***********************************************************************
*      INITIALIZATION, GET THE PAUSE/MODIFY ECB ADDRESS               *
*
* 4-3-02 KEEP AS MUCH CODE OUTSIDE OF THE SUPERVISOR STATE AS
*        POSSIBLE.
***********************************************************************
         SYSEVENT DONTSWAP         MAKE US NON-SWAPPABLE
*
         MODESET MODE=SUP          AND GET INTO SUPERVISOR STATE
         SPACE
         MVC   WRKCOMM,COMMLPTR    MOVE LIST FORM TO 24 BIT ADDRESS
         EXTRACT WRKCOMMP,MF=(E,WRKCOMM)  GET ADDR OF ECB AND CIB PTRS
*
         MVC   WRKWTO,MESSAGE      COPY WTO PARAMETERS TO WORK AREA
*
         L     R15,CVTPTR          ADDRESS OF THE MVS CVT
         L     R5,CVTASVT-CVT(R15) ADDRESS OF ASVT
         USING ASVT,R5             FIELD ADDRESSABILITY
         L     R0,ASVTMAXU         NUMBER OF ADDRESS SPACES
         MH    R0,TBLSIZE          TIMES TABLE ENTRY FOR TABLE SIZE
         GETMAIN RC,LV=(0),LOC=ANY GET A TABLE TO HOLD COUNTS
*
* AR 3-20-02 TBLENTRY STORES CPU TIME, STATUS OF EACH ASID
*
         LTR   R15,R15             TEST IF WE GOT THE TABLE
         BNZ   FAILURE             NOPE, THEN WE BETTER CRASH AND BURN
*
         ST    R1,WRKTABLE         SAVE ADDRESS OF TABLE FOR LATER
*
         GETMAIN RC,LV=CALLNGTH,LOC=ANY GET THE FIRST CALBLOCK
*
         LTR   R15,R15             MAKE SURE THE GETMAIN WORKED
         BNZ   FAILURE             NOPE, WE BETTER FIND OUT WHY
*
         ST    R1,WRKCALST         PUT IT ON THE QUEUE
** AR    LR    R11,R1              MOVE OVER FOR FIELD ADDRESSABILITY
** AR    USING CALBLOCK,R11        ESTABLISH FIELD ADDRESSABILITY
** AR    MVC   CALASID,=H'1'       INDICATE BLOCK FOR ASID '1'
*
         L     R8,PSAAOLD-PSA      ADDRESS OF CURRENT ASCB
         USING ASCB,R8             FIELD ADDRESSABILITY
         L     R4,ASCBLDA          ADDRESS OF LOCAL DATA AREA
         USING LDA,R4              FIELD ADDRESSABILITY
         L     R1,LDASTRTA         STARTING ADDRESS IN ADDRESS SPACE
         A     R1,LDASIZA          ADD IN SIZE OF ADDRESS SPACE
         ST    R1,WRKASSZ          AND SAVE AS TOP OF ADDRESS SPACE
*
         MODESET KEY=ZERO          GET INTO PROTECT KEY ZERO
*
         GETMAIN RC,LV=SRBLNGTH,SP=245,LOC=ANY GET PAGE FIXED KEY ZERO
*
         LTR   R15,R15             TEST IF WE GOT WHAT WE ASKED FOR
         BNZ   FAILURE             NOPE, THEN WE BETTER CRASH AND BURN
*
         ST    R1,WRKSRB           SAVE FOR LATER REFERENCE
         XC    ZERO(SRBLNGTH,R1),ZERO(R1) CLEAR AREA TO BINARY ZEROES
*
         LOAD  EP=MONJOBSS,GLOBAL=(YES,F) LOAD SRB ROUTINES INTO FIXED
*
         ST    R0,WRKRTN           SAVE FOR LATER REFERENCE
         USING SRB,R6              FIELD ADDRESSABILITY
         L     R6,WRKSRB           ADDRESS OF GOTTEN SRB AREA
         MVC   SRBID,=CL4'SRB'     INITIALIZE THE EYE CATCHER
         MVC   SRBEP,WRKRTN        ADDRESS OF THE SRB ROUTINE
         OI    SRBEP,SRBMODE       INDICATE 31 BIT ADDRESSING
         LA    R1,SRBEND           ADDRESS OF ECB TO POST WHEN DONE
         ST    R1,SRBPARM          PUT THAT INTO PARMS FIELD
         L     R1,SRBEP            ADDRESS OF THE SRB ROUTINE
         LA    R1,FOUR(R1)         SRB + 4 IS THE TERMINATION ROUTINE
         ST    R1,SRBRMTR          ADDRESS OF THE TERMINATION ROUTINE
         OI    SRBRMTR,SRBRMODE    INDICATE 31 BIT ADDRESSING
         L     R8,PSAAOLD-PSA      ADDRESS OF CURRENT ASCB
         USING SRBAREA,R6          ESTABLISH FIELD ADDRESSABILITY
*
* AR 3-20-02 SRB SITS INSIDE OF SRBAREA, IS WHY WE DID NOT
*            RELOAD R6 ABOVE.  NOTE THERE IS A SRBASCB WHICH IS
*            IS NOT TO BE CONFUSED WITH THE BELOW SRA FIELD
*
         ST    R8,SRAASCB          UPDATE THE SRB PARAMETERS
         USING SRB,R6              RE-ESTABLISH FIELD ADDRESSABILITY
*
         MODESET KEY=NZERO         BACK INTO NORMAL PROTECT KEY
*
* AR 4-3-02 CREATE ESTAE SO WE CAN DUMP ALL OF OUR GETMAIN STORAGE
*           IF WE ABEND FOR ANY REASON
         ESTAE  P08010,CT,TERM=YES
         LTR   R15,R15             TEST IF WE GOT WHAT WE ASKED FOR
         BNZ   FAILURE             NOPE, THEN WE BETTER CRASH AND BURN
** ****************************************************
** AR 7-18-02 CHANGE VERSION # BELOW ******************
         WTO   'MON104I MONJOBS V2.8 INITIALIZED'
         EJECT
***********************************************************************
*      OUTER LOOP, SET UP THE ASCB SCAN                               *
***********************************************************************
         SPACE
ASVTLOOP DS    0H
         L     R9,ASVTMAXU         NUMBER OF ADDRESS SPACES TO LOOK AT
         MVC   WRKWAIT,LIMIT       SET UP FOR SIX SECOND SLEEP
*
ASCBLOOP DS    0H
         LOCASCB ASID=(9)          LOCATE AN ASCB
*
         LTR   R15,R15             TEST IF ACTIVE ASCB FOUND
         BNZ   ASCBNEXT            NOPE, GO DESCREMENT AND GET NEXT
*
         LR    R8,R1               ADDRESS OF THE ASCB
         USING ASCB,R8             FIELD ADDRESSABILITY
*
         L     R7,ASCBCSCB         ADDRESS OF CSCB FOR THIS MEMORY
         USING CHAIN,R7            FIELD ADDRESSABILITY
* AR 3-20-02 COMMAND SCHEDULING CONTROL BLOCK, UPDATED WHEN
*   CANCEL JOBNAME, MODIFY OR STOP COMMAND IS IN FLIGHT
*
         LTR   R7,R7               TEST IF CSCB EXISTS
         BZ    TESTLOOP            NOPE, GO TEST FOR LOOPING JOB
         B     TEST_JOB_CLASS      YEP, GO TEST FOR CPU LIMITS
         EJECT
***********************************************************************
*      TEST FOR HSMSYKO IN ENQ CHAIN FOR SYSZRAC2 RACF.PRIMARY        *
*  AR 3-20-02 HOW DO WE GET TO THIS ROUTINE? I THINK NOT USED  **     *
***********************************************************************
         SPACE
         GQSCAN AREA=(ENQRET,1000),SCOPE=SYSTEM,                       X
               RESNAME=(SYSZRAC2,RNAME,12),WAITCNT=4
*
         LTR   R15,R15             CHECK OUT THE ANSWER
         BZ    TEST_HSM_ENQ        YEP, WE GOT SOMETHING SO LOOK AT IT
*
         CH    R15,H4              TEST FOR NOTHING FOUND
         BE    TEST_JOB_CLASS      TRUE, GO ON TO THE NEXT TASK
         DC    H'0'                SHOULD NEVER OCCUR
* AR 3-20-02 ABOVE LOOKS LIKE IT CAUSES AN ABEND **
*
TEST_HSM_ENQ DS  0H
         USING RIB,ENQRET          ESTABLISH FIELD ADDRESSABILITY
         LH    R15,RIBVLEN         LENGTH OF THE VARIABLE SECTION
         LA    R10,RIBEND(R15)     ADDRESS OF FIRST RIBE
         USING RIBE,R10            FIELD ADDRESSABILITY
         L     R15,RIBTRIBE        NUMBER OF RIBES RETURNED
*
TEST_HSM_LOOP DS 0H
         CLC   RIBEJBNM,HSMSYKO    TEST IF HSMSYKO INVOLVED
         BE    TEST_HSM_SDUMP      YEP, GO GET A DUMP OF HSM
*
         LA    R10,RIBEEND         ADDRESS OF NEXT RIBE
*
         BCT   R15,TEST_HSM_LOOP   GO LOOK AT NEXT RIBE
*
         B     TEST_JOB_CLASS      ALL RIBES PROCESSED, NEXT TASK
*
TEST_HSM_SDUMP DS 0H
         SDUMP HDR='HSMSYKO',ASID=RIBEASID SVC DUMP OF HSM
*  AR 3-20-02 ******** END OF NOT USED CODE        **********  **     *
         EJECT
***********************************************************************
*      TEST FOR JES3 INITIATOR GROUP 'EXPRESS'                        *
*  AR 3-20-02 WE DO NOT USE, IS IT JES3 ONLY ??    **********  **     *
*  ON JES2 IT COULD BE  STC  OR JOBNAME
***********************************************************************
         SPACE
TEST_JOB_CLASS DS 0H
         CLC   CHKEY,EXPRESS       TEST FOR EXPRESS JOB CLASS
         BNE   TESTLOOP            NOPE, GO TEST FOR LOOPING JOB
* AR 3-20-02 ONLY PLACE CSCB IS USED   ***********
*
         CLC   ASCBJBNI,ZEROES     TEST FOR JOB RUNNING IN INITIATOR
         BE    TESTLOOP            NOPE, GO TEST FOR LOOPING JOB
* AR 3-20-02 JBNI IS POINTER TO JOBNAME, JBNS IS POINTER TO STC NAME
*
         LM    R0,R1,ASCBEJST      PICK UP THE CPU TIME
         SRDL  R0,TWELVE           SHIFT TO MICROSECONDS
         D     R0,TENTHOU          CONVERT TO HUNDREDTHS OF A SECOND
*
         C     R1,LIMIT            TEST IF ITS TOO BIG
         BL    ASCBWT              NOPE, CALCULATE WAIT TIME
         SPACE 2
***********************************************************************
*      RESET CPU TIME LIMIT IN THE ASCB TO FORCE S322 ABEND           *
***********************************************************************
         SPACE 3
         MODESET KEY=ZERO          PROTECT KEY FOR ASCB UPDATE
*
         LA    R1,ONE              SET UP TO CHANGE THE LIMIT
         ST    R1,ASCBJSTL         SET THE LIMIT WAY DOWN (S322 ABEND)
*
         MODESET KEY=NZERO         BACK OFF THE TIGHTROPE
*
         B     ASCBNEXT            DONE WITH THIS ASCB
*
ASCBWT   DS      0H
         L     R15,LIMIT           GET THE LIMIT VALUE
         SR    R15,R1              TIME TO GO TO LIMIT
*
         CL    R15,WRKWAIT         TEST IF SHORTER THAN CURRENT
         BH    TESTLOOP            NOPE, THEN LOOK FOR LOOPS
*
         CL    R15,SECOND          TEST IF TOO SHORT TO WORRY
         BH    WAITSET             NOPE, SET NEW WAIT TIME
*
         L     R15,SECOND          OTHERWISE SET A ONE SECOND LIMIT
*
WAITSET  DS    0H
         ST    R15,WRKWAIT         SET HOW LONG TO SLEEP
         B     ASCBNEXT            SKIP LOOP TEST FOR 'EXPRESS'
*
*      END TEST_JOB_CLASS  LOGIC      ***************                 *
*      THE ABOVE IS NOT USED ANYWHERE ELSE IN THE PROGRAM *****       *
         EJECT
***********************************************************************
*      LOOP CHECKING LOGIC:  IF 5 MINUTES CPU W/ NO IO OR WAITS ..... *
***********************************************************************
         SPACE
TESTLOOP DS    0H
         LM    R0,R1,ASCBEJST      PICK UP THE CPU TIME
* AR 3-20-02 DOCO SAYS ELAPSED JOB STEP TIMING?
         SRDL  R0,TWELVE           SHIFT TO MICROSECONDS
         D     R0,TENTHOU          CONVERT TO HUNDREDTHS OF A SECOND
*
         LH    R3,ASCBASID         GET THE ASID NUMBER
         BCTR  R3,ZERO             DECREMENT BY ONE FOR DISPLACEMENT
         MH    R3,TBLSIZE          CALCULATE ENTRY OFFSET
         AL    R3,WRKTABLE         ADDRESS OF PROPER TABLE ENTRY
         USING TBLENTRY,R3         FIELD ADDRESSABILITY
         SR    R2,R2               INITIALIZE SHORT WAIT COUNT
*
         ST    R1,WRKCPU           SAVE CPU TIME
         CL    R1,TBLCPU           TEST IF CPU HAS DECREASED
         BL    TBLUPDAT            YEP, NEW JOB MUSTA STARTED
*
         CLC   TBLINTS,ASCBINTS    TEST IF NEW START TIME HAS CHANGED
         BL    TBLUPDAT            YEP, NEW JOB MUSTA STARTED
*
         LR    R15,R1              COPY CURRENT CPU TIME VALUE
         SL    R15,TBLCPU          COMPUTE THE DELTA
         ST    R15,DLTCPU          SAVE THE DELTA
*
         CL    R15,LOOPCPU         COMPARE TO LOOP TEST LIMIT
***      BL    ASCBVSM             LOW, GO LOOK AT VIRTUAL PICTURE
         BL    TBLUPDAT            LOW, UPDATE TABLE STATS 4-3-02
*
*  * * **    HERE WE FOUND SOMETHING THAT EXCEEDED THE CPU LIMIT
* AR 7-18-02 IF CICS REGION SKIP THE NEXT TESTS            *****
*  * * **    BUT FIRST WE NEED TO OBTAIN THE JOB/STC NAME  *****
*
***********************************************************************
** AR 4-3-02 ADDED LOGIC TO SEE IF IT IS A JOB, IF SO GO FIND THE
**      PROGRAM NAME. IF IT IS A DB2 STEP, THEN GIVE IT MORE
**      LEEWAY. IF A STC & A CICS REGION MODIFY THE ALERT MSG
*
* DISPLAY THE VALUES SO WE KNOW CALCULATION CORRECT - TCMCT0
*
*        WTO   'HIT THE DISPLAYS'
         MVC   DSPMSGL,=H'35'
         MVC   DSPMSGI,=C'MON122I '
         L     R1,WRKCPU                LOAD SAVED CURR CPU
         CVD   R1,DBLWORD
         UNPK  DSPCPU,DBLWORD
         OI    DSPCPU+15,X'F0'
         MVC   DSPTEXT,=C'CURR CPU: '
         WTO   TEXT=DSPMSG,MF=(E,WRKWTO) MESSAGE ABOUT LOOPING JOB
*
         L     R1,TBLCPU                LOAD SAVED PREV CPU
         CVD   R1,DBLWORD
         UNPK  DSPCPU,DBLWORD
         OI    DSPCPU+15,X'F0'
         MVC   DSPTEXT,=C'PREV CPU: '
         WTO   TEXT=DSPMSG,MF=(E,WRKWTO) MESSAGE ABOUT LOOPING JOB
*
         L     R1,DLTCPU                LOAD SAVED DELTA
         CVD   R1,DBLWORD
         UNPK  DSPCPU,DBLWORD
         OI    DSPCPU+15,X'F0'
         MVC   DSPTEXT,=C'DELTA:    '
         WTO   TEXT=DSPMSG,MF=(E,WRKWTO) MESSAGE ABOUT LOOPING JOB
*
* BLANK OUT OUR WTO AREA, SO WE CAN CUSTOMIZE THE MESSAGE **
*
         MVI   WRKMSGT,C' '         BLANK OUT THE AREA
         MVC   WRKMSGT+1(WRKMLGTH-1),WRKMSGT
         MVC   WRKM32TX,LPGM32TX   MOVE IN DEFAULT MESSAGE TEXT
         MVC   WRKASID,ASCBASID    COPY THE ASID NUMBER
         MVC   WRKM100I,=C'MON132I ' FILL IN THE MESSAGE ID
         MVC   LOOPNAME(8),=C'ASID =  '   NEXT IAZXJSAB DOES NOT
         MVC   LOOPUSID(8),=C'        '     ALWAYS WORK
* AR 4-30-02 WLM, GRS ARE EXAMPLES WHERE IT DOES NOT WORK
         SPACE 2
         IAZXJSAB READ,ASCB=(8),JOBNAME=LOOPNAME,USERID=LOOPUSID,      X
               JOBID=LOOPID
         SPACE 2
         LTR   R15,R15            DID WE FIND A GOOD ONE
         BZ    TESTLB5            YES
         L     R1,ASCBJBNI        FIND JOBNAME ELSEWHERE
         LTR   R1,R1              DID WE FIND A GOOD ONE
         BNZ   TESTLB1            YES
         L     R1,ASCBJBNS        IS IT A STC
         LTR   R1,R1
         BZ    TESTLB5            NO
TESTLB1  L     R14,8(R1)          WORKS FOR MVS SP4 & HIGHER
**       SET MODE 31  FOR THE NEXT MOVE
         MVC   LOOPNAME(8),16(R14)
         SPACE 2
TESTLB5  EQU   *
***********************************************************************
*  * * **    NOW GO BACK TO SEE IF WE SHOULD IGNORE THIS TASK **
         CLC  LOOPNAME(3),=C'ETC'  A CICS REGION
         BE    TESTLB7             YEP, LET'S DO THE ALERT
*  ARR 09-15-11 ADD BOISE CICS REGIONS ********
         CLC  LOOPNAME(3),=C'CIC'  A CICS REGION
         BE    TESTLB7             YEP, LET'S DO THE ALERT
*
         CLC   ASCBIOSC,TBLIOSC    TEST IF IO COUNT HAS CHANGED
         BNE   TBLUPDAT            YEP, JUST UPDATE THE TABLE
*
         ICM   R4,15,ASCBOUXB      ADDRESS OF THE OUXB
         BZ    TBLUPDAT            NOPE, IT DOESN'T EXIST
*
         USING OUXB,R4             FIELD ADDRESSABILITY
         LH    R2,ASCBSWCT         PICK UP THE SHORT WAIT COUNT
         SL    R2,OUXBSWCT         REMOVE THE SWAP COUNT
         STH   R2,WRKSWCT          AND SAVE WAIT COUNT
*
         CH    R2,TBLSWCT          TEST IF THIS VALUE HAS CHANGED
* ACF    BNE   TBLUPDAT            YEP, LIVE AND LET LIVE
* AR  3-20-02 NOT SURE WHY WE WOULD IGNORE THE ABOVE TESTS -
*
         TM    TBLFLAGS,TBLFMSG    TEST IF WE HAVE ALREADY COMMENTED
***      BO    ASCBVSM             YEP, GO LOOK AT VIRTUAL STORAGE
         BO    TBLUPDA2            YEP, UPDATE TABLE STATS 4-3-02
* AR  3-20-02 HERE WE FOUND A LOOPER BUT WE ALREADY HAVE SENT
*             AN ALERT, SO WE SKIP THE TBLUPDAT - WHY ??
*             BECAUSE TBLUPDAT RESETS TBLFLAGS, AND CAUSE US TO
*             RESEND THE ALERT NEXT TIME THRU. SO LET'S CHANGE TO GO
*             TO TBLUPDA2.
*
         SPACE 2
*  * * ** HERE WE HAVE A TASK THAT WE WILL ALERT ON  **********
TESTLB7  EQU   *
         CLC   ASCBJBNI,ZEROES     TEST FOR JOB RUNNING IN INITIATOR
         BE    TESTLOO2            NOPE, GO TEST FOR STC OR TSO
* AR 3-20-02 JBNI IS POINTER TO JOBNAME, JBNS IS POINTER TO STC NAME
*            SOME TASKS HAVE BOTH SET.
*            TEST1EV1 ON SVT2 IS DOMINO STC, IS EXAMPLE, BUT IT DOES
*            NOT HAVE A JOBCARD. THESE ALSO HAVE A SDSF STATUS OF
*            PROTECTED, NOT SURE WHAT THAT IS.
** AR    CLC   ASCBJBNS,ZEROES     SOME STC HAVE JOB CARDS
** AR    BNE   TESTLOO2            YES THIS IS ONE
         SPACE
         ICM   R4,15,ASCBOUCB      ADDRESS OF THE OUCB
         BZ    TESTLOO6            NOPE, NO OUCB (SHOULD NOT HAPPEN)
** AR    TM    OUCBSFL,OUCBNSW     TEST FOR NONSWAPPABLE ADDRESS SPACE
** AR    BZ    TESTLOO6            NOPE, SKIP THE VIRTUAL TEST
*
** AR    CLC   OUCBSUBN,=CL4'STC'  TEST FOR A STARTED TASK
** AR    BNE   TESTLOO6            NOPE, SKIP THE VIRTUAL TEST
*
         MODESET KEY=ZERO          GET INTO PROTECT KEY ZERO
*
         USING SRB,R6              FIELD ADDRESSABILITY TO REAL SRB
         ST    R8,SRBASCB          UPDATE SRB WITH ASCB ADDRESS
         USING SRBAREA,R6          FIELD ADDRESSABILITY TO SRB + FIELDS
         XC    SRBECB,SRBECB       CLEAR THE ECB BEFORE SCHEDULE
*
*  4-15-02 IT IS EASIER TO NOT HAVE SRB SAVE/RESTORE, SO WE
*          WE DO IT HERE INSTEAD    ****
*
         STM   2,12,WRKSAVR       SAVE SOME REGISTERS  4-15-02
*
         SCHEDULE SRB=(6),FRR=NO   SCHEDULE SRB TO COPY LDA DATA
*
         LM    2,12,WRKSAVR       RESTORE ALL REGISTERS  4-15-02
*
         MODESET KEY=NZERO         GET BACK OFF THE TIGHTROPE
*
         TM    SRBECB,X'80'        TEST IF ECB POSTED YET
         BO    TESTLOO1            YEP, WE HAVE DATA TO MOVE
*
         MODESET KEY=ZERO          OTHERWISE SWITCH TO PROTECT KEY ZERO
*
         WAIT  1,ECB=SRBECB        AND WAIT FOR ECB TO COMPLETE
*
         MODESET KEY=NZERO         GET OFF THE TIGHTROPE
*
TESTLOO1 DS    0H
         MVC   WRKBLOCK,SRABLOCK   COPY THE DATA FROM SQA TO WORK AREA
         MVC   WRKINTS,ASCBINTS    AND THE JOB INITIATION TIME
**       L     R1,ASCBJBNS         ADDRESS OF JOBNAME FOR STCS
**       MVC   WRKJOBN,ZERO(R1)    PICK UP JOBNAME FOR POSSIBLE MESSAGE
**  AR 4-2-02 ABOVE INCORRECT FOR MVS SP4 AND ABOVE ***
         MVC   WRKJOBN,LOOPNAME            JOBNAME AR 4-2-02
** AR    ST    R11,WRKCCURR        SAVE ADDRESS OF LAST CALBLOCK
** AR    L     R11,CALNEXT         MOVE UP TO NEXT CALCULATION BLOCK
*
         CLC   ASCBASID,=H'1'      TEST IF WORKING ON *MASTER*
         BE    TESTLOO6            YES
*
         XC    WRKCCURR,WRKCCURR   INDICATE NO PREVIOUS BLOCK
         CLC   WRKASID,ZEROES      TEST FOR THE VERY FIRST ASID
         BE    TESTLOO6            YEP, NO DATA AVAILABLE TO PROCESS
         OC    WRKBLOCK,WRKBLOCK   TEST IF ANY DATA CAME BACK
         BZ    TESTLOO6            NOPE, A.S. WAS TERMINATING
         SPACE
         MVC   WRKMVART(8),WRKPGMN      PUT INTO MSG
         CLC   WRKPGMN(8),=C'IKJEFT01'  IS IT A DB2 JOBSTEP?
         BE    TESTLO1B                 NO
         CLC   WRKPGMN(8),=C'DSNUTILB'  IS IT A DB2 JOBSTEP?
         BNE   TESTLOO6                 NO
TESTLO1B EQU   *
         MVC   WRKM36TX,LPGM36TX   DB2 JOB MAYBE LOOPING
         SPACE
***   BEGIN OF DEBUG 4-15-02       ************
         CLI   WSSNAPS,C'1'           DID WE ALREADY DO A SNAP
         BE    P02XX1
         MVI   WSSNAPS,C'1'          SET SWITCH
         ST    R1,WSR1               SAVE REG
         OPEN  (SNAP2,OUTPUT),MODE=31
** AR    ST    R13,SNAPL1S           ADDRESS OF WORKAREA
         ST    R11,SNAPL1S           ADDRESS OF WORKAREA
         LR    R1,R11
         A     R1,=F'4095'
         ST    R1,SNAPL1E
         NI    SNAPL1S,X'EF'         LEFTMOST BIT S/B ZERO
         OI    SNAPL1E,X'80'         MARK END OF LIST
         SNAP  DCB=SNAP2,LIST=SNAPL,PDATA=(PSW,REGS,SA)
         L     R1,WRKSRB           ADDRESS OF GOTTEN SRB AREA
         ST    R1,SNAPL1S            ADDRESS OF SRBAREA
**       LA    R1,4095(R1)           DOES NOT WORK
         A     R1,=F'4095'
         ST    R1,SNAPL1E
         NI    SNAPL1S,X'EF'         BIT 31 S/B ZERO
         OI    SNAPL1E,X'80'         MARK END OF LIST
         SNAP  DCB=SNAP2,LIST=SNAPL,PDATA=(PSW,REGS,SA)
         CLOSE (SNAP2,),MODE=31
         L     R1,WSR1               SAVE REG
P02XX1   EQU    *
***   END OF DEBUG 4-15-02       ************
         B     TESTLOO6            DONE, GO DO ALERT MSG
         SPACE 2
TESTLOO2 L     R0,ASCBJBNS         POINTER TO STC NAME
         LTR   R0,R0               IS IT STC, NO  IF HEX ZEROES
         BZ    TESTLOO6            NOPE, NOT SURE WHAT IT IS
**       CLC   ASCBTSB,ZEROES     TSO?   4-7-02 DOES NOT WORK
**       BNE   TESTLOO4           YES
         CLC   LOOPID(3),=C'TSU'        TSO?
         BE    TESTLOO4                 YES
* AR 4-30-02 DIFF MESSAGE # FOR STC, FOR AUTO OPS TO USE
         MVC   WRKM100I,=C'MON142I ' FILL IN THE MESSAGE ID
         CLC   LOOPNAME(3),=C'ETC'      CICS STC?
         BE    TESTLOB3
         CLC   LOOPNAME(3),=C'CIC'      BOISE CICS ?
         BNE   TESTLOO3
TESTLOB3 EQU   *
         MVC   WRKM100I,=C'MON152I '  CICS   THE MESSAGE ID
         MVC   WRKM34TX,LPGM34TX   CICS REGION MAYBE LOOPING
         SPACE 2
         B     TESTLOO6            DONE, GO DO ALERT MSG
TESTLOO3 EQU   *                   PROCESS OTHER STC HERE
         MVC   WRKM35TX,LPGM35TX   STC   MAYBE LOOPING
         SPACE 2
         B     TESTLOO6            DONE, GO DO ALERT MSG
TESTLOO4 EQU   *                   PROCESS TSO HERE
         MVC   WRKM37TX,LPGM37TX   TSO   MAYBE LOOPING
         SPACE 2
         B     TESTLOO6            DONE, GO DO ALERT MSG
         SPACE 2
TESTLOO6 EQU   *          AR 4-3-02 END OF NEW LOGIC
***********************************************************************
*    NOW CHECK EXCLUDE TABLE TO SEE IF WE SHOULD IGNORE THE ALERT
*    WE ONLY IGNORE JOBS THAT USE DB2.
*    USE R0 R1 R2 R4 AS WORK REGISTERS
*    TABLE ENTRIES ARE LIKE KMJ*   FMJ%%1D  TCARR03Q
*    WHERE %  MEANS DO NOT CARE, MATCH ON ANYTHING IN THAT COLUMN
*    TCMCT0 - WE CHANGED R3 TO R0 BECAUSE R3 IS TBLENTRY DSECT
*
***********************************************************************
         SPACE
         L     R4,WRKEXCT          ADDR OF EXCLUDE TABLE START
TESTLA1  MVI   WRKEXCTS,C'N'       SET WE FOUND A MATCH SWITCH
         LR    R1,R4               ADDR OF START OF THIS ENTRY
         LA    R4,1(R4)            BUMP PAST THE LENGTH FIELD
         LA    R2,8                LOOP COUNTER
         LA    R0,LOOPNAME         JOBNAME
TESTLA3  CLI   0(R4),C'*'          WILD CARD
         BE    TESTLA4             YES
         CLI   0(R4),C'%'          DO NOT CARE
         BE    TESTLA4             YES
         CLI   0(R4),C' '          BLANK = END OF NAME
         BE    TESTLA6             SKIP TO NEXT TBL ENTRY
         CLC   0(1,R0),0(R4)       JOBNAME TO TBL NAME
         BNE   TESTLA7             SKIP TO NEXT TBL ENTRY
TESTLA4  MVI   WRKEXCTS,C'Y'       SET WE FOUND A MATCH SWITCH
         LA    R4,1(R4)            NEXT COL
         LA    R0,1(R0)
         BCT   R2,TESTLA3          LOOP AGAIN
TESTLA6  EQU   *
         SPACE 2
         CLI   WRKEXCTS,C'Y'       DID WE FIND A MATCH
***      BE    ASCBVSM             YES SKIP THE ALERT MSG AR 6-17-02
         BE    TBLUPDA2            YES SKIP THE ALERT MSG
TESTLA7  LR    R4,R1                GO BACK TO START OF CURR ENTRY
         LA    R4,9(R4)             NEXT TBL ENTRY
         C     R4,WRKEXCTE          END OF TABLE
         BNH   TESTLA1              LOW OR = SO STILL LOOP
         SPACE 2
TESTLA9  EQU   *
***********************************************************************
*      END OF EXCLTBL LOGIC                                           *
***********************************************************************
*      LOOP CHECKING LOGIC:  EXECUTE REXX EXEC TO NOTIFY SOMEBODY     *
***********************************************************************
         SPACE
LOOPNTFY DS    0H
***      IAZXJSAB READ,ASCB=(8),JOBNAME=LOOPNAME,USERID=LOOPUSID
* AR 3-20-02 JOB SCHEDULER ADDRESS CONTROL BLOCK
*  GETS THE JOBNAME AND USERID FROM JES
*  AR 4-3-02 I MOVED IT HIGHER UP, WHICH MIGHT MAKE THIS PARAGRAPH
*       NOT WORK RIGHT. IT IS NOT RIGHT NOW, SO WHO CARES?
*
***      CLC   LOOPUSID(4),=C'USWC' TEST IF WE ACTUALLY CARE
***      BNE   ASCBVSM             NOPE, GO OFF TO CHECK VIRTUAL USE
*
         B     LOOPMSG             ELSE GO ISSUE A CONSOLE MESSAGE
*  AR 3-20-02 IGNORE THE CODE BELOW  **************
*
         SR    R0,R0               CLEAR ENVIRONMENT BLOCK POINTER
         LA    R1,REXXPARM         ADDRESS OF THE PARAMETER LIST
*
         LINK  EP=IRXJCL           GO EXECUTE SOME REXX CODE
*
         B     ASCBVSM             THEN GO DO SOME VIRTUAL USAGE
         SPACE 2
***********************************************************************
*      LOOP CHECKING LOGIC:  ISSUE MESSAGE ABOUT LOOPING JOB          *
***********************************************************************
         SPACE
LOOPMSG  DS    0H
**  **   MVC   WRKM32TX,LPGM32TX   MOVE IN THE MESSAGE TEXT
         MVC   WRKMJOBN,LOOPNAME   COPY JOBNAME TO MESSAGE
         MVI   WRKMCOM1,C' '       PRETTY UP THE MESSAGE A LITTLE BIT
         MVC   WRKMUSID,LOOPUSID   COPY THE USERID INTO THE MESSAGE
         MVI   WRKMCOMA,C' '       PRETTY UP THE MESSAGE A LITTLE BIT
*
        LH    R1,WRKASID          PICK UP THE ADDRESS SPACE NUMBER
        CVD   R1,WRKTEMP          CONVERT TO PACKED DECIMAL
        MVC   WRKMASID,=X'40202020' GET AN EDIT PATTERN
        ED    WRKMASID,WRKTEMP+SIX READABLE ASID NUMBER
*
**  **   MVC   WRKM100I,=C'MON132I ' FILL IN THE MESSAGE ID
         OI    TBLFLAGS,TBLFMSG    INDICATE MESSAGE HAS BEEN ISSUED
* AR 3-20-02 DO WE RESET IT BELOW HERE IN TBLUPDAT?
**       LA    R1,WRKM32TL         LENGTH OF THE MESSAGE TEXT
         LA    R1,WRKMLGTH         LENGTH OF THE MESSAGE TEXT
         STH   R1,WRKMSGL          UPDATE THE LENGTH FIELD
*
         WTO   TEXT=WRKMSG,MF=(E,WRKWTO) MESSAGE ABOUT LOOPING JOB
*
         MVI   WRKMSGT,C' '         BLANK OUT THE AREA
         MVC   WRKMSGT+1(WRKMLGTH-1),WRKMSGT
         B     TBLUPDA2            DO NOT CLEAR THE FLAG
TBLUPDAT DS    0H
         MVI   TBLFLAGS,ZERO       CLEAR THE FLAGS BYTE
TBLUPDA2 DS    0H
         MVC   TBLCPU,WRKCPU       SAVE THE CURRENT CPU TIME VALUE
         MVC   TBLSWCT,WRKSWCT     AND SAVE WAIT COUNT
         MVC   TBLIOSC,ASCBIOSC    SAVE THE CURRENT IO COUNT
         MVC   TBLINTS,ASCBINTS    AND THE CURRENT JOB START TIME
         EJECT
***********************************************************************
*      TEST VIRTUAL STORAGE CONDITION FOR AUTHORIZED STCS             *
***********************************************************************
         SPACE
ASCBVSM  DS    0H
         USING OUCB,R4             FIELD ADDRESSABILITY
         B     ASCBNEXT            DISABLE THE VSM CHECK FOR NOW
*  AR 3-20-02 IGNORE THE CODE BELOW  **************
*
         ICM   R4,15,ASCBOUCB      ADDRESS OF THE OUCB
         BZ    ASCBNEXT            NOPE, NO OUCB (SHOULD NOT HAPPEN)
*
         TM    OUCBSFL,OUCBNSW     TEST FOR NONSWAPPABLE ADDRESS SPACE
         BZ    ASCBNEXT            NOPE, SKIP THE VIRTUAL TEST
*
         CLC   OUCBSUBN,=CL4'STC'  TEST FOR A STARTED TASK
         BNE   ASCBNEXT            NOPE, SKIP THE VIRTUAL TEST
*
         MODESET KEY=ZERO          GET INTO PROTECT KEY ZERO
*
         USING SRB,R6              FIELD ADDRESSABILITY TO REAL SRB
         ST    R8,SRBASCB          UPDATE SRB WITH ASCB ADDRESS
         USING SRBAREA,R6          FIELD ADDRESSABILITY TO SRB + FIELDS
         XC    SRBECB,SRBECB       CLEAR THE ECB BEFORE SCHEDULE
*
         SCHEDULE SRB=(6),FRR=NO   SCHEDULE SRB TO COPY LDA DATA
*
         MODESET KEY=NZERO         GET BACK OFF THE TIGHTROPE
*
         CLC   WRKASID,ZEROES      TEST FOR THE VERY FIRST ASID
         BE    XMWAIT              YEP, NO DATA AVAILABLE TO PROCESS
*
         OC    WRKBLOCK,WRKBLOCK   TEST IF ANY DATA CAME BACK
         BZ    XMWAIT              NOPE, A.S. WAS TERMINATING
         EJECT
***********************************************************************
*      PROCESS LDA DATA FROM THE LAST NONSWAPPABLE ADDRESS SPACE      *
*  AR 3-20-02 IGNORE THE CODE BELOW  **************
*      ALL THE CAL-- LOGIC           **************
***********************************************************************
         SPACE 2
CALCOMP  DS    0H
         SPACE
***********************************************************************
*      BUILD THE MESSAGE ABOUT EXPECTED TERMINATION DATE/TIME         *
***********************************************************************
         SPACE
         LA    R1,WRKMLGTH         LENGTH OF THE MESSAGE
         STH   R1,WRKMSGL          SET UP THE MESSAGE LENGTH
*
         MVC   WRKM100I,=C'MON100I ' MOVE IN THE MESSAGE IDENTIFIER
         MVC   WRKMJOBN,WRKJOBN    AND THE JOB NAME
         MVI   WRKMCOM1,C','       DELIMITER
         LH    R1,WRKASID          PICK UP THE ADDRESS SPACE NUMBER
         CVD   R1,WRKTEMP          CONVERT TO PACKED DECIMAL
         MVC   WRKMASID,=X'40202020' GET AN EDIT PATTERN
         ED    WRKMASID,WRKTEMP+SIX READABLE ASID NUMBER
         MVI   WRKMCOM2,C','       DELIMITER
         L     R1,WRKASSZ          GET SIZE OF ADDRESS SPACE
         SRL   R1,TWENTY           CONVERT TO MEGABYTES
         CVD   R1,WRKTEMP          CONVERT TO PACKED DECIMAL
         MVC   WRKMASSZ,=X'40202020' GET AN EDIT PATTERN
         ED    WRKMASSZ,WRKTEMP+SIX READABLE ADDRESS SPACE SIZE IN MEG
         MVI   WRKMCOM3,C','       DELIMITER
         L     R1,WRKCRGTP         CURRENT TOP OF REGION
         SRL   R1,TEN              CONVERT TO K
         CVD   R1,WRKTEMP          CONVERT TO PACKED DECIMAL
         MVC   WRKMVIRT,=X'402020202020' GET AN EDIT PATTERN
         ED    WRKMVIRT,WRKTEMP+FIVE READABLE VIRTUAL USED VALUE
         MVI   WRKMCOM4,C','       DELIMITER
         L     R1,WRKHIAL          GET THE SYSTEM SIZE
         SRL   R1,TEN              CONVERT TO K
         CVD   R1,WRKTEMP          CONVERT TO PACKED DECIMAL
         MVC   WRKMSYS,=X'402020202020' GET AN EDIT PATTERN
         ED    WRKMSYS,WRKTEMP+FIVE READABLE SYSTEM USED VALUE
         MVI   WRKMCOM5,C','       DELIMITER
         L     R1,WRKREM           GET THE REMAINDER VALUE
         SLL   R1,TWO              CONVERT TO K
         CVD   R1,WRKTEMP          CONVERT TO PACKED DECIMAL
         MVC   WRKMREM,=X'402020202020' GET AN EDIT PATTERN
         ED    WRKMREM,WRKTEMP+FIVE READABLE REMAINDER (UNUSED) VALUE
         MVI   WRKMCOM6,C','       DELIMITER
         MVC   WRKMYYYY,=X'402020202020' EDIT PATTERN
         ED    WRKMYYYY,WRKDTDAT   MAKE A READABLE YEAR
         MVI   WRKMDOT1,C'.'       APPEND CHARACTER
         MVC   WRKDDD,=X'4021202020' GET AN EDIT PATTERN
         ED    WRKDDD,WRKDTDAT+TWO MAKE A READABLE NUMBER OF DAYS
         MVC   WRKMDDD,WRKDDD+TWO  COPY IT OVER TO THE MESSAGE
         MVI   WRKMDOT2,C'.'       APPEND CHARACTER
         MVC   WRKDDD,=X'F020202020' GET AN EDIT PATTERN
         ED    WRKDDD,WRKDTVAL     MAKE A READABLE TIME OF DAY
         MVC   WRKMTIME,WRKDDD+ONE COPY IT OVER TO THE MESSAGE
         EJECT
***********************************************************************
*      ISSUE THE MESSAGE ABOUT EXPECTED TERMINATION DATE/TIME         *
***********************************************************************
         SPACE 3
         WTO   TEXT=WRKMSG,MF=(E,WRKWTO) A MESSAGE ABOUT IT
*  AR 3-20-02 END OF IGNORED CODE    **************
         SPACE 2
***********************************************************************
*      WAIT FOR CROSS MEMORY POST FROM SRB GETTING LDA DATA           *
***********************************************************************
         SPACE 3
XMWAIT   DS    0H
         TM    SRBECB,X'80'        TEST IF ECB POSTED YET
         BO    XMWMOVE             YEP, WE HAVE DATA TO MOVE
*
         MODESET KEY=ZERO          OTHERWISE SWITCH TO PROTECT KEY ZERO
*
         WAIT  1,ECB=SRBECB        AND WAIT FOR ECB TO COMPLETE
*
         MODESET KEY=NZERO         GET OFF THE TIGHTROPE
*
XMWMOVE  DS    0H
         MVC   WRKBLOCK,SRABLOCK   COPY THE DATA FROM SQA TO WORK AREA
         MVC   WRKASID,ASCBASID    COPY THE ASID NUMBER
         MVC   WRKINTS,ASCBINTS    AND THE JOB INITIATION TIME
         L     R1,ASCBJBNS         ADDRESS OF JOBNAME FOR STCS
         MVC   WRKJOBN,ZERO(R1)    PICK UP JOBNAME FOR POSSIBLE MESSAGE
** AR    ST    R11,WRKCCURR        SAVE ADDRESS OF LAST CALBLOCK
** AR    L     R11,CALNEXT         MOVE UP TO NEXT CALCULATION BLOCK
*
         CLC   ASCBASID,=H'1'      TEST IF WORKING ON *MASTER*
         BNE   ASCBNEXT            NOPE, THEN STAY ON CALBLOCK CHAIN
*
** AR    L     R11,WRKCALST        OTHERWISE GET TO HEAD OF CHAIN
** AR    XC    WRKCCURR,WRKCCURR   INDICATE NO PREVIOUS BLOCK
         EJECT
***********************************************************************
*      MOVE UP TO THE NEXT ASCB                                       *
***********************************************************************
         SPACE 3
ASCBNEXT DS    0H
         LA    R10,FOUR(R10)       MOVE UP TO NEXT ASCB
* AR 4-15-02 NOT SURE WHAT R10 IS USED FOR  ***
*
         BCT   R9,ASCBLOOP         FALL THRU WHEN END OF LIST REACHED
         SPACE
***********************************************************************
*      GO TO SLEEP FOR A WHILE,  THEN WAKE UP AND DO IT ALL AGAIN     *
***********************************************************************
         SPACE 2
SLEEP    DS    0H
         L     R2,WRKCOMMP         ADDRESS OF COMMUNICATIONS AREA
         L     R9,ZERO(R2)         ADRRESS OF STOP/MODIFY ECB
*
         TM    ZERO(R9),POSTED     TEST FOR PAUSE COMMAND ENTERED
** AR    BO    RC0                 YEP, THEN ITS TIME TO QUIT
         BO    P08010              YEP, THEN ITS TIME TO QUIT
*
* AR 3-20-02 WRKWAIT CAN BE DIFFERENT FROM LIMIT, SEE ASCBWT LOGIC
         SPACE 2
         STIMER WAIT,BINTVL=WRKWAIT SNOOZE FOR A LITTLE WHILE
*
         B     ASVTLOOP            THEN GO SCAN SETUNITS AGAIN
         EJECT
***********************************************************************
*      PARM PROCESSING ROUTINE                                        *
***********************************************************************
PACKIT   EQU   *
         BCTR  R4,0                      SUBTRACT ONE FOR EXECUTED MOVE
         LA    R5,7                      MAX LENGTH
         SLL   R5,4                      AND SHIFT TO FORM L2
         OR    R5,R4                     L1, L2 NOW IN REG 5
         EX    R5,PACKINS                PACK IT
         CVB   R5,DOUBLE                 MAKE TYPE BINARY
         BR    R14                       RETURN
PACKINS  PACK  DOUBLE(*-*),0(,R3)        MAKE IT DECIMAL
DOUBLE   DC    D'0'                      WORK AREA
         EJECT
FAILURE  DC    H'0'
FIXTOFLT DS    0H
         MVC   WRKTEMP,ZEROES      INITIALIZE TEMPORARY FIELD
         ST    R1,WRKTEMP+FOUR     SAVE THE FIXED POINT VALUE
         XC    WRKTEMP,TWO31       FLIP SOME VARIOUS BITS
         LD    FPR0,WRKTEMP        LOAD WORK FIELD INTO REGISTER
         SD    FPR0,TWO31          NORMALIZE FLOATING POINT NUMBER
         BR    R14                 AND RETURN TO CALLER
*
FLTTOFIX DS    0H
         SD    FPR0,TWO31R         TEST IF NUMBER IS TOO BIG (POSITIVE)
         BNMR  R14                 YEP, TAKE THE ERROR RETURN
*
         AW    FPR0,TWO32          TEST IF NUMBER IF TOO BIG (NEGATIVE)
         BMR   R14                 YEP, TAKE THE ERROR RETURN
*
         STD   FPR0,WRKTEMP        SAVE THE FLOATING POINT NUMBER
         XI    WRKTEMP+FOUR,X'80'  FLIP A BIT
         L     R1,WRKTEMP+FOUR     AND LOAD THE FINAL RESULT
         B     FOUR(R14)           TAKE THE NORMAL RETURN
         SPACE 2
P08010   EQU   *         ESTAE FIXUP ROUTINES  4-3-02
***      LR    R12,R15
***      USING P08010,R12
         BALR  R12,0                 SET UP NEW BASE REG.
         USING *,R12
         OPEN  (SNAP2,OUTPUT),MODE=24
         LTR   R15,R15
         BZ    P08220B
         ABEND  510,DUMP
P08220B  EQU   *
** AR    ST    R13,SNAPL1S           ADDRESS OF WORKAREA
         ST    R11,SNAPL1S           ADDRESS OF WORKAREA
         LR    R1,R11
         A     R1,=F'4095'
         ST    R1,SNAPL1E
         NI    SNAPL1S,X'EF'         LEFTMOST BIT S/B ZERO
         OI    SNAPL1E,X'80'         MARK END OF LIST
         SNAP  DCB=SNAP2,LIST=SNAPL,PDATA=(PSW,REGS,SA)
         LTR   R15,R15
         BZ    P08220C
         ABEND  512,DUMP
P08220C  EQU   *
         L     R1,WRKSRB           ADDRESS OF GOTTEN SRB AREA
         ST    R1,SNAPL1S            ADDRESS OF SRBAREA
**       LA    R1,4095(R1)           DOES NOT WORK
         A     R1,=F'4095'
         ST    R1,SNAPL1E
         NI    SNAPL1S,X'EF'         BIT 31 S/B ZERO
         OI    SNAPL1E,X'80'         MARK END OF LIST
         SNAP  DCB=SNAP2,LIST=SNAPL,PDATA=(PSW,REGS,SA)
         CLOSE (SNAP2,),MODE=24
***********************************************************************
*      MODULE EXIT ROUTINE                                            *
***********************************************************************
         SPACE 3
RC0      DS    0H
         WTO   'MON108I MONJOBS NORMAL TERMINATION' OFF THE AIR
*
         LR    R1,R13              ADDRESS OF MODULE WORK AREA
         LA    R0,WRKLNGTH         LENGTH OF MODULE WORK AREA
         L     R13,FOUR(R13)       ADDRESS OF CALLERS SAVE AREA
         FREEMAIN R,LV=(0),A=(1)   FREE UP MODULE WORK AREA
*
         RETURN (14,12),RC=0       AND RETURN TO CALLER
         EJECT
*      WORKING STORAGE
*
H4       DC    H'4'
COMMLPTR EXTRACT FIELDS=COMM,MF=L
COMMLPTL EQU   *-COMMLPTR
SECOND   DC    F'100'
LIMIT    DC    F'1000'
TENTHOU  DC    F'10000'
LOOPCPU  DC    F'6000'
SNAPL    DS    0F                 LIST OF SNAP START-END ADDRESS
SNAPL1S  DC    F'0'
SNAPL1E  DC    F'0'
*
MEG      DC    X'00100000'
TBLSIZE  DC    AL2(TBLLNGTH)
ZEROES   DC    XL8'00'
EXPRESS  DC    CL8'EXPRESS'     ** NOT USED BY SUPERVALU
*
LPGM32TX DC    C'MAY BE LOOPING'
LPGM32TL EQU   *-LPGM32TX
*
LPGM34TX DC    C'CICS MAY BE LOOPING'
LPGM34TL EQU   *-LPGM34TX
*
LPGM35TX DC    C'STC  MAY BE LOOPING'
LPGM35TL EQU   *-LPGM35TX
*
LPGM36TX DC    C'DB2 JOB MAY BE LOOPING'
LPGM36TL EQU   *-LPGM36TX
*
LPGM37TX DC    C'TSO  MAY BE LOOPING'
LPGM37TL EQU   *-LPGM37TX
*
MESSAGE  WTO   TEXT=ZEROES,MF=L
MESSAGEL EQU   *-MESSAGE
HSMSYKO  DC    CL8'HSMSYKO'
SYSZRAC2 DC    C'SYSZRAC2'
RNAME    DC    C'RACF.PRIMARY'
*
REXXPARM DC    A(X'80000000'+REXXLGTH)
REXXLGTH DC    AL2(REXXEND-REXXDATA)
REXXDATA DC    CL8'LOOPNTFY'
         DC    C' '
LOOPNAME DC    CL8' '
         DC    C' '
LOOPUSID DC    CL8' '
         DC    C' '
LOOPID   DC    CL8' '        4-3-02 JOBNNN, STCNNN, TSUNNN
REXXEND  EQU   *
*
         LTORG
         DS    0D
FP_ONE   DC    D'1'
FP_THIRTY DC   D'30'
NINETY   DC    D'0.9'
TWO31    DC    X'4E00000080000000'
TWO31R   DC    X'4F00000008000000'
TWO32    DC    X'4E00000100000000'
*
WSR1     DC    F'0'     SNAP REG SAVE  R1
WSR13    DC    F'0'     SNAP REG SAVE  R13
WSSNAPS  DC    C'0'     SNAP SWITCH SO WE ONLY DO IT ONCE
*
*  4-3-02 HERE WE ARE CLOSE TO RUNNING OUT OF ADDRESSIBILITY
*         WE MAY NEED A SECOND BASE REGISTER SOON *******
SYSIN    DCB   DDNAME=SYSIN,DSORG=PS,RECFM=FB,MACRF=(GL),              X
               BLKSIZE=0,LRECL=80,EODAD=P10600
*              BLKSIZE=800,LRECL=80,DCBE=SYSINDC
*YSINDC  DCBE  RMODE31=BUFF,EODAD=P10600
*
SNAP2    DCB   DDNAME=SNAP2,DSORG=PS,RECFM=VBA,MACRF=(W),              X
               BLKSIZE=882,LRECL=125
*
ENQRET   DC    1000X'00'
         EJECT
WORKAREA DSECT
WRKSAVE  DS    18F
WRKWAIT  DS    F
WRKTABLE DS    F
WRKASID  DS    H
         DS    0F
WRKSAVR  DS    16F            4-15-02 SAVE BEFORE SCHEDULE SRB RUNS
WRKWTO   DS    XL(MESSAGEL)
*
WRKMSG   DS    0H
WRKMSGL  DS    H
WRKMSGT  DS    0X
WRKM100I DS    CL8
WRKMJOBN DS    CL8
WRKMCOM1 DS    C
WRKMASID DS    CL4
WRKMCOM2 DS    C
WRKMASSZ DS    CL4
WRKMCOM3 DS    C
WRKMVIRT DS    CL6
WRKMCOM4 DS    C
WRKMSYS  DS    CL6
WRKMCOM5 DS    C
WRKMREM  DS    CL6
WRKMCOM6 DS    C
WRKMYYYY DS    CL6
WRKMDOT1 DS    C
WRKMDDD  DS    CL3
WRKMDOT2 DS    C
WRKMTIME DS    CL4
WRKMVART DS    CL17          VARIABLE TEXT HERE
WRKMLGTH EQU   *-WRKMSGT     NOT TO START OF WRKMSG
** ABOVE IS USED AS TEMP AREA FOR SYSIN DATA, SO CHECK LENGTH **
         ORG   WRKMASSZ
WRKMUSID DS    CL8
WRKMCOMA DS    C
WRKM32TX DS    XL(LPGM32TL)
WRKM32TL EQU   *-WRKMSGT
         ORG   WRKM32TX
WRKM34TX DS    XL(LPGM34TL)
WRKM34TL EQU   *-WRKMSGT
         ORG   WRKM32TX
WRKM35TX DS    XL(LPGM35TL)
WRKM35TL EQU   *-WRKMSGT
         ORG   WRKM32TX
WRKM36TX DS    XL(LPGM36TL)
WRKM36TL EQU   *-WRKMSGT
         ORG   WRKM32TX
WRKM37TX DS    XL(LPGM37TL)
WRKM37TL EQU   *-WRKMSGT
         ORG
*
         DS    0F
WRKSRB   DS    F
WRKRTN   DS    F
WRKCALO  DS    F
WRKASSZ  DS    F
WRKCALST DS    F
WRKCCURR DS    F
WRKEXCT  DS    F        EXCLTBL LIST OF JOBNAMES TO EXCLUDE
WRKEXCTE DS    F        EXCLTBL END-OF-TABLE
WRKCPU   DS    F        HOLD CPU TIME FOR TBLCPU UPDAT
WRKSWCT  DS    H
DLTCPU   DS    F        HOLD DELTA CPU TIME
DBLWORD  DS    D        WORK DOUBLEWORD FIELD\
*
WRKCOMM  DS    CL(COMMLPTL)
WRKCOMMP DS    F
WRKDTVAL DS    XL8
WRKDTDAT DS    XL4
         DS    XL4
*
WRKBLOCK DS    0XL40    FOR SRABLOCK, PART OF SRB DATA
WRKCRGTP DS    F
WRKLIMIT DS    F
WRKHIAL  DS    F
WRKERGTP DS    F
WRKELIM  DS    F
WRKEHIAL DS    F
WRKESTRA DS    F
WRKREGRQ DS    F
WRKPGMN  DS    CL8         4-2-02 PROGRAM NAME
*   AR 4-2-02 ABOVE IS THE END OF WRKBLOCK
WRKREM   DS    F
*
WRKEXCTS DS    C        EXCLTBL SWITCH
WRKDDD   DS    CL5
WRKJOBN  DS    CL8
*
         DS    0D
WRKTEMP  DS    D
WRKTOD   DS    D
WRKINTS  DS    D
* DISPLAY CPU VALUES - TCMCT0
DSPMSG   DS    0H
DSPMSGL  DC    H'35'
DSPMSGT  DS    0X
DSPMSGI  DC    CL8'MON122I '
DSPTEXT  DS    CL10'CURR CPU: '
DSPCPU   DS    CL16
         DC    CL1' '
*
WRKLNGTH EQU   *-WORKAREA
*
TBLENTRY DSECT
TBLCPU   DS    F        CPU TIME, PART OF ASCBEJSY
TBLSWCT  DS    H        SHORT WAIT
TBLFLAGS DS    X
TBLFMSG  EQU   B'10000000'
TBLRSVD1 DS    X
TBLIOSC  DS    F        I/O COUNT   ASCBIOSC
TBLINTS  DS    XL8      START TIME, ASCBINTS
TBLLNGTH EQU   *-TBLENTRY
*
* AR 4-2-02 BELOW IS A LITTLE DIFF FROM MONJOBSS CODE **
SRBAREA  DSECT ,
         DS    XL(SRBSIZE)   THE REAL SRB RESIDES IN HERE
SRBECB   DS    F
SRBPOST  POST  SRBECB,ASCB=SRAASCB,ERRET=0,ECBKEY=YES,MF=L
SRAASCB  DS    F
SRABLOCK DS    0XL40
SRACRGTP DS    F
SRALIMIT DS    F
SRAHIAL  DS    F
SRAERGTP DS    F
SRAELIM  DS    F
SRAEHIAL DS    F
SRAESTRA DS    F
SRAREGRQ DS    F
SRAPGMN  DS    CL8         4-2-02 PROGRAM NAME
SRBLNGTH EQU   *-SRBAREA
*
* AR 4-15-02  REMOVED MOST LOGIC FOR THIS FUNCTION
CALBLOCK DSECT
CALNEXT  DS    F
CALPREV  DS    F
CALASID  DS    H
*
CALFLAGS DS    X
CALMSG   EQU   B'10000000'
*
CALRANGE DS    0D
CALLEAST DS    F
CALMOST  DS    F
CALINTS  DS    D
CALTOD   DS    D
CALN     DS    D
CALXSUM  DS    D
CALYSUM  DS    D
CALXSQR  DS    D
CALYSQR  DS    D
CALXYSUM DS    D
CALALPHA DS    D
CALBETA  DS    D
CALLNGTH EQU   *-CALBLOCK
*
         CVT   DSECT=YES
         IAZJSAB ,
         IHAASCB ,
         IHAASSB ,
         IHAASVT ,
CSCB     DSECT
         IEECHAIN ,
         IHAGDA ,
         IHALDA ,
         IHAOUXB ,
         IHAPSA ,
         IHASRB ,
         IRAOUCB ,
         ISGRIB ,
         END
./ ADD NAME=MONJOBSS 0100-03311-03311-1200-00273-00273-00000-FILE066 00
         TITLE 'MONJOBSS: SRB ROUTINE TO EXTRACT VIRTUAL STORAGE DATA'
***********************************************************************
* MACRO LIBS NEEDED: SYS1.MACLIB                                      *
*                    SYS1.MODGEN                                      *
*                                                                     *
* LINKAGE EDITOR PARMS: DEFAULT                                       *
*                                                                     *
* PURPOSE:                                                            *
*        MONJOBSS IS AN SRB ROUTINE THAT RUNS IN EACH ADDRESS SPACE   *
*        BEING EXAMINED FOR VIRTUAL STORAGE USE.                      *
*        THE BASIC FUNCTIONS ARE:                                     *
*        1) FIND THE LDA FOR THIS ADDRESS SPACE                       *
*        2) COPY SELECTED LDA FIELDS TO THE SQA AREA PASSED AS AN     *
*           INPUT PARAMETER                                           *
*    4-2-02 USE ASCB, GO TO ASXB & POINT TO FIRST TCB IN              *
*    ADDRESS SPACE. GO THRU CHAIN OF TCB'S UNTIL WE FIND ONE THAT     *
*    HAS A GOOD JOB STEP CONTROL BLOCK (JSCB). THEN GET PROGRAM       *
*    NAME.                                                            *
*                                                                     *
*                                                                     *
* CHANGE LOG:                                                         *
*  SUPERVALU, INC ALAN FIELD, ALAN RECKNER 4-2-02 MODIFIED TO         *
*  FIND PROGRAM NAME FOR JOB/STC THAT MAY BE USING TOO MUCH CPU       *
*  THE LDA LOGIC APPEARS TO NOT BE USED IN THE ORIGINAL PROGRAM       *
*                                                                     *
*                                                                     *
*                                                                     *
* NOTES:                                                              *
*                                                                     *
*                 REGISTER CONVENTIONS =                              *
*                                                                     *
*                    REGISTER  0       = UNUSED                       *
*                    REGISTER  1       = ADDRESS OF INPUT PARAMETERS  *
*                    REGISTER  2       = ASXB                         *
*                    REGISTER  3       = WORK                         *
*                    REGISTER  4       = WORK                         *
*                    REGISTER  5       = WORK                         *
*                    REGISTER  6       = WORK                         *
*                    REGISTER  7       = WORK                         *
*                    REGISTER  8       = WORK                         *
*                    REGISTER  9       = LDA THEN TCB                 *
*                    REGISTER  10      = WORK                         *
*                    REGISTER  11      = LDA                          *
*                    REGISTER  12      = MODULE BASE REGISTER         *
*                    REGISTER  13      = WORK                         *
*                    REGISTER  14      = WORK                         *
*                    REGISTER  15      = WORK                         *
*                                                                     *
*                PATCH LABEL = N/A                                    *
*                                                                     *
*                ATTRIBUTES =                                         *
*                                                                     *
*             ENTRY POINTS = MONJOBSS (ONLY ENTRY POINT)              *
*                                                                     *
*             INPUT =                                                 *
*                                                                     *
*             OUTPUT =                                                *
*                                                                     *
*             EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14   *
*                                                                     *
*                RETURN CODE = ZERO                                   *
*                                                                     *
*             EXIT - ERROR = AT PROGRAM END VIA BRANCH REGISTER 14    *
*                                                                     *
*                OUTPUT = NONE                                        *
*                                                                     *
*                RETURN CODE =                                        *
*                                                                     *
*             EXTERNAL REFERENCES =                                   *
*                                                                     *
*                ROUTINES =                                           *
*                                                                     *
*                DATA AREAS =                                         *
*                                                                     *
*             TABLES = NONE                                           *
*                                                                     *
*             MACROS = IHASRB, IHALDA, IHAASCB                        *
*                                                                     *
*             MESSAGES = NONE                                         *
*                                                                     *
*             ABEND CODES =                                           *
***********************************************************************
         EJECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
FPR0     EQU   0
FPR2     EQU   2
FPR4     EQU   4
FPR6     EQU   6
ZERO     EQU   0
ONE      EQU   1
TWO      EQU   2
THREE    EQU   3
FOUR     EQU   4
FIVE     EQU   5
SIX      EQU   6
SEVEN    EQU   7
EIGHT    EQU   8
NINE     EQU   9
TEN      EQU   10
ELEVEN   EQU   11
TWELVE   EQU   12
FOURTEEN EQU   14
FIFTEEN  EQU   15
SIXTEEN  EQU   16
SEVNTEEN EQU   17
EIGHTEEN EQU   18
POSTED   EQU   B'01000000'
MASK0111 EQU   B'00000111'
MASK1000 EQU   B'00001000'
MASK1110 EQU   B'00001110'
ALLBITS  EQU   B'11111111'
MONJOBSS AMODE 31
MONJOBSS RMODE ANY
         EJECT
***********************************************************************
*      MODULE ENTRY POINT                                             *
***********************************************************************
         SPACE 3
MONJOBSS CSECT
         USING MONJOBSS,R15        TEMPORARY ADDRESSABILITY
         B     BEGIN               SKIP OVER THE EYECATCHER
*  ENTRY POINT FOR RESOURCE MANAGER TERMINATION ROUTINE
RMTR     DS    0H
         USING SRBECB,R1           FIELD ADDRESSABILITY
         BCTR  R15,ZERO            BACK UP BASE REG BY ONE BYTE
         BCTR  R15,ZERO            BACK UP BASE REG BY TWO BYTES
         BCTR  R15,ZERO            BACK UP BASE REG BY THREE BYTES
         BCTR  R15,ZERO            BACK UP BASE REG BY FOUR BYTES
         LR    R12,R15             AND ESTABLISH MODULE BASE REGISTER
         XC    SRABLOCK,SRABLOCK   ZERO OUT TO INDICATE NO DATA
         B     POSTIT              GO INDICATE THE SRB IS DONE
*
         DC    CL8'MONJOBSS'       MODULE NAME
         DC    CL8'&SYSDATE'
         DC    CL8'&SYSTIME'
*
BEGIN    DS    0H
         LR    R12,R15             SET UP MODULE BASE REGISTER
         DROP  R15                 FORGET THAT
         USING MONJOBSS,R12        MODULE ADDRESSABILITY
         LR    R11,R0              COPY OVER THE SRB ADDRESS
         USING SRB,R11             FIELD ADDRESSABILITY TO SRB
         L     R10,SRBASCB         GET THE ASCB ADDRESS
         USING ASCB,R10            FIELD ADDRESSABILITY TO ASCB
*
         L     R9,ASCBLDA          ADDRESS OF THE LDA
         USING LDA,R9              ESTABLISH FIELD ADDRESSABILITY
         EJECT
***********************************************************************
*      COPY LDA FIELDS TO PARMS AREA IN SQA                           *
***********************************************************************
         SPACE 3
         USING SRBECB,R1           FIELD ADDRESSABILITY
         MVC   SRACRGTP,LDACRGTP   COPY CURRENT TOP OF REGION
         MVC   SRALIMIT,LDALIMIT   COPY IEALIMIT VALUE
         MVC   SRAHIAL,LDAHIAL     COPY HI ALLOCATED VALUE
*
         MVC   SRAERGTP,LDAERGTP   COPY CURRENT TOP OF REGION > 16M
         MVC   SRAELIM,LDAELIM     COPY IEALIMIT VALUE > 16M
         MVC   SRAEHIAL,LDAEHIAL   COPY HI ALLOCATED VALUE > 16M
         MVC   SRAESTRA,LDAESTRA   COPY REGION STARTING ADDRESS > 16M
         MVC   SRAREGRQ,LDAREGRQ   COPY REGION SIZE REQUESTED
* AR 4-2-02 LOGIC TO FIND THE PROGRAM NAME ********
         L      R2,ASCBASXB         XTENDED ASCB
         USING  ASXB,R2
** X     MVC    DAUSER(7),ASXBUSER   USER ID
** X     MVC    DAASXBT(4),ASXBFTCB   ARE THEY ALL THE SAME?
** X     MVC    DAASXBT+4(4),ASCBASXB
**AR 3-26-02 WE COME HERE FOR SOME STC AS WELL AS JOBS, WHY?
         L      R9,ASXBFTCB         FIRST TCB ON CHAIN
         DROP   R9
         USING  TCB,R9
* NOW FIND A TCB THAT IS NOT KEY=0, SEARCH QUE OF TCB'S
* WE SHOULD COMPARE TO ASXBTCBS SO WE DO NOT GO PAST END OF CHAIN
P01020    C     R9,TCBJSTCB
          BNE   P01030
          CLC   TCBTCB,=X'00000000'  END OF CHAIN?
          BE    P01030              NOT RIGHT, BUT WHAT ELSE TO DO?
          L     R9,TCBTCB          GO GET NEXT TCB
          B     P01020
P01030   EQU    *
         L      R2,TCBJSCB
         DROP   R2
         USING  IEZJSCB,R2
         MVC    SRAPGMN(8),JSCBPGMN   PROGRAM NAME
         CLI    JSCBPGMN,X'00'        NOT THERE, GO LOOK
         BNE    P01050
         L      R9,TCBBACK            PREV TCB ON QUE
         L      R2,TCBJSCB
* AR 4-2-02 THE NEXT 2 DID NOT HAVE ANY EFFECT.
*        L      R2,JSCBACT            FIND ACTIVE JSCB
         MVC    SRAPGMN(8),JSCBPGMN   PROGRAM NAME
P01050   EQU    *
         EJECT
***********************************************************************
*      POST THE MONITOR TASK THAT WE HAVE DONE OUR WORK               *
***********************************************************************
         SPACE 3
POSTIT   DS    0H
         L     R2,SRBECB           GET THE CONTENTS OF THE ECB
         N     R2,=X'3FFFFFFF'     TURN OFF WAIT AND POST BITS
         L     R3,=X'40000000'     SET TO TURN ON THE POST BIT
*
         CS    R2,R3,SRBECB        TRY TO POST THE ECB
         BZ    POSTDONE            YEP, IT WORKED
*
         LTR   R2,R2               TEST IF THE WAIT BIT IS ON
         BM    DOPOST              YEP, WE GOTTA GO THROUGH POST
*
         N     R2,=X'40000000'     TEST IF ECB IS NOW POSTED
         BNZ   POSTDONE            YEP, WE CAN SKIP THE POST
*
DOPOST   DS    0H
         LR    R2,R14              SAVE THE RETURN ADDRESS
         L     R10,SRAASCB         ASCB ADDRESS TO POST COMPLETION
         POST  SRBECB,                                                 X
               LINKAGE=SYSTEM,                                         X
               ECBKEY=0,                                               X
               ASCB=(R10),                                             X
               ERRET=MONJOBSS+FOUR,                                    X
               MF=(E,SRBPOST)
         LR    R14,R2              RECOVER THE RETURN ADDRESS
POSTDONE DS    0H
         SR    R15,R15             INDICATE OUT GENERAL HAPPINESS
         BR    R14                 AND RETURN TO THE SYSTEM
*
         LTORG ,
         EJECT
SRBAREA  DSECT ,
         DS    XL(SRBSIZE)
SRBECB   DS    F
SRBPOST  DS    4F
SRAASCB  DS    F
SRABLOCK DS    0XL40
SRACRGTP DS    F
SRALIMIT DS    F
SRAHIAL  DS    F
SRAERGTP DS    F
SRAELIM  DS    F
SRAEHIAL DS    F
SRAESTRA DS    F
SRAREGRQ DS    F
SRAPGMN  DS    CL8
SRBLNGTH EQU   *-SRBAREA
*
         IHAASCB ,
         IHALDA ,
         IHASRB ,
         IHAASXB
         EJECT
         IHAASVT
         EJECT
TCBFIX   DSECT
         IKJTCB      TCB
         EJECT
         IEZJSCB     JSCB
         EJECT
         END
./ ADD NAME=RACFDS   0100-03311-03311-1200-00148-00148-00000-FILE066 00
RACFDS   MOWSTART
***********************************************************************
* PROGRAM LISTS INFORMATION FROM THE RACF CVT AND DSDT                *
***********************************************************************
MOWWORK  DSECT
MSG1     DC    CL80' '
RACFDS   CSECT
RACFDS   AMODE 31
RACFDS   RMODE 24
         USING CVT,R2
         L     R2,16                      POINT TO CVT
         USING RCVT,R3
         L     R3,CVTRAC                  POINT TO RACF CVT
         LTR   R3,R3                      CHECK IT
         BZ    FIN                        NOT SET
         USING DSDT,R6
         L     R6,RCVTDSDT                DATASET DESCRIPTOR TABLE
         USING DSDE,R7
         LA    R7,DSDTENTY
         L     R2,DSDTNUM                 # ENTRIES IN TABLE
         SLL   R2,1                       MULTIPLY BY 2
         MVI   MSG1,X'40'                 A BLANK
         MVC   MSG1+1(79),MSG1            BLANK IT OUT
PUTNAME  EQU   *
         MVC   MSG1(44),DSDEDSN
         LA    R4,MSG1+45                 POINT TO MESSAGE AREA
         MVC   0(7,R4),=C'OLD FMT'
         TM    DSDESTAT,X'40'             IS THIS THE PRIMARY
         BZ    TA                         NO
         TM    DSDTFLAG,X'80'             TEST FOR FORMAT
         BZ    T0                         OLD FORMAT
         B     TB                         SET NEW FORMAT
TA       EQU   *
         TM    DSDTFLAG,X'40'             TEST BACKUP FOR NEW FMT
         BZ    T0                         ITS NOT
TB       EQU   *
         MVC   0(3,R4),=C'NEW'            INDICATE NEW FMT
T0       EQU   *
         LA    R4,8(R4)
         TM    RCVTSTAT,RCVTRNA           IS IT ACTIVE
         BZ    T1
         MVC   0(12,R4),=C'NOT ACTIVE, '  MESSAGE TO SAY ITS NOT ACTIVE
         LA    R4,12(R4)                  NEXT MESSAGE SLOT
T1       EQU   *
         TM    RCVTSTAT,RCVTNLS           BYPASS STATS
         BZ    T2
         MVC   0(14,R4),=C'BYPASS STATS, '
         LA    R4,14(R4)
T2       EQU   *
         BCTR  R4,0
         MVI   0(R4),X'40'
         BAL   R10,DISPLAY
         LA    R7,176(R7)             POINT TO NEXT DATASET ENTRY
         BCT   R2,PUTNAME
         SPACE
         L     R2,RCVTDPTB            ADDRESS OF DYNAMIC PARSE TABLE
         LTR   R2,R2                  IS IT LOADED
         MVC   MSG1(14),=C'DYNAMIC PARSE '
         MVC   MSG1+14(6),=C'ACTIVE'
         BNZ   *+10
         MVC   MSG1+14(8),=C'INACTIVE'
         TPUT  MSG1,L'MSG1
         SPACE
         L     R4,RCVTSPT           POINT TO STARTED PROCEDURES TABLE
         USING RSTCTAB,R4
         LH    R5,RSTCENT           NUMBER OF ENTRIES IN TABLE
         N     R5,=X'00007FFF'      MAKE SURE ITS POSITIVE
         LTR   R5,R5                IF ZERO, ICHRIN03 NOT IN USE
         BNZ   STCNAM0              IT IS
         MVC   MSG1(19),=C'ICHRIN03 NOT IN USE'
         BAL   R10,DISPLAY
         B     FIN
STCNAM0  EQU   *
         MVC   MSG1(L'RSTCTITL),RSTCTITL
         BAL   R10,DISPLAY
STCNAM   EQU   *
         MVC   MSG1(L'RSTCNAM),RSTCNAM       MOVE IN STC NAME
         MVC   MSG1+9(L'RSTCUSR),RSTCUSR     MOVE IN USERID
         TM    RSTCFLG,RSTPRIV      TEST FOR PRIVILEDGED
         BZ    *+8                  ITS NOT
         MVI   MSG1+18,C'P'         INDICATE PRIVILEDGED
         TM    RSTCFLG,RSTTRUS      TEST FOR TRUSTED
         BZ    *+8                  ITS NOT
         MVI   MSG1+19,C'T'         INDICATE TRUSTED
         LA    R4,RSTELEN(0,R4)     POINT TO NEXT STC ENTRY
         BAL   R10,DISPLAY          PUT OUT NAME
         BCT   R5,STCNAM            LOOP WHILE MORE ENTRIES
FIN      EQU   *
         MOREND
DISPLAY  DS    0H
         SETMODE 24
         TPUT  MSG1,L'MSG1          PUT OUT INFORMATION
         MVI   MSG1,X'40'           A BLANK
         MVC   MSG1+1(L'MSG1-1),MSG1  CLEAR FIELD
         SETMODE 31
         MVI   MSG1,X'40'                 A BLANK
         MVC   MSG1+1(79),MSG1            BLANK IT OUT
         BR    R10                        RETURN
         SPACE
RSTCTITL DC    CL20'--NAME-- -USERID- --'
         SPACE
DSDT     DSECT
DSDTID   DC    CL4' '
DSDTNUM  DC    XL4'00'
DSDTDSDX DC    XL4'00'
DSDTVRSN DC    XL1'00'
DSDTFLAG DC    XL1'00'
         DC    XL2'00'
         DC    CL8' '
DSDTPLNM DC    CL48' '
DSDTPLTK DC    CL8' '
DSDTBLNM DC    CL48' '
DSDTBLTK DC    CL8' '
DSDTDSFL DC    CL1' '
DSDTDSMO DC    CL1' '
         DC    CL2' '
         DC    CL4' '
DSDTENTY DS    0CL80
DSDE     DSECT
DSDEDCB  DC    XL4'00'
DSDEDEB  DC    XL4'00'
DSDEINDX DC    XL4'00'
DSDEHDR  DC    XL4'00'
DSDEUCB  DC    XL4'00'
DSDEXLEN DC    XL4'00'
DSDEBAM  DC    XL4'00'
DSDEDSNL DC    XL1'00'
DSDESTAT DC    XL1'00'
DSDENREC DC    XL2'00'
DSDERXNO DC    XL1'00'
DSDEDSN  DC    CL44' '
DSDEDSNO DC    XL1'00'
DSDECBLN DC    XL2'00'
         SPACE
RSTCTAB  DSECT
RSTCENT  DC    H'0'
RSTCNAM  DC    CL8' '
RSTCUSR  DC    CL8' '
RSTCGRP  DC    CL8' '
RSTCFLG  DC    X'00'
RSTPRIV  EQU   X'80'
RSTTRUS  EQU   X'40'
RSTCRSV  DC    XL7'00'
RSTELEN  EQU   *-RSTCNAM
         SPACE
         ICHPRCVT
         CVT   DSECT=YES
         END
./ ADD NAME=RETCODE  0123-86142-07242-1131-00152-00020-00145-TCACF0  00
         TITLE '*** RETCODE ***'
RETCODE  MOWSTART
RETCODE  AMODE 31
RETCODE  RMODE ANY
**********************************************************************
* USEFUL FOR SETTING COND CODE TO TEST JCL CONDITIONAL STUFF BEFORE  *
* IMPLEMENTING IN PROCS ETC.                                         *
*                                                                    *
* IF PARM IS NOT PRESENT, RC IS SET TO DAY OF MONTH.                 *
* IF PARM IS NUMERIC, IT IS PUT IN R15 TO USE AS RETURN CODE FOR     *
*    SUBSEQUENT STEPS.                                               *
* IF PARM = SREL, TAKES SYSTEM RELEASE FROM FMID AND MAKES IT THE RC *
* IF PARM = SYSN, SETS RC BASED ON SYSID, FROM TABLE IN PROGRAM.     *
* IF PARM = J=NNNNN, WHERE NNNNN IS A JOB OR STARTED TASK NAME, THE  *
*    RC IS SET TO 4 IF THAT JOB IS FOUND RUNNING WHEN RETCODE IS     *
*    RUN.                                                            *
**********************************************************************
         L     R1,0(R1)                GET PARM
         LH    R2,0(R1)                LENGTH OF PARM FIELD
         LTR   R2,R2                   CHECK FOR ANY LENGTH
         BZ    SETDOM         NO PARM, USE DAY OF MONTH (1-31) AS RC
         LA    R1,2(R1)                POINT TO DATA PORTION
         BCTR  R2,0                    LESS ONE
         CLC   0(4,R1),=C'SREL'        REQUESTING SYSTEM RELEASE CC?
         BNE   SETNAM                  NO, TRY FOR SYSTEM NAME
         L     R3,CVTPTR               A(CVT)
         SH    R3,=H'256'              A(CVT PREFIX)
         USING CVTFIX,R3
         PACK  DOUBLE,CVTPRODI+4(3)    NUMERIC PORTION OF FMID
         CVB   R15,DOUBLE              MAKE IT NUMERIC
         B     FIN                     INDICATE SREL
         SPACE
SETNAM   EQU   *
         CLC   0(4,R1),=C'SYSN'        REQUESTING SYSTEM NAME CC?
         BNE   SETJOB                  NO, TRY FOR JOB NAME
         L     R2,CVTPTR               A(CVT)
         USING CVTMAP,R2
         L     R3,CVTECVT              POINT TO ECVT
         USING ECVT,R3                 BASE REG FOR ECVT
         L     R2,CVTSMCA              A(SMF COMM AREA)
         USING SMCABASE,R2
         LA    R5,SYSNAM               TABLE OF SYS NAMES
         LA    R4,NENT
SETNAM1  EQU   *
         CLC   0(4,R5),SMCASID         FOUND OUR ENTRY?
         BE    SETNAM2                 YES
         LA    R5,6(,R5)               NO, POINT TO NEXT ONE
         BCT   R4,SETNAM1              LOOP WHILE ENTRIES IN TABLE
         SPACE
SETNAM2  EQU   *
         LH    R15,4(,R5)              GET RC VALUE FROM TABLE
         CLC   SMCASID,=C'WETA'        CHECK FOR SPECIAL CASE
         BNE   FIN                     NOT A WETTERAU SYSTEM
         LA    R15,1(,R15)             ADD ONE
         CLC   =C'WETY2K',ECVTVMNM     WETTERAU Y2K GUEST
         BE    FIN                     SET RC BASED ON SYSTEM
         LA    R15,1(,R15)             ADD ONE
         CLC   =C'MVSTST',ECVTVMNM     WETTERAU TEST SYSTEM
         BE    FIN                     SET RC BASED ON SYSTEM
         B     FIN                     SHOULDN'T EVER DO THIS
         SPACE
SETJOB   EQU   *
         CLC   0(2,R1),=C'J='          REQUESTING JOB NAME TEST?
         BNE   SETVAL                  NO, CONVERT NUMERIC PARM
         SH    R2,=H'2'                R2 HAS LENGTH OF JOB NAME
         USING CVTFIX,R10              BASE REG FOR CVT
         USING ASCB,R8                 BASE REG FOR ASCB
         USING ASVT,R9                 BASE REG FOR ASVT
         LA    R15,4                   ASSUME JOB IS FOUND
         L     R10,CVTPTR              LOAD CVT BASE REG
         SH    R10,=H'256'             A(CVT PREFIX)
         L     R9,CVTASVT              AND ASVT BASE REG
         LA    R10,ASVTENTY-4          AND NOW POINT TO ASVT
         LA    R7,ASVTMAXU             POINT TO MAX NUM ASVTS
         L     R7,0(R7)                THERE NOW
SCANLIST EQU   *
         LA    R10,4(R10)              NEXT ASVTENTY
         CLI   0(R10),X'80'            TEST FOR ASID ASSIGNED
         BE    UNUSED                  ITS NOT IN USE
         L     R8,0(R10)               A(ASCB)
         L     R6,ASCBJBNI             POINTER TO JOB NAME
         LTR   R6,R6                   ZERO IF ITS A STC
         BNZ   GETNAME                 NOT ZERO SO ITS A JOB
         L     R6,ASCBJBNS             POINTER SO STC NAME
GETNAME  EQU   *
         EX    R2,CLCINS               CHECK FOR PARM JOB NAME
         BE    FIN                     EXIT SETTING RC TO SAY JOB FND
UNUSED   EQU   *
         BCT   R7,SCANLIST
         SR    R15,R15                 SET RC = 0, JOB NOT FOUND
         B     FIN                     RC BASED ON WHETHER JOB FOUND
CLCINS   CLC   0(*-*,R6),2(R1)         EXECUTED CLC
         SPACE
SETVAL   EQU   *
         O     R2,X'00000070'          LENGTH ONE
         EX    R2,PACK
         CVB   R15,DOUBLE              MAKE IT A BINARY
         B     FIN
         SPACE
SETDOM   EQU   *
         TIME  DEC,DOUBLE,DATETYPE=YYYYMMDD,LINKAGE=SYSTEM
         L     R2,RC           GET YYYYMMDD INTO A REGISTER
         N     R2,=X'000000FF' TURN OF YYYYMM
         SLL   R2,4            MAKE IT 00000DD0
         O     R2,=X'0000000F' MAKE IT 00000DDF
         XC    DOUBLE,DOUBLE   ZERO WORK AREA
         ST    R2,DOUBLE+4     SAVE IT
         CVB   R15,DOUBLE      SET RC = DAY NUMBER OF MOINTH
         SPACE
FIN      EQU   *
         MOREND RC=(15)
PACK     PACK  DOUBLE,0(0,R1) PACK IT
DOUBLE   DC    D'0'           DOUBLE MUST BE FOLLOWED BY RC
RC       DC    2F'0'          DDMMYYYY,0
         SPACE
         DS    0H             ALIGNMENT
SYSNAM   DC    C'WETA',H'4001'           WETTERAU PRODUCTION
         DC    C'WDRS',H'4002'           WETTERAU DISASTER RECOVERY
         DC    C'WTST',H'4003'           WETTERAU MVSTST
         DC    C'SV41',H'4004'           CORP
         DC    C'D03 ',H'4005'           .
         DC    C'??? ',H'4006'           .
         DC    C'SVT2',H'4007'           .
         DC    C'D01 ',H'4008'           .
         DC    C'D02 ',H'4009'           .
         DC    C'P01 ',H'4010'           .
         DC    C'P02 ',H'4011'           .
         DC    C'P03 ',H'4012'           .
         DC    C'P04 ',H'4013'           .
         DC    C'TIME',H'4014'           .
         DC    C'P0A ',H'4015'           .
         DC    C'P0B ',H'4016'           .
         DC    C'P0C ',H'4017'           .
         DC    C'P0D ',H'4018'           .
         DC    C'A1T1',H'4019'           BOISE
         DC    C'A1PA',H'4020'
         DC    C'A1PB',H'4021'
         DC    C'A1PC',H'4022'
         DC    C'A2P1',H'4023'
         DC    C'A2P2',H'4024'
         DC    C'A2P3',H'4025'
         DC    C'A2P4',H'4026'
         DC    C'A2P5',H'4027'
NENT     EQU   ((*-SYSNAM)/6)
         DC    C'----',H'4000'      STOPPER ENTRY AT NENT + 1
         EJECT
         CVT   DSECT=YES,PREFIX=YES
         IHAECVT
         IEESMCA
         IHAASCB
         IHAASVT
         END
./ ADD NAME=SHOWLPAR 0163-97225-08206-1007-00440-00411-00440-TCACF0  00
* GOES IN SYS2.LINKLIB, SETCODE AC(1)
*
* THIS PROGRAM DISPLAYS THE CURRENT PR/SM CONFIGURATION
* IT USES AN AUTHORIZATION SVC (SVC 235), BUT YOU CAN GET RID OF
* THE SVC AUTHORIZATION CALL BY CREATING AN ENTRY FOR SHOWLPAR IN
* IKJTSOXX TABLE (PARAMETER AUTHCMD OR AUTHPGM)
* THIS AN EXAMPLE OF THE DISPLAY YOU WILL GET :
*
* MODIFIED OCT 2006 FOR Z9. SHOWS ICF AND IFL SEPARATELY.
*
*---------------------------------------------------------------------
*! 03 PARTITIONS, 04 PHYSICAL PROCESSORS, CURRENT PARTITION IS MVS1  !
*! DISPATCH TIMES WERE EVALUATED ON A 1001 MILLISECONDS INTERVAL     !
*!                                                                   !
*!  MVSLOCA  : PARTITION NUMBER 01, 01 LOGICAL PROCESSORS            !
*!      CP    -WEIGHT-    W/A    DISPATCH                            !
*!      01      500       NO       17.0 %                            !
*!                                                                   !
*!  MVSPROD  : PARTITION NUMBER 02, 03 LOGICAL PROCESSORS            !
*!      CP    -WEIGHT-    W/A    DISPATCH                            !
*!      01      DED       YES      99.1 %                            !
*!      02      DED       YES     101.7 %                            !
*!      03      DED       YES      99.5 %                            !
*!                                                                   !
*!  MVSTEST  : PARTITION NUMBER 03, 01 LOGICAL PROCESSORS            !
*!      CP    -WEIGHT-    W/A    DISPATCH                            !
*!      01      500       NO        1.8 %                            !
*---------------------------------------------------------------------
         MACRO
&NLA     SUBDW  &D1,&D2
&NLA     DS     0H
.* THIS MACRO SUBTRACTS 2 UNSIGNED DOUBLE-WORDS D1, D2
.* (D1 MUST BE >= D2)
.* RETURNS D1=D1-D2
         MNOTE  '** THIS MACRO USES REGS 0 - 1 **'
         L      0,&D1        1ST DOUBLE-WORD
         L      1,&D2        2ND DOUBLE-WORD
         SLR    0,1          SUBTRACT
         ST     0,&D1        STORE THE RESULT
         L      0,&D1+4      1ST DOUBLE-WORD
         L      1,&D2+4      2ND DOUBLE-WORD
         SLR    0,1          SUBTRACT
         CLC    &D1+4(4),&D2+4     COMPARE
         BH     DIFP&SYSNDX
         L      1,&D1        THE 1ST RESULT WAS TOO BIG
         S      1,=F'1'      DECREMENT
         ST     1,&D1        STORE AGAIN 1ST RESULT
DIFP&SYSNDX     DS  0H
         ST     0,&D1+4
         MEND
SHOWLPAR CSECT
SHOWLPAR AMODE  31
SHOWLPAR RMODE  24
         SAVE   (14,12),,SHOWLPAR-&SYSDATE-&SYSTIME
         LR     R12,R15
         USING  SHOWLPAR,R12
         LR     R9,R13
         LA     R13,SAVE
         ST     R13,8(R9)
         ST     R9,4(R13)
* OBTAIN 1 PAGE AND FIX IT (FOR THE PRSM BUFFER)
*        LA     R0,1                   AUTHORIZATION SVC : AUTH ON
*        SVC    235                    AUTHORIZATION SVC : AUTH ON
         MODESET  MODE=SUP,KEY=ZERO
         GETMAIN  RU,LV=4096,BNDRY=PAGE     GETMAIN 1 PAGE
         LR     R8,R1                  KEEP ADDRESS OF PAGE
         L      R7,=F'4096'
         AR     R7,R8                  END ADDRESS
         PGFIX  R,A=(R8),ECB=0,EA=(R7) FIX THE PAGE FOR DIAGNOSE
         ST     R15,RETCODE
         MODESET  MODE=PROB,KEY=NZERO
*        XR     R0,R0                  AUTHORIZATION SVC : AUTH OFF
*        SVC    235                    AUTHORIZATION SVC : AUTH OFF
         L      R1,RETCODE             TEST RC FROM FIX
         LTR    R1,R1
         BZ     FIX0
         TPUT   =C'** BAD RETURN CODE AFTER PGFIX **',33
         B      END0
* ISSUE DIAGNOSE INSTRUCTION TO GET PRSM DATA (FIRST PASS)
FIX0     DS     0H
         L      R6,16                  A(CVT)
         USING  CVT,R6
         L      R7,CVTPCCAT            POINT TO PCCA
         LA     R3,16                  MAX NUM CPUS
         LA     R5,ATTRTAB             POINT TO ATTRIBUTE TABLE
LOOP     EQU    *
         ICM    R4,B'1111',0(R7)       A(PCA) FOR CPU
         USING  PCCA,R4
         MVC    0(1,R5),PCCAATTR       SAVE ATTRIBUTE OF CPU
         LA     R7,4(,R7)              POINT TO NEXT CPU PCCA
         LA     R5,1(,R5)              POINT TO NEXT ATTR SLOT
         BCT    R3,LOOP                LOOP WHILE CPUS TO DO
*        LA     R0,1                   AUTHORIZATION SVC : AUTH ON
*        SVC    235                    AUTHORIZATION SVC : AUTH ON
         MODESET  MODE=SUP,KEY=ZERO
         LRA    R1,0(R8,0)             LOAD REAL ADDRESS OF BUFFER
         LA     R0,4                   GET INFORMATION FROM PRSM
         DC     X'83',X'10',X'0204'    DIAGNOSE CODE 0204
         LTR    R0,R0                  EXECUTION CORRECT ?
         BNZ    ITSBAD                 NO
         MODESET  MODE=PROB,KEY=NZERO
*        XR     R0,R0                  AUTHORIZATION SVC : AUTH OFF
*        SVC    235                    AUTHORIZATION SVC : AUTH OFF
* STORE CPU DISPATCH TIMES IN THE TABLE
         LR     R5,R8
         USING  DDBL1,R5
* PROCESS 1 PARTITION
         XR     R9,R9
         IC     R9,DDBNUMCP            HOW MANY PARTITIONS ?
         LTR    R9,R9
         BZ     END0                   NO PARTITION
         MVC    DW1,DDBTODCK
         LR     R4,R5
         LA     R4,(PRPRFLEN)(0,R4)    ACCESS TO 1ST PARTITION
         DROP   R5
         USING  DDBPPDTA,R4
         LA     R9,1(0,R9)             # OF PART + FOR 'PHYSICAL' PART
LOPPART0 DS     0H
         IC     R1,DDBLPNN             PARTITION NUMBER
         STC    R1,PARTNO              STORE
* PROCESS 1 LOGICAL PROCESSOR IN 1 PARTITION
         XR     R3,R3
         IC     R3,DDBNMVP             HOW MANY PROCESSORS ?
         LA     R4,(PRPALENG)(0,R4)    ACCESS 1ST PROC. IN PARTITION
         LTR    R3,R3                  NONE ?
         BZ     NXTPART                YES, PARTITION DEACTIVATED
         DROP   R4
         USING  DDBVPDBS,R4
LOPPROC0 DS     0H
* STORE DISPATCH TIMES IN THE TABLE
         LA     R2,TABLE
         XR     R1,R1
         ICM    R1,B'0011',DDBVPADR    PROCESSOR NUMBER
         SLL    R1,3                   X8 (SIZE OF AN ENTRY)
         AR     R2,R1                  + ADDRESS OF TOP OF TABLE
         XR     R1,R1                  CLEAR R1
         IC     R1,PARTNO              PARTITION NUMBER
         SLL    R1,7                   X8 X16 (16 PROC. MAXIMUM)
         AR     R2,R1                  + ADDRESS
         MVC    0(8,R2),DDBPDTIM       DISPATCH TIME COPIED IN TABLE
         LA     R4,(PRPRLENG)(0,R4)    ACCESS TO NEXT PROCESSOR ENTRY
         BCT    R3,LOPPROC0            PROCESS NEXT PROCESSOR
NXTPART  BCT    R9,LOPPART0            PROCESS NEXT PARTITION
* WAIT 1 SECOND BEFORE GETTING NEW STATISTICS
         STIMER WAIT,,DINTVL=INT
* RE-ISSUE DIAGNOSE INSTRUCTION (SECOND PASS)
*        LA     R0,1                   AUTHORIZATION SVC : AUTH ON
*        SVC    235                    AUTHORIZATION SVC : AUTH ON
         MODESET  MODE=SUP,KEY=ZERO
         LRA    R1,0(R8,0)             LOAD REAL ADDRESS
         LA     R0,4
         DC     X'83',X'10',X'0204'    DIAGNOSE CODE 0204
         LTR    R0,R0
         BNZ    ITSBAD
         MODESET  MODE=PROB,KEY=NZERO
*        XR     R0,R0                  AUTHORIZATION SVC : AUTH OFF
*        SVC    235                    AUTHORIZATION SVC : AUTH OFF
* SECOND PASS, PROCESS DATA IN THE BUFFER
         LR     R5,R8
         USING  DDBL1,R5
         MVC    DW2,DDBTODCK
* COMPUTE THE EXACT LENGTH OF THE TIME INTERVAL
         SUBDW  DW2,DW1            SUBTRACT THE 2 DOUBLE WORDS
         LM     R0,R1,DW2
         SRDL   R0,12              GET TIME IN MICROSECONDS
         D      R0,=F'1000'        THEN IN MILLISECONDS
         ST     R1,INTREAL         STORE TIME INTERVAL LENGTH
         CVD    R1,DW1             CONVERSION TO PACKED DECIMAL
         UNPK   OUT,DW1            AND TO DECIMAL ZONED
         OI     OUT+L'OUT-1,X'F0'  NORMALIZE THE SIGN
* HOW MANY PARTITIONS ?
         XR     R0,R0
         IC     R0,DDBNUMCP        LOAD NUMBER OF PARTITIONS
         CVD    R0,DW1             CONVERSION TO PACKED DECIMAL
         UNPK   NBPART,DW1         AND TO DECIMAL ZONED
         OI     NBPART+L'NBPART-1,X'F0'   NORMALIZE THE SIGN
* HOW MANY PHYSICAL PROCESSORS ?
         XR     R0,R0
         ICM    R0,B'0011',DDBNUMPP        LOAD NUMBER OF PARTITIONS
         CVD    R0,DW1             CONVERSION TO PACKED DECIMAL
         UNPK   NBPROC,DW1         AND TO DECIMAL ZONED
         OI     NBPROC+L'NBPROC-1,X'F0'   NORMALIZE THE SIGN
         LR     R4,R5
         AH     R4,DDBORGPN        OFFSET TO CURRENT PARTITION
         MVC    PARTCUR,(DDBPRNAM-DDBPPDTA)(R4)       NAME OF PARTITION
         TPUT   MSG1,LMSG1         HOW MANY PARTITIONS AND PROCESSORS
         TPUT   MSG2,LMSG2         HOW LONG IS THE TIME INTERVAL ?
* PROCESS 1 PARTITION
         XR     R9,R9
         IC     R9,DDBNUMCP        NUMBER OF PARTITIONS
         LTR    R9,R9
         BZ     END0               NO PARTITION
         LR     R4,R5
         LA     R4,(PRPRFLEN)(0,R4)    ACCESS TO 1ST PARTITION
         DROP   R5
         USING  DDBPPDTA,R4
         LA     R9,1(0,R9)             # OF PART + FOR 'PHYSICAL' PART
LOPPART  DS     0H
* WHAT IS THE PARTITION NUMBER ?
         XR     R0,R0
         IC     R0,DDBLPNN              PARTITION NUMBER
         CVD    R0,DW1                  CONVERSION TO PACKED DECIMAL
         UNPK   NPART,DW1               AND TO DECIMAL ZONED
         OI     NPART+L'NPART-1,X'F0'   NORMALIZE THE SIGN
         MVC    NPARTX+1(1),DDBLPNN     PARTITION NUMBER
         UNPK   NPARTX(1),NPARTX+1(1)
         NC     NPARTX(2),=2X'0F'
         TR     NPARTX(2),=C'0123456789ABCDEF'       MAKE IT HEX
* HOW MANY LOGICAL PROCESSORS FOR THIS PARTITION ?
         XR     R0,R0
         IC     R0,DDBNMVP         PROCESSORS
         CVD    R0,DW1             CONVERSION TO PACKED DECIMAL
         UNPK   NPROC,DW1          AND TO DECIMAL ZONED
         OI     NPROC+L'NPROC-1,X'F0'   NORMALIZE THE SIGN
* STATUS OF THE PARTITION (ACTIVE / INACTIVE)
         MVC    STATUS,=C'               '
         CLI    DDBNMVP,X'00'      NO PROCESSOR ?
         BNE    PROCNONE
         MVC    STATUS,=C' ** INACTIVE **'
PROCNONE DS     0H
         MVC    PARTN,DDBPRNAM     NAME OF PARTITION
         TPUT   =C' ',1            SKIP 1 LINE
         TPUT   MSG3,LMSG3
         IC     R1,DDBLPNN         PARTITION NUMBER
         STC    R1,PARTNO          STORED
* PROCESS 1 PROCESSOR FOR 1 PARTITION
         XR     R3,R3
         IC     R3,DDBNMVP         HOW MANY PROCESSORS ?
         LA     R4,(PRPALENG)(0,R4)  ACCESS 1ST PROCESSOR IN PARTITION
         LTR    R3,R3              NONE ?
         BZ     NEXTPART           YES, PARTITION WAS DEACTIVATED
         TPUT   =C'       CP    -WEIGHT-    W/A    DISPATCH  CAPPED',48
         DROP   R4
         USING  DDBVPDBS,R4
LOPPROC  DS     0H
* LOGICAL PROCESSOR NUMBER
         XR     R1,R1              R1 = 0
         ICM    R1,B'0011',DDBVPADR    LOGICAL PROCESSOR NUMBER
         CVD    R1,DW1             CONVERT TO PACKED
         UNPK   NOPROC,DW1         AND TO DECIMAL ZONED
         OI     NOPROC+L'NOPROC-1,X'F0'     NORMALIZE THE SIGN
         LA     R2,ATTRTAB         POINT TO ATTRIBUTE TABLE
         AR     R2,R1              AND ENTRY FOR THIS PROCESSOR
* WEIGHT OF THE PROCESSOR
         LH     R1,DDBPRELS        WEIGHT OF THIS PROCESSOR
         CVD    R1,DW1             CONVERT TO PACKED
         MVC    WEIGHT,=X'4020202020202020'    MASK FOR INSTRUCTION ED
         ED     WEIGHT,WORD        CONVERT TO DECIMAL ZONED
* WAIT ASSIST
         MVC    ASSIST,=CL3'NO'
         TM     DDBVPFGS,DDBWSTAS  WAIT ASSIST=YES?
         BNO    NOWASST            NO
         MVC    ASSIST,=CL3'YES'   YES
NOWASST  DS     0H
* CAPPED
         MVC    CAPPED,=CL3'NO'
         TM     DDBVPFGS,DDBCAPFL  CAPPED?
         BNO    NOCAPPED           NO
         MVC    CAPPED,=CL3'YES'   YES
NOCAPPED DS     0H
* DISPATCH TIME PERCENTAGE
         MVC    DISPPC,=CL5'?????' PERCENT DISPATCH TIME UNKNOWN
* WEIGHT OF THE PROCESSOR
         CLC    DDBPRELS,=H'-1'    WEIGHT = X'FFFF' ?
         BNE    NOTDEDIC                 NO
         MVC    WEIGHT,=CL8'     DED'    YES : DEDICATED PROCESSOR
NOTDEDIC DS     0H
* PROCESSOR USE
         L      R6,16                  A(CVT)
         USING  CVT,R6
         L      R6,CVTHID              HOST ID
         USING  SHID,R6
         MVC    PUSE(7),=CL7' IFL'     MAYBE ITS AN IFL?
         CLC    CPCND_TYPE+2(4),=C'2094'  2064/2084/2094/....
         BE     *+10
         MVC    PUSE(7),=CL7' ICF'
         CLI    DDBPTYPE,DDBPIFL       CHECK PROCESSOR TYPE
         BE     GOTTYPE                IT IS AN IFL
*        MVC    PUSE(7),=CL7'ZIIP'     MAYBE ITS A ZIIP?
*        TM     0(R2),PCCAZIIP         ZIIP?
*        BO     GOTTYPE                IT IS A ZIIP
*        MVC    PUSE(7),=CL7'ZAAP'     MAYBE ITS A ZAAP?
*        TM     0(R2),PCCA_BYLPAR_ZAAP  ZAAP?
*        BO     GOTTYPE                IT IS A ZAAP
         MVC    PUSE(7),=CL7' ICF'     MAYBE ITS AN ICF?
         CLI    DDBPTYPE,DDBPICF       CHECK FOR PROCESSOR USE TYPE
         BE     GOTTYPE                IT IS AN ICF
         MVC    PUSE(7),=CL7'  OS'     OTHERWISE IT MUST BE A GP/OS
GOTTYPE  EQU    *
* COMPUTE CPU UTILIZATION FROM TABLE
         LA     R2,TABLE
         XR     R1,R1
         ICM    R1,B'0011',DDBVPADR    PROCESSOR NUMBER
         SLL    R1,3               X 8
         AR     R2,R1              + BEGINNING OF TABLE
         XR     R1,R1
         IC     R1,PARTNO          PARTITION NUMBER
         SLL    R1,7               X 8   X 16
         AR     R2,R1              + BEGINNING OF TABLE
         MVC    DW1,0(R2)          LAST DISPATCH TIME
         MVC    DW2,DDBPDTIM       PRESENT DISPATCH TIME
         CLC    DW1,DW2            COMPARE OLD AND NEW DISPATCH TIMES
         BNL    NOCALC             IF OLD > NEW, ABNORMAL
         CLI    DDBPTYPE,DDBPICF * ICF???
         BE     NOCALC           *
         SUBDW  DW2,DW1            SUBTRACT THEM
         LM     R0,R1,DW2          LOAD MICROSECONDS
         D      R0,INTREAL         DIVIDE BY TIME INTERVAL LENGTH
         CVD    R1,DW1             CONVERT TO PACKED
         UNPK   DISPP,DW1          AND TO DECIMAL ZONED
         OI     DISPP+L'DISPP-1,X'F0'     NORMALIZE THE SIGN
         MVC    DISPPC(3),DISPP               100
         MVI    DISPPC+3,C'.'                    .
         MVC    DISPPC+4(1),DISPP+3               0
         CLI    DISPPC,C'0'        REPLACE LEADING ZEROES ...
         BNE    NOCALC
         MVI    DISPPC,C' '                              ... BY BLANKS
         CLI    DISPPC+1,C'0'      REPLACE LEADING ZEROES ...
         BNE    NOCALC
         MVI    DISPPC+1,C' '                            ... BY BLANKS
NOCALC   DS     0H
* DISPLAY AN INFORMATION LINE ABOUT THE PROCESSOR USED BY THE PARTITION
         TPUT   MSG4,LMSG4
         LA     R4,(PRPRLENG)(0,R4)    NEXT PROCESSOR
         BCT    R3,LOPPROC
NEXTPART BCT    R9,LOPPART
         B      END0
ITSBAD   DS     0H
         MODESET  MODE=PROB,KEY=NZERO
*        XR     R0,R0                  AUTHORIZATION SVC : AUTH OFF
*        SVC    235                    AUTHORIZATION SVC : AUTH OFF
         TPUT   =C'** ERROR AFTER DIAGNOSE **',26
END0     DS     0H
* FREE THE ALLOCATED PAGE
*        LA     R0,1                   AUTHORIZATION SVC : AUTH ON
*        SVC    235                    AUTHORIZATION SVC : AUTH ON
         MODESET  MODE=SUP,KEY=ZERO
         L      R7,=F'4096'
         AR     R7,R8                       END ADDRESS
         PGFREE R,A=(R8),ECB=0,EA=(R7)      UNFIX PAGE IN MEMORY
         FREEMAIN   RC,LV=4096,A=(8)
         MODESET  MODE=PROB,KEY=NZERO
*        XR    R0,R0                  AUTHORIZATION SVC : AUTH OFF
*        SVC   235                    AUTHORIZATION SVC : AUTH OFF
END      DS    0H
         L     R13,4(R13)
         RETURN (14,12),T,RC=0
         LTORG
INT      DC    CL8'00000100'          WAIT INTERVAL : 1 SECOND
RETCODE  DS    F                      RETURN CODE FROM PGFIX
ATTRTAB  DC    XL16'00'               ATTRIBUTE FLAG FOR EACH PROCESSOR
MSG1     DC    CL2' '
NBPART   DS    CL2
         DC    C' PARTITIONS, '
NBPROC   DS    CL2
         DC    C' PHYSICAL PROCESSORS, CURRENT PARTITION IS '
PARTCUR  DS    CL8
LMSG1    EQU   *-MSG1
MSG2     DC    C'  DISPATCH TIMES WERE EVALUATED ON A '
OUT      DS    CL4
         DC    C' MILLISECONDS INTERVAL'
LMSG2    EQU   *-MSG2
MSG3     DC    CL3' '
PARTN    DS    CL8
         DC    C' : PARTITION NUMBER '
NPART    DS    CL2
         DC    CL4' (X'''
NPARTX   DC    CL2'  '
         DC    C'''), '
NPROC    DS    CL2
         DC    C' LOGICAL PROCESSORS     '
STATUS   DC    CL15' '
LMSG3    EQU   *-MSG3
MSG4     DC    CL7' '
NOPROC   DS    CL2
         DC    C' '
WEIGHT   DS    CL8
         DC    CL7' '
ASSIST   DS    CL3
         DC    CL5' '
DISPPC   DS    CL5     % DISPATCH TIME FROM 000.0 TO 100.0 (OR MORE)
         DC    C' %'
         DC    CL4' '
CAPPED   DS    CL3' '
         DS    CL4' '
PUSE     DC    CL7' '
LMSG4    EQU   *-MSG4
INTREAL  DS    F       TIME INTERVAL LENGTH
PARTNO   DS    CL1
DISPP    DS    CL4     % DISPATCH TIME FROM 0000 TO 1000 (OR MORE...)
DW1      DS    D       DOUBLE-WORD FOR WORK
         ORG   DW1+4
WORD     DS    F
DW2      DS    D       DOUBLE-WORD FOR WORK
* WE STORE PROCESSOR DISPATCH TIMES IN THIS TABLE
TABLE    DS    0CL2048          16 PARTITIONS X 16 PROCESSORS X 8C
         DC    2048X'00'        16 PARTITIONS X 16 PROCESSORS X 8C
SAVE     DS    16F
* THIS DSECT DESCRIBES THE CONTENTS OF THE PR/SM BUFFER (OCO)
* RETURNED BY THE DIAGNOSE X'204' INSTRUCTION. MAPPED BY ERBDDBL1.
* DOC IS IN RMF DATA AREAS, LY28-1303
DDBL1    DSECT
* HEADER
DDBNUMCP DS    CL1     HOW MANY PARTITIONS
DDBFLAG1 DS    CL1     TIMER INFORMATION BLOCK HEADER FLAGS
DDBGTMSL DS    CL2     TIME SLICE
DDBNUMPP DS    CL2     HOW MANY PHYSICAL PROCESSORS
DDBORGPN DS    H       OFFSET TO ENTRY FOR CURRENT PARTITION
DDBTODCK DS    D       TOD
PRPRFLEN EQU   (*-DDBL1)
* ENTRY FOR PARTITION
DDBPPDTA DS    0F
DDBLPNN  DS    CL1     PARTITION NUMBER
DDBNMVP  DS    CL1     HOW MANY LOGICAL PROCESSORS FOR THIS PARTITION
         DS    CL6     RESERVED
DDBPRNAM DS    CL8     NAME OF THE PARTITION
PRPALENG EQU   (*-DDBPPDTA)
* ENTRY FOR LOGICAL PROCESSOR IN USE BY THE PARTITION
DDBVPDBS DS    0F
DDBVPADR DS    CL2     LOGICAL PROCESSOR NUMBER
         DS    CL2     RESERVED
DDBPTYPE DS    CL1     PROCESSOR TYPE
DDBPSTD  EQU   X'00'   GENERAL PURPOSE PROCESSOR
DDBPAAP  EQU   X'01'   ZAAP PROCESSOR ???
DDBPIIP  EQU   X'02'   ZIIP PROCESSOR ???
DDBPIFL  EQU   X'03'   IFL PROCESSOR
DDBPICF  EQU   X'04'   ICF PROCESSOR
DDBVPFGS DS    CL1     FLAG (WAIT ASSIST, ETC)
DDBWSTAS EQU   X'80'   WAIT COMPLETION FLAG
DDBCAPFL EQU   X'40'   PARTITION CAPPING FLAG
DDBPRELS DS    H       WEIGHT OF PARTITION - X'FFFF' MEANS DEDICATED
DDBPDTIM DS    D       TIME A LOGICAL PROC. WAS DISPATCHED ON A PHYS.
DDBEFFDT DS    CL8
PRPRLENG EQU   (*-DDBVPDBS)
         PRINT NOGEN
         CVT   DSECT=YES
         IHAPCCA
         IOSDSHID                      SYSTEM HOST ID MAPPING
         REQU
         END
./ ADD NAME=SMFDS    0100-03311-03311-1200-00185-00185-00000-FILE066 00
SMFDS    MOWSTART
SMFDS    AMODE 31
SMFDS    RMODE 24
**********************************************************************
* PROGRAM EMULATES THE OPERATOR D SMF COMMAND FOR TSO USERS.         *
* ALSO IF PARM IS 'CA7', IS USED TO DEMAND A DUMP JOB FOR ANY DATA-  *
* SETS FOUND WHICH HAVE THE DUMP REQUIRED BIT ON.                    *
* GOES IN FIELD.TEST.LOAD                                            *
**********************************************************************
         L     R1,0(R1)             PARM POINTER
         LH    R2,0(R1)             GET PARM LENGTH
         LTR   R2,R2                ANY LENGTH?
         BZ    TSOONLY              NO
         CLC   2(3,R1),=C'CA7'      PARM SAYS CA7?
         BNE   TSOONLY              NO, SO JUST DO TSO
         OI    FLAG,CA7OPT          SET FLAG FOR CA7 OPTION PRESENT
TSOONLY  EQU   *
         SR    R11,R11              USE THIS REG FOR A RETURN CODE
         L     R4,16                CVT
         LR    R6,R4                COPY ADDRESS
         S     R6,=F'32'            BACK UP TO CVTPRODI (HBB5510)
         CLI   3(R6),C'4'           IS THIS REL 4?
         BNE   *+8                  NO
         OI    FLAG,MVSREL4         SET MVS REL 4 FLAG
         CLI   3(R6),C'5'           IS THIS REL 5?
         BNE   *+8                  NO
         OI    FLAG,MVSREL5         SET MVS REL 5 FLAG
         CLI   3(R6),C'6'           IS THIS REL 6?
         BNE   *+8                  NO
         OI    FLAG,MVSREL5         SET MVS REL 6 FLAG
         CLI   3(R6),C'7'           IS THIS REL 7
         BNE   *+8                  NO
         OI    FLAG,MVSREL5         SET MVS REL 7 FLAG
         OI    FLAG,MVSREL5         SET MVS REL 5/6/7 FLAG
         L     R6,196(0,R4)         CVTSMCA
         USING SMCABASE,R6
         TM    SMCAMISC,SMCAUSER    SMF RECORDING REQUESTED
         BO    SMFIN                YES, SKIP MESSAGE
         TPUT  SMFOFF,80                 TELL USER SMF IS INACTIVE
         B     FIN                       AND QUIT
SMFIN    EQU   *
         L     R5,SMCALRDS               A(LAST RDS).
         L     R4,SMCAFRDS               A(1ST RDS).
         USING IEEMBRDS,R4     RDS IS DESCRIBED IN FICHE FOR IFADSMF.
         L     R1,SMCAACTP               A(ACT)
         USING IEEMBACT,R1
         MVC   SMFTITLE+75(2),ACTMEMID   PARMLIB MEMBER SUFFIX
         TPUT  SMFTITLE,80               DISPLAY TITLE RECORD
MORSMFDS EQU   *
         LA    R14,10                    DSN LENGTH MVS REL 4
         TM    FLAG,MVSREL4              MVS REL 4?
         BO    *+8                       SKIP THE IC INSTR
         IC    R14,RDSNLEN               GET LENGTH OF DSN
         BCTR  R14,0                     REDUCE FOR EXECUTED MOVE
         EX    R14,MVCRDSNM              PUT SMF DSNAME IN MESSAGE
         MVC   SMFDMND+33(1),SMFANS+8    GET LAST CHAR FROM SMF DSN
         TM    FLAG,MVSREL4              MVS REL 4?
         BZ    *+10
         MVC   SMFVOL(6),RDS4VOL         SMF DATASET VOLSER
         TM    FLAG,MVSREL5              MVS REL 5?
         BZ    *+10
         MVC   SMFVOL(6),RDS5VOL         SMF DATASET VOLSER
         MVC   SMFSTAT(9),=C'ALTERNATE'
         TM    RDSFLAG,X'04'             DS ACTIVE?
         BO    *+10                      NO
         MVC   SMFSTAT(9),=C'ACTIVE   '
         TM    RDSFLAG,X'08'             DUMP REQD?
         BZ    NODUMP                    NO
         MVC   SMFSTAT(9),=C'DUMP REQD'
         IC    R11,SMFANS+8              GET MAN NUMBER (1, 2, 3)
         N     R11,=X'0000000F'          MAKE IT NUMERIC ONLY
         TM    FLAG,CA7OPT               IS THIS FLAG ON?
         BZ    NODUMP                    NO, SO DON'T TRY TO DEMAND IT
* AT IPL IEFU29 DOES A DEMAND, CHECK IF THIS IS CLOSE TO AN IPL
* AND IF SO DON'T DO THE DEMAND.
*        L     R2,SMCAITME          GET IPL TIME FROM SMCA
*        A     R2,=A(15*6000)       ADD 15 MINUTES * 60 1/100 SECONDS
*        TIME  BIN                  GET CURRENT TIME
*        CR    R0,R2                WITHIN 15 MINS OF IPL?
*        BL    FIN                  YES - DON'T DEMAND SMF DUMP JOB
         LA    R1,=A(CA7PARM)       POINT TO PARM LIST
         LINK  EP=U7SVC             AND DEMAND IN JOB
         B     FIN                  AND LEAVE
NODUMP   EQU   *
         TM    RDSFLAG,X'02'        CLOSE PENDING?
         BZ    *+10                 NO
         MVC   SMFSTAT(9),=C'CLOSE PDG'
         TM    RDSFLAG+1,X'60'      I/O ERROR
         BZ    *+10                 NO
         MVC   SMFSTAT(9),=C'I/O ERROR'
         SR    R14,R14              CLEAR FOR DIVIDE
         TM    FLAG,MVSREL4         MVS REL 4?
         BZ    *+8                  NO
         L     R15,RDS4NXT          SMF DS NEXT BLOCK
         TM    FLAG,MVSREL5         MVS REL 5?
         BZ    *+8                  NO
         L     R15,RDS5NXT          SMF DS NEXT BLOCK
         BCTR  R15,0
         CVD   R15,DOUBLEB
         M     R14,=F'100'
         TM    FLAG,MVSREL4         MVS REL 4?
         BZ    *+8                  NO
         L     R1,RDS4CAP           SMF DS CAPACITY
         TM    FLAG,MVSREL5         MVS REL 5?
         BZ    *+8                  NO
         L     R1,RDS5CAP           SMF DS CAPACITY
         CVD   R1,DOUBLEA
         DR    R14,R1               PERCENT FULL
         CVD   R15,DOUBLEC
         MVC   SMFANSOA(10),=X'40206B2020206B202120'
         ED    SMFANSOA(10),DOUBLEA+4
         MVC   SMFANSOB(10),=X'40206B2020206B202120'
         ED    SMFANSOB(10),DOUBLEB+4
         MVC   SMFANSOC(4),=X'40202120'
         ED    SMFANSOC(4),DOUBLEC+6
         TPUT  SMFANS,80
         L     R4,RDSNEXT           NEXT RDS ON CHAIN
         CR    R5,R4                END OF CHAIN YET?
         BNE   MORSMFDS             NO, MORE DATASETS TO LOOK AT
FIN      EQU   *
         MOREND RC=(11)
DOUBLEA  DC    D'0'
DOUBLEB  DC    D'0'
DOUBLEC  DC    D'0'
MVCRDSNM MVC   SMFANS(*-*),RDSNAME     MOVE SMF DATASET NAME
SMFOFF   DC    CL80'SMF RECORDING INACTIVE'
SMFTITLE DC    CL80'SMF DATASET     VOLSER --STATE-- BLKS ALLOC   BLK U*
               SED % FULL. MEM = SMFPRMXX'
*                   0123456789 123456789 123456789 123456789 123456789
*              123456789 123456789 123456789
SMFANS   DS    0CL80' '
         DC    CL16'SYS1.MAN?       '
SMFVOL   DC    CL07'VOLSER '
SMFSTAT  DC    CL10'ACTIVE'
SMFANSOA DC    CL11' X,XXX,XXX '       BLKS ALLOCATED'
SMFANSOB DC    CL11' X,XXX,XXX '       BLKS USED
SMFANSOC DC    CL05' XXX '             % FULL
         DC    CL(80-(*-SMFANS))' '
         DS    0H
CA7PARM  DC    AL2(CA7PARML)
*                0123456789 123456789 123456789 123456789
SMFDMND  DC    C'/LOGON SVCUSER;DEMAND,JOB=SMFDUMP?;/LOGOFF'
CA7PARML EQU   *-SMFDMND
FLAG     DC    X'00'
CA7OPT   EQU   X'80'
MVSREL4  EQU   X'40'         MVS RELEASE 4
MVSREL5  EQU   X'20'         MVS RELEASE 5
         SPACE
IEEMBACT DSECT               SMF ACT - DERIVED FROM FICHE OF IEEMB833
ACTID    DC    CL4'ACT '     EYECATCHER - ACT
ACTSRCP  DC    XL4'00'       A(INPUT TO PARSE)
ACTMSDCB DC    XL4'00'       A(MESSAGE DATASET DCB)
ACTPLDCB DC    XL4'00'       A(PARMLIB DCB)
ACTOCB   DC    XL4'00'       A(1ST OCB ON CHAIN)
ACTDSNAM DC    XL4'00'
ACTOCBPL DC    XL4'00'       A(OCB BUFFER POOL)
ACTCONID DC    CL4' '        CONSOLE ID
ACTAREA  DC    XL1'00'       CONSOLE AREA ID
ACTALTCN DC    CL4' '        ALTERNATE CONSOLE ID
ACTALTAR DC    XL1'00'       ALTERNATE CONSOLE AREA
ACTRSVD1 DC    XL2'00'
ACTOPTAB DC    XL4'00'       A(OPTION TABLE)
ACTFLAGS DC    XL2'00'
ACTMEMID DC    CL2'00'       SMFPRMXX PARMLIB MEMBER SUFFIX
         SPACE
IEEMBRDS DSECT               SMF RECORDING DATASET DSECT
RDSID    DS    CL4'RDS '     EYECATCHER
RDSNEXT  DS    F             POINTER TO NEXT RDS
         DS    F             POINTER TO PREVIOUS RDS?
RDSFLAG  DS    3X'00'        FLAGS
RDSNLEN  DS    X'00'         LENGTH OF RDSNAME
RDSNAME  DS    CL44          DATASET NAME
RDS5VOL  DS    CL6           VOLSER
         DS    H'0'          ?
RDS5DDN  DS    CL8           DDNAME?
RDS5CAP  DS    F             DATASET CAPACITY
RDS5NXT  DS    F
         ORG   RDSNAME+10
RDS4VOL  DS    CL6           VOLSER
RDS4DDN  DS    CL8           DDNAME?
RDS4CAP  DS    F             DATASET CAPACITY
RDS4NXT  DS    F
         SPACE
         IEESMCA
         END
./ ADD NAME=SMFSRCH  0108-09070-09120-1257-00891-00831-00103-TCACF0  00
         TITLE 'SMF SEARCH PROGRAM'
***********************************************************************
* CONTROL CARD FORMAT:                                                *
*  'A'  - INDICATES AN ACCESS REFFERENCE ( REQUIRED ).                *
*  'P'  - INDICATES A PARTIAL DSNAME FOLLOWS.                         *
*  'M'  - INDICATES A MEMBER NAME FOLLOWS                             *
*  'D=' - SPECIFIES THE DATA SET NAME ( OPTIONAL IF J= PRESENT ).     *
*  'F=' - SPECIFIES THE OMVS FILE/DIRECTORY.                          *
*  'J=' - SPECIFIES THE JOB NAME ( OPTIONAL IF D= PRESENT ).          *
*  'M=' - SPECIFIES THE MEMBER NAME FOR ADD/REN/DEL.                  *
*  'T=' - SPECIFIES THE ACCESS TYPE:                                  *
*         ( OPTIONAL AND '15' IS THE DEFAULT (ALL ACCESS) ).          *
*                         '1' = READ,                                 *
*                         '2' = UPDATE,                               *
*                         '4' = SCRATCHED,                            *
*                         '8' = RENAMED,                              *
*                               OR THE ADDITION OF ANY OF THE ABOVE.  *
* ------------------------------------------------------------------- *
* SMF RECORD TYPES:                                                   *
*    14 - INPUT                                                       *
*    15 - OUTPUT                                                      *
*    17 - SCRATCH                                                     *
*    18 - RENAME                                                      *
*    42 - PDS/PDSE MEMBER ADD/RENAME/DELETE                           *
*    61 - IF ACTCODE = 'IN' THEN ACTIVITY = 'ICF DEFINE (IN)'         *
*         IF ACTCODE = 'DE' THEN ACTIVITY = 'ICF DEFINE (DE)'         *
*         IF ACTCODE = 'UP' THEN ACTIVITY = 'ICF DEFINE (UP)'         *
*            (ACTCODE IS AT DISPLACEMENT 19)                          *
*    62 - VSAM OPEN                                                   *
*    64 - VSAM CLOSE                                                  *
*    65 - IF ACTCODE = 'S' THEN ACTIVITY = 'VSAM SCRATCH'             *
*         IF ACTCODE = 'U' THEN ACTIVITY = 'VSAM (UN)CAT'             *
*            (THIS TIME ACTCODE IS AT DISPLACEMENT 71)                *
*    66 - IF ACTCODE = 'R' THEN ACTIVITY = 'RENAME(ICF)'              *
*            ELSE ACTIVITY = 'ICF ALTER';                             *
*            (ACTCODE IS AT DISPLACEMENT 71 HERE TOO)                 *
*    92 - OMVS DELETE                                                 *
***********************************************************************
SMFSRCH  CSECT
         USING SMFSRCH,R12,R11          DECLARE BASE
         USING SMFTY14,R10              SMF TYPE 14
         USING SMFTY17,SMFTY14          SMF TYPE 17
         USING SMFTY18,SMFTY14          SMF TYPE 18
         USING SMF42,SMFTY14            SMF TYPE 42
         USING SMFTY61,SMFTY14          SMF TYPE 61 VSAM DEFINE
         USING SMFTY62,SMFTY14          SMF TYPE 62 READ/WRITE/UPDATE
         USING SMFTY65,SMFTY14          SMF TYPE 65 VSAM DELETE
         USING SMFTY66,SMFTY14          SMF TYPE 66 VSAM ALTER
         USING SMFRCD92,SMFTY14         SMF TYPE 92 OMVS DELETE
         USING INFMJFCB,R9              BASE REGISTER FOR JFCB
         USING WORKAREA,R13
         SAVE  (14,12)                  SAVE CALLERS REGISTERS
         LR    R12,R15                  SET UP BASE
         LA    R11,4095(0,R12)            AND SECOND BASE
         LA    R11,1(0,R11)
         GETMAIN R,LV=AREA
         XC    0(OUTAREA-SAVE,R1),0(R1)       CLEAR GETMAINED AREA
         ST    R13,4(,R1)               SAVE CALLERS SAVE AREA ADDRESS
         ST    R1,8(,R13)               SAVE MY SAVE AREA ADDRESS
         LR    R13,R1                   SET ADDRESSABILIY TO WORKAREA
OP       EQU   *
         USING IHADCB,R2
         OPEN  (PRINT,(OUTPUT))
         MVI   OUTAREA,C' '             MOVE BLANK TO PRINT LINE
         MVC   OUTAREA+1(132),OUTAREA   AND BLANK REST OF AREA
OC       EQU   *
         OPEN  (CONTROL,(INPUT))
         LA    R2,CONTROL               LOAD ADDRESS OF CONTROL
         TM    DCBOFLGS,X'10'           IS THERE AN ERROR DURING OPEN
         BO    RC                          NO, GO GET CONTROL CARD
         MVC   ERRMSG,CTLERR00          INDICATE OPEN ERROR FOR CNTL
         B     EOC                      AND GO TERMINATE
         DROP  R2
RC       EQU   *
         GET   CONTROL,CNTLCARD
         MVC   ERRMSG(72),CNTLCARD      MOVE CONTROL CARD TO PRINT LINE
         PUT   PRINT,OUTAREA            PRINT CONTROL CARD
         MVI   OUTAREA,C' '             MOVE BLANK TO PRINT LINE
         MVC   OUTAREA+1(132),OUTAREA   AND BLANK REST OF AREA
         LA    R2,CNTLCARD              SETUP FOR EDIT OF CONTROL CARD
         LA    R3,72                    LOAD LENGTH OF CONTROL CARD
FO1      EQU   *
         CLI   0(R2),C' '              IS THIS THE BEGIN OF OPTION
         BNE   FO2                         YES, GO DETERMINE OPTION
         LA    R2,1(,R2)                 NO, GO TO NEXT COLUMN
         BCT   R3,FO1                         IF NOT THE END OF CARD
         MVC   ERRMSG,CTLERR01          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
FO2      EQU   *
         CLC   0(1,R2),ACCESS          IS THIS A REFFERENCE CNTL CARD
         BNE   FO3                          NO, GO CHECK OTHER OPTIONS
         MVI   OPTION1,X'01'            INDICATE ACCESS OPTION FOUND
         B     FA1                          YES, GO FIND OPERANDS
FO3      EQU   *
         CLC   0(1,R2),SCRATCH         IS THIS A SCRATCH CONTROL CARD
         BNE   FO4                          NO, GO CHECK OTHER OPTIONS
         MVI   OPTION1,X'02'            INDICATE SCRATCH OPTION FOUND
         B     FA1                          YES, GO FIND OPERANDS
FO4      EQU   *
         CLC   0(1,R2),RENAME          IS THIS A RENAME CONTROL CARD
         BNE   FO5                          NO, GO CHECK OTHER OPTIONS
         MVI   OPTION1,X'04'            INDICATE RENAME OPTION FOUND
         B     FA1                          YES, GO FIND OPERANDS
FO5      EQU   *
         CLC   0(1,R2),PARTIAL         IS THIS A PARTIAL CONTROL CARD
         BNE   FO6                          NO, GO CHECK OTHER OPTIONS
         MVI   OPTION1,X'08'            INDICATE PARTIAL OPTION FOUND
         B     FA1                          YES, GO FIND OPERANDS
FO6      EQU   *
         CLC   0(1,R2),MEMSRCH         IS THIS A MEMSRCH CONTROL CARD
         BNE   FO7                          NO, GO CHECK OTHER OPTIONS
         MVI   OPTION1,X'10'            INDICATE MEMBER OPTION FOUND
         B     FA1                          YES, GO FIND OPERANDS
FO7      EQU   *
         MVC   ERRMSG,CTLERR02          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
FA1      EQU   *
         LA    R2,1(,R2)              BUMP TO NEXT COLUMN
         BCTR  R3,R0                      AND DECREMENT LENGTH
FA2      EQU   *
*        CLC   0(3,R2),CONTINUE        IS THIS A CONTINUATION
*        BE    PC                          YES, GO PROCESS CONTINUATION
         CLI   0(R2),C' '              IS THIS THE BEGIN OF OPERAND
         BNE   FA3                         YES, GO DETERMINE OPERAND
         LA    R2,1(,R2)                 NO, GO TO NEXT COLUMN
         BCT   R3,FA2                         IF NOT THE END OF CARD
         MVC   ERRMSG,CTLERR03          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
FA3      EQU   *
         CLC   0(2,R2),ACCTYPE         IS THIS A ACCTYPE OPERAND
         BE    A1                          YES, GO PROCESS ACCTYPE
         CLC   0(2,R2),DATASET         IS THIS A DATASET OPERAND
         BE    S1                          YES, GO PROCESS DATASET
         CLC   0(2,R2),FILENAM         IS THIS A FILE (OMVS) OPERAND
         BNE   *+12                        YES, GO PROCESS DATASET
         OI    OPTION2,X'80'
         B     S1
         CLC   0(2,R2),JOBNAME         IS THIS A JOBNAME OPERAND
         BE    J1                          YES, GO PROCESS JOBNAME
         CLC   0(2,R2),MEMNAME         IS THIS A MEMNAME OPERAND
         BE    M1                          YES, GO PROCESS JOBNAME
         MVC   ERRMSG,CTLERR04          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
A1       EQU   *
         LA    R2,2(,R2)              BUMP TO NEXT COLUMN
         SH    R3,H2                      AND DECREMENT LENGTH
         LR    R4,R2                    LOAD OPERAND BEGINNING
         SR    R5,R5                    CLEAR LENGTH OF OPERAND
         TM    OPTION1,X'09'            IS THIS A ACCESS OR PARTIAL
         BNZ   A2                           YES, GO PROCESS OPERAND
         MVC   ERRMSG,CTLERR11          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
A2       EQU   *
         CLI   0(R4),C' '              IS THIS THE END OF OPERAND
         BE    A3                          YES, GO CHECK ACC FOR MAX
         CLI   0(R4),C','              IS THIS THE END OF OPERAND
         BE    A3                          YES, GO CHECK ACC FOR MAX
         LA    R4,1(,R4)                 NO, GO TO NEXT COLUMN
         LA    R5,1(,R5)                     AND ADD ONE TO OPR LEN
         BCT   R3,A2                    CONT TO FIND END OF OPERAND
         MVC   ERRMSG,CTLERR05          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
A3       EQU   *
         CH    R5,H2                   IS LENGTH OF OPERAND > TWO
         BNH   A4                          NO, GO CHECK ACC FOR MIN
         MVC   ERRMSG,CTLERR06          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
PACKER   PACK  DBLWORD,0(0,R2)          PACK LENGTH
A4       EQU   *
         LTR   R5,R5                  IS LENGTH OF OPERAND ZERO
         BNZ   A5                          NO, GO SETUP OPERAND
         MVC   ERRMSG,CTLERR06          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
A5       EQU   *
         BCTR  R5,R0                   DECREMENT LENGTH FOR EX
         EX    R5,PACKER               PACK ACCTYPE OPERAND
         CVB   R5,DBLWORD              CONVERT ACCTYPE OPR TO BINARY
         CH    R5,H15                  IS ACCTYPE OPERAND > MAX
         BNH   A6                          NO, GO CHECK MINIMUM
         MVC   ERRMSG,CTLERR07          INDICATE ACCTYP OPERAND ERROR
         B     EIC                      AND GO TERMINATE
A6       EQU   *
         LTR   R5,R5                  IS ACCTYPE OPERAND < MIN
         BNZ   A7                          NO, GO CHECK MINIMUM
         MVC   ERRMSG,CTLERR07          INDICATE ACCTYP OPERAND ERROR
         B     EIC                      AND GO TERMINATE
A7       EQU   *
         STC   R5,ACCREF               SET ACCESS REFERENCE FIELD
         LR    R2,R4                    RELOAD POSITION CNTL
         CLI   0(R2),C' '               IS THIS THE END OF OPERAND
         BE    DP                          YES, GO DETERMINE ACTION
         LA    R2,1(,R2)                BUMP POSITION
         BCTR  R3,R0                      AND DECREMENT LENGTH
         B     FA3                      AND GO CHECK FOR MORE OPERANDS
M1       EQU   *                       GET MEMBER NAME
         MVC   MEMBER(8),2(R2)          SAVE MEMBER NAME
         MVI   REFINDI,X'04'
         B     OS                       AND GO TO PROCESS
S1       EQU   *
         LA    R2,2(,R2)                BUMP TO NEXT COLUMN
         SH    R3,H2                      AND DECREMENT LENGTH
         LR    R4,R2                    LOAD OPERAND BEGINNING
         SR    R5,R5                   CLEAR LENGTH OF OPERAND
         TM    REFINDI,X'02'            HAS JOBNAME BEEN SPECIFIED
         BZ    S2                          NO, GO PROCESS DATASET
         MVC   ERRMSG,CTLERR12          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
S2       EQU   *
         CLI   0(R4),C' '              IS THIS THE END OF OPERAND
         BE    S3                          YES, GO CHECK MAX FOR SET
         CLI   0(R4),C','              IS THIS THE END OF OPERAND
         BE    S3                          YES, GO CHECK MAX FOR SET
         LA    R4,1(,R4)                 NO, GO TO NEXT COLUMN
         LA    R5,1(,R5)                     AND ADD ONE TO OPR LEN
         BCT   R3,S2                    CONT TO FIND END OF OPERAND
         MVC   ERRMSG,CTLERR05         INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
S3       EQU   *
         CH    R5,H44                  IS DATASET OPERAND > 44
         BNH   S4                          NO, GO CHECK MIN FOR SET
         MVC   ERRMSG,CTLERR08          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
S4       EQU   *
         LTR   R5,R5                  IS DATASET OPERAND < MIN
         BNZ   S5                          NO, GO SETUP OPERAND
         MVC   ERRMSG,CTLERR08          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
MOVERN   MVC   ACCNAME(0),0(R2)         MOVE DATA SET NAME
S5       EQU   *
         BCTR  R5,R0                   SETUP LENGTH FOR EX
         STH   R5,PARTLEN              STORE LENGTH FOR PARTIAL OPT
         MVI   ACCNAME,C' '             MOVE BLANK TO NAME
         MVC   ACCNAME+1(43),ACCNAME    CLEAR NAME
         EX    R5,MOVERN               MOVE DATASET NAME TO HOLD
         MVI   REFINDI,X'01'            INDICATE ACCESS FOR DATASET
         LR    R2,R4                    RESET POSITION CNTL
         TM    OPTION1,X'02'            IS THIS FROM A SCRATCH OPTION
         BNO   S6                          NO, GO CHECK RENAME OPTION
         MVI   ACCREF,X'04'             INDICATE SCRATCH RECORDS ONLY
         B     OS                          YES, GO FIND IF MORE OPRS
S6       EQU   *
         TM    OPTION1,X'04'            IS THIS FROM A RENAME OPTION
         BNO   S7                          NO, GO CHECK OTHER OPTION
         MVI   ACCREF,X'08'             INDICATE RECORDS RECORDS ONLY
         B     OS                          YES, GO FIND IF MORE OPRS
S7       EQU   *
         TM    OPTION1,X'09'            IS THIS FROM A ACCESS OPTION
         BZ    EL0                         NO, GO INDICATE LOGIC ERROR
         CLI   0(R2),C' '               IS THIS THE END OF OPERAND
         BE    DP                          YES, GO DETERMINE ACTION
         LA    R2,1(,R2)                BUMP POSITION
         BCTR  R3,R0                      AND DECREMENT LENGTH
         B     FA3                       AND GO CHECK MORE OPERANDS
EL0      EQU   *
         MVC   ERRMSG,LOGERR00             NO, INDICATE A LOGIC ERROR
         MVI   EL0,X'00'                CAUSE ABEND
         B     EL0                      AND GO TERMINATE
J1       EQU   *
         LA    R2,2(,R2)                BUMP TO NEXT COLUMN
         SH    R3,H2                      AND DECREMENT LENGTH
         LR    R4,R2                   LOAD OPERAND BEGINNING
         SR    R5,R5                  CLEAR LENGTH OF OPERAND
         TM    OPTION1,X'09'            IS THIS A ACCESS OR PARTIAL
         BNZ   J0                           YES, GO PROCESS OPERAND
         MVC   ERRMSG,CTLERR11          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
J0       EQU   *
         TM    REFINDI,X'01'            HAS DATASET BEEN SPECIFIED
         BZ    J2                          NO, GO PROCESS JOBNAME
         MVC   ERRMSG,CTLERR12          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
J2       EQU   *
         CLI   0(R4),C' '              IS THIS THE END OF OPERAND
         BE    J3                          YES, GO CHECK MAX FOR JOB
         CLI   0(R4),C','              IS THIS THE END OF OPERAND
         BE    J3                          YES, GO CHECK MAX FOR JOB
         LA    R4,1(,R4)                 NO, GO TO NEXT COLUMN
         LA    R5,1(,R5)                     AND ADD ONE TO OPR LEN
         BCT   R3,J2                    CONT TO FIND END OF OPERAND
         MVC   ERRMSG,CTLERR05          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
J3       EQU   *
         CH    R5,H8                   IS DATASET OPERAND > 8
         BNH   J4                          NO, GO CHECK MIN FOR JOB
         MVC   ERRMSG,CTLERR09          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
J4       EQU   *
         LTR   R5,R5                  IS DATASET OPERAND < MIN
         BNZ   J5                          NO, GO SETUP OPERAND
         MVC   ERRMSG,CTLERR09          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
MOVERJ   MVC   ACCJOB(0),0(R2)          MOVE JOB NAME
J5       EQU   *
         BCTR  R5,R0                   SETUP LENGTH FOR EX
         STH   R5,PARTLEN              STORE LENGTH FOR PARTIAL OPT
         MVI   ACCJOB,C' '              MOVE BLANK TO NAME
         MVC   ACCJOB+1(7),ACCJOB       CLEAR NAME
         EX    R5,MOVERJ               MOVE DATASET NAME TO HOLD
         MVI   REFINDI,X'02'            INDICATE ACCESS FOR JOB
         LR    R2,R4                   RESET POSITION CNTL
         CLI   0(R2),C' '               IS THIS THE END OF OPERAND
         BE    DP                          YES, GO DETERMINE ACTION
         LA    R2,1(,R2)                BUMP POSITION
         BCTR  R3,R0                      AND DECREMENT LENGTH
         B     FA3                      AND GO CHECK FOR MORE OPERANDS
DP       EQU   *
         TM    ACCREF,X'0F'             CHECK IF WE GOT AN ACC REQUEST
         BNZ   DP1                         YES, GO TEST DATASET
         MVI   ACCREF,X'0F'                NO, SET TO ALL
DP1      EQU   *
         TM    REFINDI,X'FF'            CHECK IF WE GOT AN SET REQUEST
         BNZ   OS                          YES, GO GET SMF DATA
         MVC   ERRMSG,CTLERR10          INDICATE CONTROL CARD ERROR
         B     EIC                      AND GO TERMINATE
OS       EQU   *
         USING IHADCB,R2
         OPEN  (SMFDATA,(INPUT))
         LA    R2,SMFDATA               LOAD ADDRESS OF SMFDATA
         TM    DCBOFLGS,X'10'           TEST DCBOFLGS FOR OK OPEN
         BO    RS                       OPEN ERROR
         MVC   ERRMSG,RECERR00          INDICATE CONTROL CARD ERROR
         B     EOS                      AND GO TERMINATE
         DROP  R2
RS       EQU   *
         SR    R9,R9                    CLEAR POINTER TO JFCB
         GET   SMFDATA
         LR    R10,R1                   SAVE SMF RECORD ADDRESS
         AP    RECCNT,=P'001'           COUNT RECORDS FOR DEBUG
         CLI   SMF42RTY,X'2A'           IS THIS A RECORD TYPE 42
         BE    IP                          YES, GO LOOK FOR MEMBER
         CLI   SMF62RTY,X'3D'           IS THIS A RECORD TYPE 61
         BE    V4                          YES, GO CHECK JOB NAME
         TM    ACCREF,X'01'             RECORD TYPE 62 REFERENCE
         BZ    V1                          NO, GO CHECK IF REC 67
         CLI   SMF62RTY,X'3E'           IS THIS A RECORD TYPE 62
         BE    V4                          YES, GO CHECK JOB NAME
V1       EQU   *
         TM    ACCREF,X'02'             RECORD TYPE 62 REFERENCE
         BZ    V2                          NO, GO CHECK IF REC 67
         CLI   SMF62RTY,X'3E'           IS THIS A RECORD TYPE 62
         BE    V4                          YES, GO CHECK JOB NAME
V2       EQU   *
         TM    ACCREF,X'04'             RECORD TYPE 67 REFERENCE
         BZ    V3                          NO, GO CHECK IF REC 68
         CLI   SMF62RTY,X'41'           IS THIS A RECORD TYPE 65
         BE    V4                          YES, GO CHECK JOB NAME
*        CLI   SMF62RTY,X'43'           IS THIS A RECORD TYPE 67
*        BE    V4                          YES, GO CHECK JOB NAME
         CLI   SMF92RTY,X'5C'           IS THIS A RECORD TYPE 92
*        BNE   V4                          NO
*        CLC   SMF92TYP(2),=H'14'       SUB-TYPE 14, OMVS DELETE?
*        BNE   ???
V3       EQU   *
         TM    ACCREF,X'08'             RECORD TYPE 68 REFERENCE
         BZ    RS                          NO, GO GET A DIFFERENT REC
         CLI   SMF62RTY,X'42'           IS THIS A RECORD TYPE 66
         BE    V4                          YES, GO CHECK JOB NAME
*        CLI   SMF62RTY,X'44'           IS THIS A RECORD TYPE 68
*        BE    V4                          YES, GO CHECK JOB NAME
         B     P0                          NO, GO GET A DIFFERENT REC
V4       EQU   *
         TM    REFINDI,X'04'            CHECK IF WE GOT A MEM REQUEST
         BO    RS                          YES, GO CHECK DATASET NAME
         TM    REFINDI,X'01'            CHECK IF WE GOT A SET REQUEST
         BO    V6                          YES, GO CHECK DATASET NAME
         TM    REFINDI,X'02'            CHECK IF WE GOT A JOB REQUEST
         BZ    EL2                         NO, INDICATE LOGIC ERROR
         TM    OPTION1,X'08'            IS THIS A PARTIAL OPTION
         BZ    V5                          NO, DO FULL COMPARE
         LH    R5,PARTLEN              LOAD LENGTH OF PARTIAL JOBNAME
         CLI   SMF62RTY,X'3E'           IS THIS A TYPE 62?
         BNE   V4A                         NO
         EX    R5,COMPJ62              DOES JOBNAME MATCH PARTIALLY
         BE    IP                          YES, GO SETUP PRINT
         B     RS
V4A      EQU   *
         EX    R5,COMPJ66              DOES JOBNAME MATCH PARTIALLY
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET A DIFFERENT REC
COMPJ62  CLC   SMF62JBN(0),ACCJOB       DO THE JOBNAMES MATCH
COMPJ66  CLC   SMF66JNM(0),ACCJOB       DO THE JOBNAMES MATCH
V5       EQU   *
         CLI   SMF62RTY,X'3E'         IS THIS A TYPE 62?
         BNE   V5A                         NO
         CLC   SMF62JBN,ACCJOB        DO THE JOBNAMES MATCH
         BE    IP                          YES, GO CHECK IF DATASET
         B     RS                          NO, GO GET A DIFFERENT REC
V5A      EQU   *
         CLC   SMF66JNM,ACCJOB        DO THE JOBNAMES MATCH
         BE    IP                          YES, GO CHECK IF DATASET
         B     RS                          NO, GO GET A DIFFERENT REC
V6       EQU   *
         CLI   SMF62RTY,X'3D'           CHECK IF TYPE 61 RECORD
         BE    V9                          YES, GO GET CHK DATASET
         CLI   SMF62RTY,X'3E'           CHECK IF TYPE 62 RECORD
         BE    V7                          YES, GO GET CHK DATASET
         CLI   SMF62RTY,X'41'           CHECK IF TYPE 65 RECORD
         BE    V9                          YES, GO GET CHK DATASET
         CLI   SMF62RTY,X'42'           CHECK IF TYPE 66 RECORD
         BE    V11                         YES, GO GET CHK DATASET
*        CLI   SMF62RTY,X'43'           CHECK IF TYPE 67 RECORD
*        BE    P9                          YES, GO GET CHK DATASET
*        CLI   SMF62RTY,X'44'           CHECK IF TYPE 68 RECORD
*        BE    V11                         YES, GO GET CHK DATASET
         B     EL3                      AND GO TERMINATE
V7       EQU   *
         TM    OPTION1,X'08'            IS THIS A PARTIAL OPTION
         BZ    V8                          NO, DO FULL COMPARE
         LH    R5,PARTLEN              LOAD LENGTH OF PARTIAL JOBNAME
         EX    R5,VCOMPIO              DOES DATASET MATCH PARTIALLY
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET A DIFFERENT REC
V8       EQU   *
         CLC   SMF62DNM,ACCNAME         DO THE DATASET NAMES MATCH
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET NEXT REC
VCOMPIO  CLC   SMF62DNM(0),ACCNAME      DO THE DATASET NAMES MATCH
V9       EQU   *
         TM    OPTION1,X'08'            IS THIS A PARTIAL OPTION
         BZ    V10                         NO, DO FULL COMPARE
         LH    R5,PARTLEN              LOAD LENGTH OF PARTIAL JOBNAME
         EX    R5,VCOMPSRO             DOES DATASET MATCH PARTIALLY
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET A DIFFERENT REC
V10      EQU   *
         CLC   SMF66ENM,ACCNAME         DO THE DATASET NAMES MATCH
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET NEXT REC
VCOMPSRO CLC   SMF66ENM(0),ACCNAME      DO THE DATASET NAMES MATCH
VCOMPRN  CLC   SMF66NNM(0),ACCNAME      DO THE DATASET NAMES MATCH
V11      EQU   *
         TM    OPTION1,X'08'            IS THIS A PARTIAL OPTION
         BZ    V12                         NO, DO FULL COMPARE
         LH    R5,PARTLEN              LOAD LENGTH OF PARTIAL JOBNAME
         EX    R5,VCOMPSRO             DOES DATASET MATCH PARTIALLY
         BE    IP                          YES, GO SETUP PRINT
         EX    R5,VCOMPRN              DOES DATASET MATCH PARTIALLY
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET A DIFFERENT REC
V12      EQU   *
         CLC   SMF66ENM,ACCNAME         DO THE DATASET NAMES MATCH
         BE    IP                          YES, GO SETUP PRINT
         CLC   SMF66NNM,ACCNAME         DO THE DATASET NAMES MATCH
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET NEXT REC
P0       EQU   *
         TM    ACCREF,X'01'             RECORD TYPE 14 REFERENCE
         BZ    P1                          NO, GO CHECK IF REC 15
         CLI   SMF14RTY,X'0E'           IS THIS A RECORD TYPE 14
         BE    P4                          YES, GO CHECK JOB NAME
P1       EQU   *
         LA    R9,SMFJFCB1             ADDRESSING FOR JFCB
         TM    ACCREF,X'02'             RECORD TYPE 15 REFERENCE
         BZ    P2                          NO, GO CHECK IF REC 17
         CLI   SMF14RTY,X'0F'           IS THIS A RECORD TYPE 15
         BE    P4                          YES, GO CHECK JOB NAME
P2       EQU   *
         TM    ACCREF,X'04'             RECORD TYPE 17 REFERENCE
         BZ    P3                          NO, GO CHECK IF REC 18
         CLI   SMF14RTY,X'11'           IS THIS A RECORD TYPE 17
         BE    P4                          YES, GO CHECK JOB NAME
P3       EQU   *
         TM    ACCREF,X'08'             RECORD TYPE 18 REFERENCE
         BZ    RS                          NO, GO GET A DIFFERENT REC
         CLI   SMF14RTY,X'12'           IS THIS A RECORD TYPE 18
         BE    P4                          YES, GO CHECK JOB NAME
         B     RS                          NO, GO GET A DIFFERENT REC
P4       EQU   *
         LA    R9,SMFJFCB1             ADDRESSING FOR JFCB
         TM    REFINDI,X'04'            CHECK IF WE GOT A MBR REQUEST
         BO    IP                          YES, GO CHECK DATASET NAME
         TM    REFINDI,X'01'            CHECK IF WE GOT A SET REQUEST
         BO    P6                          YES, GO CHECK DATASET NAME
         TM    REFINDI,X'02'            CHECK IF WE GOT A JOB REQUEST
         BZ    EL2                         NO, INDICATE LOGIC ERROR
         TM    OPTION1,X'08'            IS THIS A PARTIAL OPTION
         BZ    P5                          NO, DO FULL COMPARE
         LH    R5,PARTLEN              LOAD LENGTH OF PARTIAL JOBNAME
         EX    R5,COMPJ                DOES JOBNAME MATCH PARTIALLY
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET A DIFFERENT REC
COMPJ    CLC   SMF14JBN(0),ACCJOB       DO THE JOBNAMES MATCH
P5       EQU   *
         CLC   SMF14JBN,ACCJOB          DO THE JOBNAMES MATCH
         BE    IP                          YES, GO CHECK IF DATASET
         B     RS                          NO, GO GET A DIFFERENT REC
P6       EQU   *
         CLI   SMF14RTY,X'0E'           CHECK IF TYPE 14 RECORD
         BE    P7                          YES, GO GET CHK DATASET
         CLI   SMF14RTY,X'0F'           CHECK IF TYPE 15 RECORD
         BE    P7                          YES, GO GET CHK DATASET
         CLI   SMF14RTY,X'11'           CHECK IF TYPE 17 RECORD
         BE    P9                          YES, GO GET CHK DATASET
         CLI   SMF14RTY,X'12'           CHECK IF TYPE 18 RECORD
         BE    P11                         YES, GO GET CHK DATASET
         B     EL3                      AND GO TERMINATE
P7       EQU   *
         TM    OPTION1,X'08'            IS THIS A PARTIAL OPTION
         BZ    P8                          NO, DO FULL COMPARE
         LH    R5,PARTLEN              LOAD LENGTH OF PARTIAL JOBNAME
         EX    R5,COMPIO               DOES DATASET MATCH PARTIALLY
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET A DIFFERENT REC
P8       EQU   *
         CLC   JFCBDSNM,ACCNAME         DO THE DATASET NAMES MATCH
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET NEXT REC
COMPIO   CLC   JFCBDSNM(0),ACCNAME      DO THE DATASET NAMES MATCH
P9       EQU   *
         TM    OPTION1,X'08'            IS THIS A PARTIAL OPTION
         BZ    P10                         NO, DO FULL COMPARE
         LH    R5,PARTLEN              LOAD LENGTH OF PARTIAL JOBNAME
         EX    R5,COMPSRO              DOES DATASET MATCH PARTIALLY
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET A DIFFERENT REC
P10      EQU   *
         CLC   SMF18ODS,ACCNAME         DO THE DATASET NAMES MATCH
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET NEXT REC
COMPSRO  CLC   SMF18ODS(0),ACCNAME      DO THE DATASET NAMES MATCH
COMPRN   CLC   SMF18NDS(0),ACCNAME      DO THE DATASET NAMES MATCH
P11      EQU   *
         TM    OPTION1,X'08'            IS THIS A PARTIAL OPTION
         BZ    P12                         NO, DO FULL COMPARE
         LH    R5,PARTLEN              LOAD LENGTH OF PARTIAL JOBNAME
         EX    R5,COMPSRO              DOES DATASET MATCH PARTIALLY
         BE    IP                          YES, GO SETUP PRINT
         EX    R5,COMPRN               DOES DATASET MATCH PARTIALLY
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET A DIFFERENT REC
P12      EQU   *
         CLC   SMF18ODS,ACCNAME         DO THE DATASET NAMES MATCH
         BE    IP                          YES, GO SETUP PRINT
         CLC   SMF18NDS,ACCNAME         DO THE DATASET NAMES MATCH
         BE    IP                          YES, GO SETUP PRINT
         B     RS                          NO, GO GET NEXT REC
EL2      EQU   *
         MVC   ERRMSG,LOGERR02            DO, INDICATE A LOGIC ERROR
         DC    H'0'                     CAUSE ABEND
EL3      EQU   *
         MVC   ERRMSG,LOGERR03             NO, INDICATE A LOGIC ERROR
         DC    H'0'                     CAUSE ABEND
*
IP       EQU   *
         MVI   OUTAREA,C' '             MOVE BLANK TO PRINT LINE
         MVC   OUTAREA+1(L'OUTAREA-1),OUTAREA  OUTPUT LINE
         MVC   OSYSNAM(4),SMF14SID      MOVE IN SYSTEM NAME
         MVC   OJOBNAME,SMF14JBN        MOVE IN JOB NAME
*        CLI   JFCBVOLS,C' '            IS VOLSER VALID?
*        BE    *+10                     NO, DON'T MOVE GARBAGE
         LTR   R9,R9                    VALID JFCB POINTER?
         BZ    *+10                     NO - DON'T SET VOLSER
         MVC   OJFCBVOLS(6),JFCBVOLS    MOVE IN JFCBVOLS
*        MVC   OFILLER2(1),SMF62RTY     RECORD TYPE FOR DEBUGGING
         UNPK  DBLWORD,SMF14DTE         UNPACK THE DATE
         OI    DBLWORD+1,X'F0'          OR SIGN FOR PRINTING
         MVC   ODATE,DBLWORD+3          MOVE DATE TO PRINT LINE
         MVC   FULLTIME,SMF14TME        MOVE SMF14TME FOR LOAD
         L     R2,FULLTIME              LOAD TIME
         SRDA  R2,32(R0)                SHIFT FOR DIVIDE
         D     R2,F100                  DIVIDE BY 100 TO GET SECONDS
         LR    R2,R3                    LOAD SECONDS
         SRDA  R2,32(R0)                SHIFT FOR DIVIDE
         D     R2,F60                   DIVIDE BY 60 TO GET MINUTES
         CVD   R2,DBLWORD2              CONVERT SECONDS TO DECIMAL
         UNPK  DBLWORD,DBLWORD2+6(2)    UNPACK SECONDS FOR PRINTING
         OI    DBLWORD+7,X'F0'          OR SIGN FOR PRINTING
         MVC   OSEC,DBLWORD+6           MOVE SECONDS TO PRINT LINE
         LR    R2,R3                    LOAD MINUTES
         SRDA  R2,32(R0)                SHIFT FOR DIVIDE
         D     R2,F60                   DIVIDE BY 60 TO GET HOURS
         CVD   R2,DBLWORD2              CONVERT MINUTES TO DECIMAL
         UNPK  DBLWORD,DBLWORD2+6(2)    UNPACK MINUTES FOR PRINTING
         OI    DBLWORD+7,X'F0'          OR SIGN FOR PRINTING
         MVC   OMIN,DBLWORD+6           MOVE MINUTES TO PRINT LINE
         CVD   R3,DBLWORD2              CONVERT HOURS TO DECIMAL
         UNPK  DBLWORD,DBLWORD2+6(2)    UNPACK HOURS FOR PRINTING
         OI    DBLWORD+7,X'F0'          OR SIGN FOR PRINTING
         MVC   OHRS,DBLWORD+6           MOVE MINUTES TO PRINT LINE
         CLI   SMF14RTY,X'0E'           WAS IT A TYPE 14 RECORD
         BE    IP10                        YES, GO SETUP READ ONLY
         CLI   SMF14RTY,X'0F'           WAS IT A TYPE 15 RECORD
         BE    IP11                        YES, GO SETUP UPDATE
         CLI   SMF14RTY,X'11'           WAS IT A TYPE 17 RECORD
         BE    IP12                        YES, GO SETUP SCRATCH
         CLI   SMF14RTY,X'12'           WAS IT A TYPE 18 RECORD
         BE    IP13                        YES, GO SETUP RENAME
         CLI   SMF42RTY,X'2A'           IS THIS A RECORD TYPE 42
         BE    V421                        YES, GO SETUP MEMBER
         CLI   SMF62RTY,X'3D'           WAS IT A TYPE 61 RECORD
         BE    VIP14                        YES, GO SETUP DEFINE ONLY
         CLI   SMF62RTY,X'3E'           WAS IT A TYPE 62 RECORD
         BE    VIP10                        YES, GO SETUP READ ONLY
         CLI   SMF62RTY,X'41'           WAS IT A TYPE 65 RECORD
         BE    VIP12                        YES, GO SETUP SCRATCH
         CLI   SMF62RTY,X'42'           WAS IT A TYPE 66 RECORD
         BE    VIP13                        YES, GO SETUP RENAME
*        CLI   SMF62RTY,X'43'           WAS IT A TYPE 67 RECORD
*        BE    VIP12                        YES, GO SETUP SCRATCH
*        CLI   SMF62RTY,X'44'           WAS IT A TYPE 68 RECORD
*        BE    VIP13                        YES, GO SETUP RENAME
EL4      EQU   *
         MVC   ERRMSG,LOGERR04             NO, INDICATE A LOGIC ERROR
         DC    H'0'                     CAUSE ABEND
*        MVI   EL4,X'00'                CAUSE ABEND
*        B     EL4                      AND GO TERMINATE
*        B     EIL                      AND GO TERMINATE
IP10     EQU   *
         MVC   OREFTYPE,READONLY        MOVE IN READ ONLY REFFERENCE
         MVC   ODATASET,JFCBDSNM        MOVE IN DATA SET NAME
         B     WR                       AND GO PRINT RECORD
IP11     EQU   *
         MVC   OREFTYPE,UPDTONLY        MOVE IN UPDATE
         MVC   ODATASET,JFCBDSNM        MOVE IN DATA SET NAME
         B     WR                       AND GO PRINT RECORD
IP12     EQU   *
         MVC   OREFTYPE,SCRONLY         MOVE IN SCRATCH
         MVC   ODATASET,SMF17DSN        MOVE IN DATA SET NAME
         SR    R6,R6                    CLEAR FOR IC
         IC    R6,SMF17NVL              GET COUNT OF VOLSERS
         LA    R7,SMF17FVL              POINT TO VOLSER
IP12A    EQU   *
         MVC   ONEWNAME(6),0(R7)        COPY VOLSER TO OUTPUT
         LA    R7,8(,R7)                POINT TO NEXT VOLSER
         BCT   R6,IP12A                 LOOP WHILE VOLSERS
         B     WR                       AND GO PRINT RECORD
IP13     EQU   *
         MVC   OREFTYPE,RENONLY         MOVE IN RENAME
         MVC   ODATASET,SMF18ODS        MOVE IN OLD DATA SET NAME
         MVC   ONEWNAME,SMF18NDS        MOVE IN NEW DATA SET NAME
         B     WR                       AND GO PRINT RECORD
VIP10    EQU   *
         MVC   OREFTYPE,READONLY        MOVE IN READ ONLY REFFERENCE
         MVC   ODATASET,SMF62DNM        MOVE IN DATA SET NAME
         B     WR                       AND GO PRINT RECORD
VIP11    EQU   *
         MVC   OREFTYPE,UPDTONLY        MOVE IN UPDATE
         MVC   ODATASET,SMF62DNM        MOVE IN DATA SET NAME
         B     WR                       AND GO PRINT RECORD
VIP12    EQU   *
         MVC   OREFTYPE,SCRONLY         MOVE IN SCRATCH
         MVC   ODATASET,SMF65ENM        MOVE IN DATA SET NAME
         MVC   OJOBNAME,SMF65JNM        MOVE IN JOB NAME
         B     WR                       AND GO PRINT RECORD
VIP13    EQU   *
         MVC   OREFTYPE,RENONLY         MOVE IN RENAME
         MVC   ODATASET,SMF66ENM        MOVE IN OLD DATA SET NAME
         MVC   ONEWNAME,SMF66NNM        MOVE IN NEW DATA SET NAME
         MVC   OJOBNAME,SMF66JNM        MOVE IN JOB NAME
         B     WR                       AND GO PRINT RECORD
VIP14    EQU   *
         MVC   OREFTYPE,DEFONLY         MOVE IN DEFINE
         MVC   ODATASET,SMF61ENM        MOVE IN NEW DATA SET NAME
         MVC   OJOBNAME,SMF61JNM        MOVE IN JOB NAME
         MVC   ONEWNAME,SMF61CNM        MOVE IN CATALOG NAME
         B     WR                       AND GO PRINT RECORD
V421     EQU   *
         TM    OPTION1,X'10'            DOING MEMBER OPTION?
         BZ    RS                       NO, SO SKIP THIS RECORD
         CLC   SMF42STY(2),=H'21'       MEMBER DELETE?
         BE    DEL42
         CLC   SMF42STY(2),=H'24'       MEMBER ADD?
         BE    ADD42
         CLC   SMF42STY(2),=H'25'       MEMBER RENAME?
         BE    REN42
         BNE   RS                       NO, SOME OTHER SUB-TYPE
ADD42    EQU   *
         USING SMF42SP,R9
         LA    R9,SMF42END              POINT TO START OF DATA
         L     R8,SMF42PN1              OFFSET TO MEMBER ADD SECTION
         AR    R8,R10                   R9 POINTING TO SUB-TYPE 24
         USING SMF421PA,R8
         MVC   OREFTYPE(3),=C'ADD'
         CLC   SMF42PMN(8),MEMBER       OUR MEMBER NAME?
         BE    SMF42COM
REN42    EQU   *
         USING SMF42SQ,R9
         LA    R9,SMF42END              POINT TO START OF DATA
         L     R8,SMF42QN1              OFFSET TO MEMBER RENAME SECTION
         AR    R8,R10                   R9 POINTING TO SUB-TYPE 25
         USING SMF420QA,R8
         MVC   OREFTYPE(3),=C'REN'
         CLC   SMF42QMN(8),MEMBER       OUR MEMBER NAME?
         BE    SMF42COM
DEL42    EQU   *
         USING SMF42SL,R9
         LA    R9,SMF42END              POINT TO START OF DATA
         L     R8,SMF42LN1              OFFSET TO MEMBER DELETE SECTION
         AR    R8,R10                   R9 POINTING TO SUB-TYPE 21
         USING SMF420LA,R8
         MVC   OREFTYPE(3),=C'DEL'
         CLC   SMF42LMN(8),MEMBER       OUR MEMBER NAME?
         BNE   RS
SMF42COM EQU   *                        SET UP REPORT DETAIL
         MVC   OJOBNAME,SMF42LJB        MOVE IN JOB NAME
         MVC   ONEWNAME+5(8),MEMBER     MOVE IN MEMBER NAME
         MVC   ODATASET(44),SMF42LDS    MOVE IN DSNAME
         B     WR
*
WR       EQU   *
         PUT   PRINT,OUTAREA            PRINT REPORT LINE
         B     RS                       AND GO GET ANOTHER RECORD
TS       EQU   *
         LA    R2,0                    LOAD GOOD RETURN CODE
         B     T1                       AND GO RETURN
EIC      EQU   *
         LA    R2,4                    LOAD BAD RETURN CODE
         PUT   PRINT,OUTAREA            PRINT ERROR MESSAGE
         B     T2                       AND GO RETRUN
EIL      EQU   *
         LA    R2,8                    LOAD BAD RETURN CODE
         PUT   PRINT,OUTAREA            PRINT ERROR MESSAGE
         B     T1                       AND GO RETURN
EOC      EQU   *
         LA    R2,12                   LOAD BAD RETURN CODE
         PUT   PRINT,OUTAREA            PRINT ERROR MESSAGE
         B     T3                       AND GO RETURN
EOS      EQU   *
         LA    R2,16                   LOAD BAD RETURN CODE
         PUT   PRINT,OUTAREA            PRINT ERROR MESSAGE
         B     T2                       AND GO RETURN
T1       EQU   *
         CLOSE (SMFDATA)                CLOSE SMFDATA DATA SET
T2       EQU   *
         CLOSE (CONTROL)                CLOSE CONTROL DATA SET
T3       EQU   *
         CLOSE (PRINT)                  CLOSE PRINT DATA SET
         LR    R1,R13                   ADDRESS OF GETMAIN CORE
         L     R13,SAVE+4
         FREEMAIN  R,LV=AREA,A=(R1)     FREE BLOCK
         LR    R15,R2                   LOAD RETURN CODE
         RETURN (14,12),RC=(15)         RETURN
         LTORG
         DS    0D
H2       DC    H'2'
H8       DC    H'8'
H15      DC    H'15'
H44      DC    H'44'
F60      DC    F'60'
F100     DC    F'100'
FULLTIME DC    F'0'
DATASET  DC    C'D='               DATASET OPERAND IN SEARCH CNTL
FILENAM  DC    C'F='               FILE (OMVS) OPERAND IN SEARCH CNTL
JOBNAME  DC    C'J='               JOBNAME OPERAND IN SEARCH CNTL
MEMNAME  DC    C'M='               MEMBER OPERAND IN SEARCH CNTL
ACCTYPE  DC    C'T='               ACCTYPE OPERAND IN SEARCH CNTL
ACCESS   DC    C'A'                REFFERENCE OPTION IN CNTL CARD
SCRATCH  DC    C'S'                SCRATCH OPTION IN CONTROL CARD
RENAME   DC    C'R'                RENAME OPTION IN CONTROL CARD
PARTIAL  DC    C'P'                PARTIAL OPTION IN CONTROL CARD
MEMSRCH  DC    C'M'                MEMBER OPTION IN CONTROL CARD
CONTINUE DC    C' - '              CONTINUATION CONSTANT
READONLY DC    C'READ'
UPDTONLY DC    C'UPDT'
SCRONLY  DC    C'SCR '
RENONLY  DC    C'REN '
DEFONLY  DC    C'DEF '
RECCNT   DC    PL4'0000'       RECORD COUNTER USED FOR DEBUGGING
RECERR00 DC    CL80'RECERR00 - ERROR OPENNING SMFDATA (SYSUT1) DATA SET*
                                            '
CTLERR00 DC    CL80'CTLERR00 - ERROR OPENNING CONTROL (SYSIN) DATA SET *
                                            '
CTLERR01 DC    CL80'CTLERR01 - CONTROL CARD IS BLANK                   *
                                            '
CTLERR02 DC    CL80'CTLERR02 - COULD NOT FIND A VALID CONTROL CARD OPTI*
               ON                           '
CTLERR03 DC    CL80'CTLERR03 - COULD NOT FIND AN OPERAND FOR OPTION    *
                                            '
CTLERR04 DC    CL80'CTLERR04 - COULD NOT FIND A VALID OPERAND FOR OPTIO*
               N                            '
CTLERR05 DC    CL80'CTLERR05 - COULD NOT FIND THE END OF AN OPERAND    *
                                            '
CTLERR06 DC    CL80'CTLERR06 - FOUND AN OPERAND WITH NO SPECIFIED VALUE*
                                            '
CTLERR07 DC    CL80'CTLERR07 - TYPE OPERAND SPECIFIES AN INVALID VALUE *
                                            '
CTLERR08 DC    CL80'CTLERR08 - DATASET OPERAND SPECIFIES AN INVALID VAL*
               UE                           '
CTLERR09 DC    CL80'CTLERR09 - JOBNAME OPERAND SPECIFIES AN INVALID VAL*
               UE                           '
CTLERR10 DC    CL80'CTLERR10 - OPERANDS FOR OPTION ARE INVALID OR MISSI*
               NG                           '
CTLERR11 DC    CL80'CTLERR11 - OPERAND IS INVALID FOR OPTION SPECIFIED *
                                            '
CTLERR12 DC    CL80'CTLERR12 - INVALID COMBINATION OF OPERANDS FOR THIS*
               OPTION                       '
LOGERR00 DC    CL80'LOGERR00 - PROGRAM HAS ENCOUNTERED SOMETHING UNEXPE*
               CTED                         '
LOGERR01 DC    CL80'LOGERR01 - PROGRAM HAS ENCOUNTERED SOMETHING UNEXPE*
               CTED                         '
LOGERR02 DC    CL80'LOGERR02 - PROGRAM HAS ENCOUNTERED SOMETHING UNEXPE*
               CTED                         '
LOGERR03 DC    CL80'LOGERR03 - PROGRAM HAS ENCOUNTERED SOMETHING UNEXPE*
               CTED                         '
LOGERR04 DC    CL80'LOGERR04 - PROGRAM HAS ENCOUNTERED SOMETHING UNEXPE*
               CTED                         '
PRINT    DCB   DDNAME=SYSPRINT,MACRF=PM,DSORG=PS,                      *
               RECFM=FB
SMFDATA  DCB   DDNAME=SYSUT1,MACRF=GL,DSORG=PS,BFTEK=A,                *
               EODAD=TS
CONTROL  DCB   DDNAME=SYSIN,MACRF=GM,DSORG=PS,                         *
               EODAD=DP
         DCBD  DSORG=PS,DEVD=DA
***********************************************************************
*                  WORKAREA LAYOUT                                    *
***********************************************************************
WORKAREA DSECT                          GETMAINED WORKAREA LAYOUT
SAVE     DS    18F                      SMFSRCH SAVE AREA
CNTLCARD DS    CL80                     CONTROL CARD
DBLWORD  DS    D                        DOUBLE-WORD WORK AREA
PARTLEN  DS    H                        LENGTH OF PARTIAL OPERAND
REFINDI  DS    X                        REFERENCE INDICATIORS
OPTION1  DS    X                        OPTION1 INDICATOR FIELD
*                                         X'01' ACCESS
*                                         X'02' SCRATCH
*                                         X'04' RENAME
*                                         X'08' PARTIAL
*                                         X'10' MEMBER
OPTION2  DS    X                        OPTION2 INDICATOR FIELD
ACCREF   DS    X                        ACCESS REFERENCE FIELD
ACCNAME  DS    CL44                     ACCESS DATA SET NAME FIELD
ACCJOB   DS    CL8                      ACCESS JOB NAME FIELD
MEMBER   DS    CL8                      MEMBER NAME WE'RE LOOKING FOR
*
OUTAREA  DS    0CL133                   OUTPUT AREA
OSYSNAM  DS    CL4                      SMF SYSTEM NAME
OFILLER1 DS    CL1                      FILLER
OREFTYPE DS    CL4                      HOW DATA SETS WAS REFFERENCED
OFILLER2 DS    CL1                      FILLER
OJOBNAME DS    CL8                      JOB NAME REFFERENCING DATA SET
OFILLER6 DS    CL1                      FILLER
ODATE    DS    CL5                      RECORD DATE - YYDDD
OFILLER7 DS    CL1                      FILLER
OHRS     DS    CL2                      RECORD HOUR
OMIN     DS    CL2                      RECORD MINUTE
OSEC     DS    CL2                      RECORD SECONDS
OFILLER3 DS    CL1                      FILLER
ODATASET DS    CL44                     DATA SET REFFERENCED
OFILLER4 DS    CL1                      FILLER
ONEWNAME DS    CL44                     NEW NAME OF DATA SET IF RENAME
OFILLER8 DS    CL2                      FILLER
OJFCBVOLS DS   CL6                      JFCBVOLS
OFILLER9 DS    CL3                      FILLER
         ORG   OUTAREA
MSGAREA  DS    0CL133                   OUTPUT AREA
MFILLER1 DS    CL20                     FILLER
ERRMSG   DS    CL80                     ERROR MESSAGE AREA
MFILLER2 DS    CL33                     FILLER
DBLWORD2 DS    D                        DOUBLE-WORD BOUNDARY
AREA     EQU   *-SAVE                   LENGTH OF GETMAIN
         EJECT
         IEFJFCBN ,                     MAP JFCB
***********************************************************************
*                     SMF RECORD DSECTS                               *
***********************************************************************
SMFTY14  DSECT
         IFASMFR 14                USE FOR 14 AND 15 (X'0E' & X'0F')
SMFTY17  DSECT
         IFASMFR 17                USE FOR 17 AND 18 (X'11' & X'12')
SMFTY18  DSECT
         IFASMFR 18                USE FOR 17 AND 18 (X'11' & X'12')
SMFTY42  DSECT
         IGWSMF SMF42_0L=YES,SMF42_0P=YES,SMF42_0Q=YES  (X'2A')
SMFTY61  DSECT
         IFASMFI6 61               VSAM ICF DEFINE   (X'3D')
SMFTY62  DSECT
         IFASMFR6 62               VSAM CLUSTER OPEN (X'3E')
SMFTY65  DSECT
         IFASMFI6 65               VSAM ICF DELETE   (X'41')
SMFTY66  DSECT
         IFASMFI6 66               VSAM ICF ALTER    (X'42')
         BPXYFTYP ,                FILE TYPES USED IN REC TYPE 92
SMFTY92  DSECT
         BPXYSMFR ,                OMVS DELETE       (X'5C')
R0       EQU   0         REGISTERS  0 - LINKAGE (PARMS)
R1       EQU   1                    1 - LINKAGE (PARMS)
R2       EQU   2                    2 - WORK
R3       EQU   3                    3 - WORK
R4       EQU   4                    4 - WORK
R5       EQU   5                    5 - WORK
R6       EQU   6                    6 -
R7       EQU   7                    7 -
R8       EQU   8                    8 -
R9       EQU   9                    9 -
R10      EQU   10                  10 - SMF RECORD DSECT
R11      EQU   11                  11 - 2ND BASE REG
R12      EQU   12                  12 - BASE
R13      EQU   13                  13 - WORKAREA AND SAVE
R14      EQU   14                  14 - LINKAGE (RETURN)
R15      EQU   15                  15 - LINKAGE (GO-TO)
         END
./ ADD NAME=SVCTAB   0178-86176-09118-1246-00245-00029-00230-TCACF0  00
         MACRO
&NAME    IHASVC
SVC      DSECT
SVCEP    DC    F'0'           SVC ENTRY POINT ADDRERSS
SVCAMODE EQU   X'80'          SVC AMODE INDICATOR
SVCATTR1 DC    0XL2'00'       ATTRIBUTES
SVCTP    DC    XL1'00'        TYPE FIELD
SVCTP1   EQU   X'00'          TYPE 1 SVC
SVCTP2   EQU   X'80'          TYPE 2 SVC
SVCTP34  EQU   X'C0'          TYPE 3 OR 4 SVC
SVCTP6   EQU   X'20'          TYPE 6 SVC
SVCAPF   EQU   X'08'          APF AUTHORIZED 1-AUTHORIZED
SVCESR   EQU   X'04'          SVC IS PART OF THE ESR
SVCNP    EQU   X'02'          NON-PREEMPTIVE SVC
SVCASF   EQU   X'01'          SVC CAN BE ASSISTED
SVCATTR3 DC    XL1'00'        ATTRUBUTES
SVCAR    EQU   X'80'          SVC MAY BE ISSUED IN AR ASC MODE
SVCLOCKS DC    XL2'00'        LOCK ATTRIBUTES
SVCLL    EQU   X'80'          LOCAL LOCK NEEDED
SVCCMS   EQU   X'40'          CMS LOCK NEEDED
SVCOPT   EQU   X'20'          OPT LOCK NEEDED
SVCALLOC EQU   X'10'          SALLOC LOCK NEEDED
SVCDISP  EQU   X'08'          DISPATCHER LOCK NEEDED
*
SVCESRAD EQU   SVCLOCKS+1
SVCLEN   EQU   *-SVC
         MEND
SVCTAB   MOWSTART
SVCTAB   AMODE  31
SVCTAB   RMODE  ANY
***********************************************************************
* THIS PROGRAM LOCATES THE SVC TABLE AND PRINTS OUT THE ATTRIBUTES    *
* OF THE SVCS.                                                        *
* IF A PARM OF USER IS SPECIFIED, ONLY SVC NUMBERS 200-255 WILL BE    *
* LISTED.                                                             *
* GOES IN SYS2.LINKLIB.                                               *
***********************************************************************
         USING CVT,R11            CVT
         L     R11,16             CVT ADDR
         L     R11,CVTABEND       -> TO SECONDARY CVT
         DROP  R11
         USING SCVTSECT,R11       SECONDARY CVT
         L     R11,SCVTSVCT       -> TO SVC TABLE (256 ENTRIES)
         DROP  R11
         USING SVC,R11            SVC TABLE
         USING CPPL,R10
         LR    R10,R1
         L     R2,CPPLCBUF        -> TO COMMAND BUFFER
         LH    R3,2(R2)           LENGTH OR OFFSET TO OPERAND
         LA    R3,4(R3)           ADD LENGTH OF 2 LENGTH FIELDS
         AR    R3,R2              -> TO OPERAND OR NOTHING
         OC    0(4,R3),=4C' '     MAKE OPERAND UPPER CASE
         CLC   0(4,R3),=C'USER'   WAS OPERAND USER?
         BNE   NOUSER
         MVI   FLAG,X'80'         SET FLAG TO SAY USER
NOUSER   EQU   *
         USING IOPL,R9
         LA    R9,IOPLADS
         L     R3,CPPLUPT
         L     R4,CPPLECT
         SR    R10,R10            LOOP COUNTER FOR ALL SVCS
         LA    R8,SVCOP           -> TO SVC NAME TABLE
         TM    FLAG,X'80'         USER FLAG ON?
         BZ    ALLTAB             NO. DO ALL SVCS
         LA    R8,SVCUSR          -> TO FIRST USER ENTRY IN NAME TABLE
         LA    R10,200            LOOP COUNTER FOR JUST USER SVCS
         LA    R11,(SVCLEN*200)(R11)   SVC TABLE POINTER
ALLTAB   EQU   *
*        TPUT  HEAD,L'HEAD
         PUTLINE PARM=PARM,UPT=(R3),ECT=(R4),ECB=ECB1,                 *
               OUTPUT=(MSG1,TERM,SINGLE,DATA),                         *
               MF=(E,IOPLADS)
NEXTENT  EQU   *                  FORMAT SVC TABLE DATA
         MVI   HEAD,X'40'         A BLANK
         MVC   HEAD+1(79),HEAD    AND 79 MORE
         C     R10,=F'200'        ASSUME THIS IS A DUMMY ADDRESS
         BNE   *+10               AND SKIP AROUNT THE MVC
         MVC   ADDRDUMY(4),SVCEP  SAVE ADDR OF WHAT WE HOPE IS DUMMY
         CVD   R10,DOUBLE         MAKE SVC # DECIMAL
         MVC   HEAD(4),=X'40202120' MOVE SVC # INTO MESSAGE
         ED    HEAD(4),DOUBLE+6   EDIT NUMBER INTO IT
         ST    R10,FULL           SAVE SVC NUMBER
         UNPK  OUT(9),FULL(5)     UNPACK
         MVZ   OUT(8),OUT-1       FOOL WITH ZONES
         TR    OUT(8),=C'0123456789ABCDEF'  CONVERT TO CHARACTERS
         MVC   HEAD+6(4),=C'(  )' SPACE FOR SVC # IN HEX
         MVC   HEAD+7(2),OUT+6    MOVE IN HEX SVC NUMBER
         UNPK  OUT(9),SVCEP(5)    UNPACK SVC ADDRESS
         MVZ   OUT(8),OUT-1       FOOL WITH ZONES
         TR    OUT(8),=C'0123456789ABCDEF' CONVERT TO CHARACTERS
         MVC   HEAD+12(8),OUT     MOVE IN CONVERTED ADDRESS
         MVI   HEAD+12,X'40'      BLANK OUT FIRST BYTE OF ADDRESS
         CLI   HEAD+13,C'0'       TEST FOR A ZERO
         BNE   *+8                SKIP ROUND MOVE
         MVI   HEAD+13,X'40'      MAKE IT A BLANK
         MVI   HEAD+40,C'6'       IT MUST BE A TYPE 6
         TM    SVCTP,SVCTP6       IS IT A TYPE 6?
         BO    GETATTR            YES, GO GET ATTRIBUTES
         MVC   HEAD+39(3),=C'3/4' ASSUME TYPE 3 OR 4
         TM    SVCTP,SVCTP34      IS IT A TYPE 3 OR 4?
         BO    GETATTR            YES, GO GET ATTRIBUTES
         MVC   HEAD+39(3),=C' 2 ' ASSUME ITS A TYPE 2
         TM    SVCTP,SVCTP2       IS IT A TYPE 2?
         BO    GETATTR            YES, GO GET ATTRIBUTES
         MVI   HEAD+40,C'1'       ASSUME ITS A TYPE 1
GETATTR  EQU   *
         MVI   HEAD+44,X'40'      ASSUME NOT AUTHORIZED
         TM    SVCTP,SVCAPF       TEST FOR AUTHORIZED
         BZ    GETAMODE           AND FOUND IT ISN'T
         MVI   HEAD+44,C'Y'       SET IT TO AUTHORIZED
GETAMODE EQU   *
         TM    SVCEP,SVCAMODE     TEST FOR AMODE BIT SET
         BZ    GETATTR1           NOT SET
         MVC   HEAD+48(2),=C'31'  INDICATE AMODE IS 31
GETATTR1 EQU   *
         MVI   HEAD+52,X'40'      ASSUME SVC NOT PART OF THE ESR
         TM    SVCTP,SVCESR       TEST FOR PART OF ESR
         BZ    GETATTR2           AND FOUND IT ISN'T
         MVI   HEAD+52,C'Y'       SAY ITS PART OF ESR
GETATTR2 EQU   *
         MVI   HEAD+56,X'40'      ASSUME ITS NON-PREMPTIVE
         TM    SVCTP,SVCNP        TEST TO SEE
         BZ    GETATTR3           AND FOUND IT ISN'T
         MVI   HEAD+56,C'Y'       SAY IT IS
GETATTR3 EQU   *
         MVI   HEAD+60,X'40'      ASSUME IT CAN'T BE ASSISTED
         TM    SVCTP,SVCASF       TEST TO SEE
         BZ    GETATTR4           AND FOUND IT ISN'T
         MVI   HEAD+60,C'Y'       SAY IT IS
GETATTR4 EQU   *
         MVI   HEAD+64,X'40'      ASSUME IT CAN'T BE IN AR MODE
         TM    SVCATTR3,SVCAR     TEST TO SEE
         BZ    LOCK0              AND FOUND IT ISN'T
         MVI   HEAD+64,C'Y'       SAY IT IS
LOCK0    EQU   *
         LA    R2,HEAD+66         -> TO LOCK FIELD IN MSG TEXT
         TM    SVCLOCKS,SVCLL     LOCAL LOCK?
         BZ    LOCK1              NOT LOCAL LOCK
         MVC   0(6,R2),=C'LOCAL,' MOVE IN LOCAL
         LA    R2,6(R2)           BUMP POINTER
LOCK1    EQU   *
         TM    SVCLOCKS,SVCCMS    CMS LOCK?
         BZ    LOCK2              NOT CMS LOCK
         MVC   0(4,R2),=C'CMS,'   MOVE IN CMS
         LA    R2,4(R2)           BUMP POINTER
LOCK2    EQU   *
         TM    SVCLOCKS,SVCOPT    OPT LOCK?
         BZ    LOCK3              NOT OPT LOCK
         MVC   0(4,R2),=C'OPT,'   MOVE IN OPT
         LA    R2,4(R2)           BUMP POINTER
LOCK3    EQU   *
         TM    SVCLOCKS,SVCALLOC  ALLOC LOCK?
         BZ    LOCK4              NOT ALLOC LOCK
         MVC   0(6,R2),=C'ALLOC,' MOVE IN ALLOC
         LA    R2,6(R2)           BUMP POINTER
LOCK4    EQU   *
         TM    SVCLOCKS,SVCDISP   DISP LOCK?
         BZ    DONELOCK           NOT DISP LOCK
         MVC   0(5,R2),=C'DISP,'  MOVE IN DISP
         LA    R2,5(R2)           BUMP POINTER
DONELOCK EQU   *
* ---
         L     R5,SVCEP           POINT TO START OF SVC
         MVC   MSG2+4+22(58),0(R5)   COPY FIRST 48 BYTES OF SVC
         TR    MSG2+4+22(58),TRANTAB CLEAN IT UP
* ---
         BCTR  R2,0               BACK POINTER UP ONE BYTE AND
         MVI   0(R2),C' '         BLANK TRAILING COMMA
         CLM   R10,B'0001',0(R8)  IS THIS ENTRY IN TABLE?
         BNE   PUTMSG             NO, SO JUST PUT MESSAGE W/OUT NAME
         MVC   HEAD+22(14),1(R8)  MOVE SVC NAME INTO MESSAGE
         LA    R8,SVCNAML(R8)     BUMP -> TO NEXT SVC NAME ENTRY
PUTMSG   EQU   *
         PUTLINE PARM=PARM,UPT=(R3),ECT=(R4),ECB=ECB1,                 *
               OUTPUT=(MSG1,TERM,SINGLE,DATA),                         *
               MF=(E,IOPLADS)
         TM    FLAG,X'80'         WAS USER PARM SPECIFIED?
         BZ    PUTMSG1
         CLC   ADDRDUMY(4),SVCEP  IS THIS A DUMMY ENTRY?
         BE    PUTMSG1            YES. DONT DISPLAY DATA
         PUTLINE PARM=PARM,UPT=(R3),ECT=(R4),ECB=ECB1,                 *
               OUTPUT=(MSG2,TERM,SINGLE,DATA),                         *
               MF=(E,IOPLADS)
*        TPUT  HEAD,L'HEAD
PUTMSG1  EQU   *
         LA    R11,SVCLEN(R11)    -> TO NEXT SVC TABLE ENTRY
         LA    R10,1(R10)         ADD 1 TO COUNT OF SVCS
         CH    R10,=H'256'        AT END YET?
         BL    NEXTENT            NO, MORE SVCS TO TELL ABOUT YET
         MOREND
PARM     PUTLINE MF=L
ECB1     DC    F'0'
IOPLADS  DC    4F'0'
FULL     DC    F'0'
DOUBLE   DC    D'0'
         DC    F'0'               MUST PRECEED OUT
OUT      DS    2F                 WORK AREA FOR UNPK
         DS    CL1                PAD SPACE FOR UNPK
FLAG     DC    X'00'
ADDRDUMY DC    F'0'               DUMMY SVC ADDR
MSG2     DC    H'84'
         DC    H'0'
MSG2T    DC    CL80'  '           MSG 2ND LINE
MSG1     DC    H'84'
         DC    H'0'
HEAD     DC    CL80'    SVC       ADDR    ---- NAME ----  TYPE AUT AMD *
               ESR PRE ASS AR LOCKS'
*                   0123456789 123456789 123456789 123456789 123456789
*                     123  (XX)  AAAAAAAA  SVC_NAME         3   Y   31
*              123456789 123456789 123456789 123456789
*               N   Y   Y    Y ...
*
* THE SVCTABLE WAS "BORROWED" DIRECTLY FROM THE DISASSEMBLER.
*
***********************************************************************
* TRANSLATE TABLE FOR PRINTABLE CHARACTERS. ALL OTHERS ARE PERIODS    *
***********************************************************************
TRANTAB  DC    256X'4B'            BUILD IT ALL PERIODS
         ORG   TRANTAB+075         ORG BACK
         DC    C'.<(+|&&'
         ORG   TRANTAB+090         ORG BACK
         DC    C'!$*);¢-/'
         ORG   TRANTAB+107
         DC    C',%_>?'
         ORG   TRANTAB+122
         DC    C':#@''="'
         ORG   TRANTAB+193
         DC    C'ABCDEFGHI'
         ORG   TRANTAB+209
         DC    C'JKLMNOPQR'
         ORG   TRANTAB+226
         DC    C'STUVWXYZ'
         ORG   TRANTAB+240
         DC    C'0123456789'
         ORG   TRANTAB+256         ORG TO END OF TABLE
*
         COPY  DISASM3B
         PRINT NOGEN
         CVT   DSECT=YES,PREFIX=NO
         IKJCPPL
         IKJPTPB
         IKJIOPL
         IHASCVT
         IHASVC
         END
./ ADD NAME=TODCN    0127-86072-04105-1018-00242-00453-00173-TCACF0  00
TODCN    MOWSTART ,           PL/I DOESNT LIKE 8 CHAR NAMES
TODCN    AMODE  31
TODCN    RMODE  ANY
*TODCNVRT MOWSTART
***********************************************************************
* FUNCTION: CONVERT A 64 BIT TIMESTAMP OBTAINED BY STCK INTO A        *
*           CHARACTER STRING GIVING YEAR, JULIAN DATE AND TIME OF DAY *
*                                                                     *
* REVERSE ENGINEERED FROM AMDPRDMP AMDPRSEG                           *
*         BY ALAN C FIELD, OZARK AIR LINES, ST. LOUIS, MO.            *
*                                                                     *
* THE ENTRY CONDITIONS TO TODCNVRT ARE:                               *
*   R1 POINTS TO AN ARGUMENT LIST WITH 3 ADCONS                       *
*       THE FIRST ARGUMENT IS A CVTTZ VALUE FOR GMT ADJUSTMENT        *
*       THE SECOND ARGUMENT IS AN 8 BYTE TOD CLOCK VALUE FROM STCK    *
*       THE THIRD ARGUMENT IS A 24 CHARACTER RETURN AREA              *
*           VALUE RETURNED IS YYYYDDDHH.MM.SS.MMMMMM                  *
* THE PROGRAM MASK IS DISABLED FOR FIXED POINT OVERFLOW               *
***********************************************************************
         LA    R2,1            A F'1' MEANING 'RETURN FULL DATE'
*        LA    R2,2            TO GET TIME IN SSSSS.MMMMMM FORM
         SR    R0,R0                       CLEAR REG
         SPM   R0                          DISABLE FIXED POINT OVFLW
         L     R7,4(,R1)                   POINT TO TIMESTAMP
         MVC   TIMESTMP(8),0(R7)           MOVE IT TO OUR AREA
*        TM    127(R12),X'20'              REQUIRED TO OFFSET FOR GMT?
*        BNO   LAB1                        NO
         L     R7,0(,R1)                   GET CVTTZ, TIME ZONE DIFF
         ICM   R14,15,0(R7)                PUT IT INTO A REGISTER
         AL    R14,TIMESTMP                ADD IT TO THE TIMESTAMP
         ST    R14,TIMESTMP                STORE IT BACK
LAB1     LM    R4,R5,TIMESTMP              GET TIMESTAMP INTO REGS
         SRDL  R4,12                       DIVIDE BY 4096
         D     R4,SIXMILL                  DIVIDE RESULT BY ...
         LR    R7,R2                       COPY
         SLA   R7,2                        MULTIPLY BY 4
         L     R7,ATAB(R7)                 BRANCH TABLE
         BR    R7                          GO TO RIGHT PLACE
         SPACE
RELTVTME L     R7,4(,R1)                   POINT TO TIMESTAMP
         CLC   0(8,R7),TIME2               COMPARE IT WITH ...
         BNE   TOD1A
         L     R7,8(,R1)                   -> TO RETURN AREA
         MVI   12(R7),C' '                 MOVE IN A BLANK
         MVC   13(11,R7),12(R7)            AND BLANK LAST HALF
         MVC   0(12,R7),ZERO1              MOVE IN ....
         LA    R15,4                       SET RETURN CODE
         B     FIN                         RETURN
         SPACE
TOD1A    LA    R7,WORK2
         L     R14,MILLION
         LR    R15,R4                      COPY REGISTER
         ST    R14,WORK1
         SLR   R14,R14                     CLEAR REG
         D     R14,WORK1                   DIVIDE BY ...
         ST    R15,0(,R7)                  STORE RESULT IN
         LR    R14,R4                      COPY REGISTER
         SRDA  R14,32                      DIVIDE
         D     R14,WORK1
         LR    R4,R14                      COPY REG
         L     R2,8(,R1)                   POINT TO RETURN AREA
         LA    R2,6(,R2)                   AND POINT 6 BYTES IN
         CVD   R4,TIMESTMP                 MAKE IT DECIMAL
         UNPK  0(6,R2),TIMESTMP+4(4)       AND PRINTABLE
         OI    5(R2),X'F0'                 INCL LAST CHAR
         L     R7,8(,R1)                   POINT TO RETURN AREA
         MVI   5(R7),X'4B'                 MOVE IN A PERIOD
         LR    R14,R5                      COPY REG
         SRDA  R14,32                      DIVIDE BY ...
         D     R14,MINSPDAY                MINUTES IN A DAY
         MH    R14,=H'60'                  MULTIPLY BY 60
         LA    R15,WORK2                   -> TO ...
         AL    R14,0(,R15)
         LR    R4,R14                      COPY REG
         LR    R2,R7                       COPY REG
         CVD   R4,TIMESTMP                 MAKE IT DECIMAL
         UNPK  0(5,R2),TIMESTMP+5(3)       AND PRINTABLE
         OI    4(R2),X'F0'                 MAKE IT PRINTABLE
         SLR   R15,R15                     SET RC
         B     FIN                         GO BACK
         SPACE
FULLDATE L     R7,4(,R1)                   POINT TO INPUT TIMESTAMP
         CLC   0(8,R7),TIME2               COMPARE WITH ...
         BNE   TOD2A                       NOT EQUAL, GO TO ...
         L     R7,8(,R1)                   POINT TO RETURN AREA
         MVI   22(R7),C' '                 MOVE IN A BLANK
         MVI   23(R7),C' '                 MOVE IN A BLANK
         MVC   0(22,R7),ZERO2              MOVE ....
         LA    R15,4                       SET RC
         B     FIN                         RETURN
         SPACE
TOD2A    LA    R7,WORK2                    POINT TO ...
         L     R14,MILLION                 LOAD IN A MILLION
         LR    R15,R4                      COPY REG
         ST    R14,WORK1                   SAVE IT IN WORK
         SLR   R14,R14                     CLEAR IT
         D     R14,WORK1                   DIVIDE BY 10E6
         ST    R15,0(,R7)                  STORE IT IN WORK
         LR    R14,R4                      COPY AGAIN
         SRDA  R14,32                      MOVE IT DOWN
         D     R14,WORK1                   DIVIDE BY 10E6
         LR    R4,R14                      COPY
         L     R2,8(,R1)                   -> TO 3ND ARG, RETURN AREA
         LA    R2,16(,R2)                  AND POINT 16 BYTES IN
         CVD   R4,TIMESTMP                 CONVERT TO DECIMAL
         UNPK  0(6,R2),TIMESTMP+4(4)       MOVE IN DECIMALS OF SECS
         OI    5(R2),X'F0'                 LAST DIGIT PRINTABLE
         L     R7,8(,R1)                   -> TO 3RD ARG
         MVI   15(R7),X'4B'                MOVE IN A PERIOD
         LA    R14,WORK2                   -> WORK
         L     R4,0(,R14)                  GET DATA PTD TO BY R14
         LA    R2,13(,R7)                  -> TO SS IN RETURN AREA
         CVD   R4,TIMESTMP                 CONVERT SECONDS
         UNPK  0(2,R2),TIMESTMP+6(2)       MOVE IT IN
         OI    1(R2),X'F0'                 PRINTABLE
         L     R7,8(,R1)                   -> TO 3RD ARG
         MVI   12(R7),X'4B'                MOVE IN A PERIOD
         LA    R14,60                      GET A 60
         LR    R15,R5                      COPY REG
         ST    R14,WORK1                   SAVE OUR 60
         SLR   R14,R14                     CLEAR A REG
         D     R14,WORK1                   DIVIDE BY 60
         ST    R15,WORK2                   SAVE RESULT
         LR    R14,R5                      COPY
         SRDA  R14,32                      SHIFT IT DOWN
         D     R14,WORK1                   DIVIDE BY 60
         LR    R4,R14                      COPY
         LA    R2,10(,R7)                  -> TO MM IN RETURN AREA
         CVD   R4,TIMESTMP                 MAKE IT DECIMAL
         UNPK  0(2,R2),TIMESTMP+6(2)       MOVE IT INTO RETURN AREA
         OI    1(R2),X'F0'                 MAKE IT PRINTABLE
         L     R7,8(,R1)                   -> TO 3RD ARG
         MVI   9(R7),X'4B'                 MOVE IN A PERIOD
         L     R5,WORK2                    COPY
         LA    R14,24                      HOURS IN A DAY
         LR    R15,R5                      COPY
         ST    R14,WORK1                   SAVE OUR 24
         SLR   R14,R14                     CLEAR IT
         D     R14,WORK1                   DIVIDE BY 24
         ST    R15,WORK2                   SAVE RESULT
         LR    R14,R5                      COPY
         SRDA  R14,32                      SHIFT IT DOWN
         D     R14,WORK1                   DIVIDE BY 24
         LR    R4,R14                      COPY
         LA    R2,7(,R7)                   -> POINT TO HH IN RESULT
         CVD   R4,TIMESTMP                 MAKE IT DECIMAL
         UNPK  0(2,R2),TIMESTMP+6(2)       AND PRINTABLE
         OI    1(R2),X'F0'                 ..
         L     R7,WORK2                    GET OUR VALUE
         C     R7,FOURYR                   COMPARE WITH DAYS IN 4 YR
         BNL   A3C
         L     R7,WORK2                    GET IT AGAIN
         LA    R14,365                     DAYS IN A YEAR
         ST    R14,WORK1                   SAVE IT
         LR    R14,R7                      COPY
         SRDA  R14,32                      MOVE IT DOWN AGAIN
         D     R14,WORK1                   DIVIDE BY DAYS IN YR
         AL    R14,F1                      ADD ONE
         LR    R3,R14                      COPY
         LR    R14,R7                      COPY
         SRDA  R14,32                      MOVE IT DOWN AGAIN
         D     R14,WORK1                   DIVIDE
         AL    R15,F1900                   ADD IN 1900
         LR    R6,R15                      COPY
         B     AAC
A3C      L     R7,WORK2                    COPY
         SL    R7,FOURYR                   SUBTRACT DAYS IN 4 YEARS
         ST    R7,WORK2                    SAVE IT
         LA    R14,1461                    DAYS IN 4 YRS, INCL LEAP
         ST    R14,WORK1                   SAVE IT
         LR    R14,R7                      COPY
         SRDA  R14,32                      SHIFT IT DOWN
         D     R14,WORK1                   DIVIDE
         LR    R5,R15                      COPY
         LR    R14,R7                      COPY
         SRDA  R14,32                      SHIFT IT
         D     R14,WORK1                   DIVIDE
         LR    R4,R14                      COPY
         LR    R15,R4                      COPY
         SLR   R14,R14                     CLEAR
         D     R14,TWOYEAR                 DAYS IN 2 YEARS
         LR    R14,R15                     COPY
         ALR   R14,R4                      ADD
         LR    R15,R4                      COPY
         ST    R14,WORK1                   SAVE IT
         SLR   R14,R14                     CLEAR
         D     R14,THREEYR                 DAYS IN 3 YEARS
         LR    R14,R15                     COPY
         AL    R14,WORK1                   ADD
         SRDA  R14,32                      MOVE IT DOWN
         D     R14,LEAPYEAR                DAYS IN A LEAP YEAR
         AL    R14,F1                      ADD 1
         LR    R3,R14                      COPY
         LR    R6,R5                       COPY
         SLA   R6,2                        MULTIPLY BY 4
         AL    R6,F1904                    1904
         LR    R14,R4                      COPY
         BCTR  R14,0                       SUBTRACT 1
         SRDA  R14,32                      MOVE IT DOWN
         D     R14,YEAR                    DAYS IN A YEAR
         ALR   R6,R15                      ADD
AAC      L     R2,8(,R1)                   -> 3RD ARG
         LA    R2,4(,R2)                   -> DDD IN RETURN FIELD
         CVD   R3,TIMESTMP                 MAKE IT DECIMAL
         UNPK  0(3,R2),TIMESTMP+6(2)       MOVE IT INTO RETURN AREA
         OI    2(R2),X'F0'                 MAKE IT PRINTABLE
         L     R2,8(,R1)                   -> 3RD ARG
         CVD   R6,TIMESTMP                 MAKE IT DECIMAL
         UNPK  0(4,R2),TIMESTMP+5(3)       MOVE IN YYYY
         OI    3(R2),X'F0'                 MAKE IT PRINTABLE
         SLR   R15,R15                     SET RC
FIN      EQU   *
         SPM   R3                          TURN ON FIXED OVFLW
         MOREND RC=(15)
         DS    0D                          ALIGN ON DOUBLEWORD
TIMESTMP DC    CL8' '
TIME2    DC    CL8' '
WORK1    DC    F'0'
WORK2    DC    F'0'
F1       DC    F'00001'
F4       DC    F'00004'
F5       DC    F'00005'
F8       DC    F'00008'
F9       DC    F'00009'
F12      DC    F'00012'
YEAR     DC    F'00365'
LEAPYEAR DC    F'00366'
TWOYEAR  DC    F'00731'
THREEYR  DC    F'01096'
MINSPDAY DC    F'01440'
FOURYR   DC    F'01460'      DAYS IN 4 YRS, EXCL LEAP YEAR
F1900    DC    F'01900'
F1904    DC    F'01904'
F2000    DC    F'02000'
MILLION  DC    F'1000000'
SIXMILL  DC    F'60000000'               SIXTY MILLION
ZERO1    DC    C'00000.000000'           SSSSS.MMMMMM (SINCE MIDNIGHT)
ZERO2    DC    C'000000000.00.00.000000' YYYYDDDHH.MM.SS.MMMMMM
ATAB     DC    A(0)
         DC    A(FULLDATE)
         DC    A(RELTVTME)
         END
